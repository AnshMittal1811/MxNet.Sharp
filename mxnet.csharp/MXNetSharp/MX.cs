using _003CStartupCode_0024MXNetSharp_003E;
using Microsoft.FSharp.Collections;
using Microsoft.FSharp.Core;
using MXNetSharp.Interop;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;

namespace MXNetSharp
{
	[Serializable]
	[CompilationMapping(/*Could not decode attribute arguments.*/)]
	public class MX
	{
		public static t NoArg<t>()
		{
			throw new NotSupportedException("Dynamic invocation of get_NoArg is not supported");
		}

		public static NDArray[] CustomFunctionNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_CustomFunction");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.CustomFunctionNDArray_004018();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void CustomFunction(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_CustomFunction");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004022_002D2();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004023_002D2();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.CustomFunction_004024(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027_002D1(), outputArray)), names, vals);
		}

		public static SymbolOperators.CustomFunction CustomFunction()
		{
			return new SymbolOperators.CustomFunction();
		}

		public static NDArray[] CachedOp(params NDArray[] data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_CachedOp");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004039_002D2();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.CachedOp_004042();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				array4[j] = val2.Invoke(array3[j]);
			}
			return array4;
		}

		public static void CachedOp(IEnumerable<NDArray> outputArray, params NDArray[] data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_CachedOp");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004047_002D3();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004048_002D3();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.CachedOp_004049_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004051_002D3();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004052_002D4(), outputArray)), names, vals);
		}

		public static SymbolOperators.CachedOp CachedOp(params Symbol[] data)
		{
			return new SymbolOperators.CachedOp(data);
		}

		public static NDArray Cvimdecode(NDArray buf, int flag = 1, bool toRgb = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cvimdecode");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004069_002D5(buf, 0, current));
			string[] parameterKeys = new string[2]
			{
				"flag",
				"to_rgb"
			};
			string[] array = new string[2];
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = toRgb;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Cvimdecode(IEnumerable<NDArray> outputArray, NDArray buf, int flag = 1, bool toRgb = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cvimdecode");
			string[] names2 = new string[2]
			{
				"flag",
				"to_rgb"
			};
			string[] array = new string[2];
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = toRgb;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Cvimdecode_004083(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004085_002D6(buf, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004086_002D7(), outputArray)), names, vals);
		}

		public static NDArray CvimreadNDArray(string filename, int flag = 1, bool toRgb = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cvimread");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"filename",
				"flag",
				"to_rgb"
			};
			string[] obj = new string[3]
			{
				filename,
				null,
				null
			};
			object obj2 = flag;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			obj[1] = (string)obj3;
			bool flag2 = toRgb;
			object obj5 = flag2;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable3 = obj5 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj6 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			obj[2] = (string)obj6;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, obj);
			return new NDArray(outputs[0]);
		}

		public static void Cvimread(IEnumerable<NDArray> outputArray, string filename, int flag = 1, bool toRgb = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cvimread");
			string[] names2 = new string[3]
			{
				"filename",
				"flag",
				"to_rgb"
			};
			string[] obj = new string[3]
			{
				filename,
				null,
				null
			};
			object obj2 = flag;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			obj[1] = (string)obj3;
			bool flag2 = toRgb;
			object obj5 = flag2;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable3 = obj5 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj6 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			obj[2] = (string)obj6;
			string[] vals2 = obj;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Cvimread_0040113(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040116_002D8(), outputArray)), names, vals);
		}

		public static SymbolOperators.Cvimread Cvimread(string filename, [Optional] [OptionalArgument] FSharpOption<int> flag, [Optional] [OptionalArgument] FSharpOption<bool> toRgb)
		{
			return new SymbolOperators.Cvimread(filename, flag, toRgb);
		}

		public static NDArray Cvimresize(NDArray src, int w, int h, int interp = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cvimresize");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040137_002D9(src, 0, current));
			string[] parameterKeys = new string[3]
			{
				"w",
				"h",
				"interp"
			};
			string[] array = new string[3];
			object obj = w;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = h;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = interp;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Cvimresize(IEnumerable<NDArray> outputArray, NDArray src, int w, int h, int interp = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cvimresize");
			string[] names2 = new string[3]
			{
				"w",
				"h",
				"interp"
			};
			string[] array = new string[3];
			object obj = w;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = h;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = interp;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Cvimresize_0040152(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040154_002D10(src, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040155_002D11(), outputArray)), names, vals);
		}

		public static NDArray CvcopyMakeBorder(NDArray src, int top, int bot, int left, int right, IEnumerable<double> values, int fillingType = 0, double value = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cvcopyMakeBorder");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040180_002D12(src, 0, current));
			string[] parameterKeys = new string[7]
			{
				"top",
				"bot",
				"left",
				"right",
				"values",
				"type",
				"value"
			};
			string[] array = new string[7];
			object obj = top;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = bot;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = left;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = right;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13;
			if (values != null)
			{
				IFormattable formattable9 = values as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = values;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15 = fillingType;
			object obj16;
			if (obj15 != null)
			{
				IFormattable formattable11 = obj15 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = obj15;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			object obj18 = value;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable13 = obj18 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[6] = (string)obj19;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void CvcopyMakeBorder(IEnumerable<NDArray> outputArray, NDArray src, int top, int bot, int left, int right, IEnumerable<double> values, int fillingType = 0, double value = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cvcopyMakeBorder");
			string[] names2 = new string[7]
			{
				"top",
				"bot",
				"left",
				"right",
				"values",
				"type",
				"value"
			};
			string[] array = new string[7];
			object obj = top;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = bot;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = left;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = right;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13;
			if (values != null)
			{
				IFormattable formattable9 = values as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = values;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15 = fillingType;
			object obj16;
			if (obj15 != null)
			{
				IFormattable formattable11 = obj15 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = obj15;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			object obj18 = value;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable13 = obj18 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[6] = (string)obj19;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.CvcopyMakeBorder_0040207(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040209_002D13(src, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040210_002D14(), outputArray)), names, vals);
		}

		public static NDArray Copyto(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_copyto");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040219_002D15(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Copyto(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_copyto");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_0040227_002D4();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_0040228_002D4();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Copyto_0040229(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040231_002D16(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040232_002D17(), outputArray)), names, vals);
		}

		public static NDArray NoGradientNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_NoGradient");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NoGradient(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_NoGradient");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_0040249_002D5();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_0040250_002D5();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NoGradient_0040251(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040254_002D18(), outputArray)), names, vals);
		}

		public static SymbolOperators.NoGradient NoGradient()
		{
			return new SymbolOperators.NoGradient();
		}

		public static NDArray BatchNormV1(NDArray data, NDArray gamma, NDArray beta, double eps = 0.001, double momentum = 0.9, bool fixGamma = true, bool useGlobalStats = false, bool outputMeanVar = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("BatchNorm_v1");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040328_002D19(data, gamma, beta, 0, current));
			string[] parameterKeys = new string[5]
			{
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var"
			};
			string[] array = new string[5];
			object obj = eps;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = fixGamma;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			bool flag2 = useGlobalStats;
			object obj10 = flag2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag3 = outputMeanVar;
			object obj13 = flag3;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void BatchNormV1(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, NDArray beta, double eps = 0.001, double momentum = 0.9, bool fixGamma = true, bool useGlobalStats = false, bool outputMeanVar = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("BatchNorm_v1");
			string[] names2 = new string[5]
			{
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var"
			};
			string[] array = new string[5];
			object obj = eps;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = fixGamma;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			bool flag2 = useGlobalStats;
			object obj10 = flag2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag3 = outputMeanVar;
			object obj13 = flag3;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BatchNormV1_0040401(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040403_002D20(data, gamma, beta, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040404_002D21(), outputArray)), names, vals);
		}

		public static SymbolOperators.BatchNormV1 BatchNormV1([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar)
		{
			return new SymbolOperators.BatchNormV1(data, gamma, beta, eps, momentum, fixGamma, useGlobalStats, outputMeanVar);
		}

		public static NDArray MpAdamwUpdate(NDArray weight, NDArray grad, NDArray mean, NDArray var, NDArray weight32, NDArray rescaleGrad, double lr, double eta, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double wd = 0.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_mp_adamw_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040521_002D22(weight, grad, mean, var, weight32, rescaleGrad, 0, current));
			string[] parameterKeys = new string[7]
			{
				"lr",
				"eta",
				"beta1",
				"beta2",
				"epsilon",
				"wd",
				"clip_gradient"
			};
			string[] array = new string[7];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eta;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = wd;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipGradient;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MpAdamwUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mean, NDArray var, NDArray weight32, NDArray rescaleGrad, double lr, double eta, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double wd = 0.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_mp_adamw_update");
			string[] names2 = new string[7]
			{
				"lr",
				"eta",
				"beta1",
				"beta2",
				"epsilon",
				"wd",
				"clip_gradient"
			};
			string[] array = new string[7];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eta;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = wd;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipGradient;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MpAdamwUpdate_0040582(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040584_002D23(weight, grad, mean, var, weight32, rescaleGrad, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040585_002D24(), outputArray)), names, vals);
		}

		public static SymbolOperators.MpAdamwUpdate MpAdamwUpdate(Symbol weight, Symbol grad, Symbol mean, Symbol var, Symbol weight32, Symbol rescaleGrad, double lr, double eta, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.MpAdamwUpdate(weight, grad, mean, var, weight32, rescaleGrad, lr, eta, beta1, beta2, epsilon, wd, clipGradient);
		}

		public static SymbolOperators.MpAdamwUpdate MpAdamwUpdate(double lr, double eta, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mean, [Optional] [OptionalArgument] FSharpOption<Symbol> var, [Optional] [OptionalArgument] FSharpOption<Symbol> weight32, [Optional] [OptionalArgument] FSharpOption<Symbol> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.MpAdamwUpdate(lr, eta, weight, grad, mean, var, weight32, rescaleGrad, beta1, beta2, epsilon, wd, clipGradient);
		}

		public static NDArray AdamwUpdate(NDArray weight, NDArray grad, NDArray mean, NDArray var, NDArray rescaleGrad, double lr, double eta, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double wd = 0.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_adamw_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040722_002D25(weight, grad, mean, var, rescaleGrad, 0, current));
			string[] parameterKeys = new string[7]
			{
				"lr",
				"eta",
				"beta1",
				"beta2",
				"epsilon",
				"wd",
				"clip_gradient"
			};
			string[] array = new string[7];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eta;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = wd;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipGradient;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void AdamwUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mean, NDArray var, NDArray rescaleGrad, double lr, double eta, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double wd = 0.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_adamw_update");
			string[] names2 = new string[7]
			{
				"lr",
				"eta",
				"beta1",
				"beta2",
				"epsilon",
				"wd",
				"clip_gradient"
			};
			string[] array = new string[7];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eta;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = wd;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipGradient;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.AdamwUpdate_0040779(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_0040781_002D26(weight, grad, mean, var, rescaleGrad, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040782_002D27(), outputArray)), names, vals);
		}

		public static SymbolOperators.AdamwUpdate AdamwUpdate(Symbol weight, Symbol grad, Symbol mean, Symbol var, Symbol rescaleGrad, double lr, double eta, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.AdamwUpdate(weight, grad, mean, var, rescaleGrad, lr, eta, beta1, beta2, epsilon, wd, clipGradient);
		}

		public static SymbolOperators.AdamwUpdate AdamwUpdate(double lr, double eta, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mean, [Optional] [OptionalArgument] FSharpOption<Symbol> var, [Optional] [OptionalArgument] FSharpOption<Symbol> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.AdamwUpdate(lr, eta, weight, grad, mean, var, rescaleGrad, beta1, beta2, epsilon, wd, clipGradient);
		}

		public static NDArray[] MultiAdamwUpdate(params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, IEnumerable<double> etas, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_multi_adamw_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_0040909_002D28();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[8]
			{
				"lrs",
				"wds",
				"etas",
				"beta1",
				"beta2",
				"epsilon",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[8];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array2[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array2[1] = (string)obj3;
			object obj5;
			if (etas != null)
			{
				IFormattable formattable5 = etas as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj5 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = etas;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[2] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable7 = obj7 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj8 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array2[3] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable9 = obj10 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj11 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array2[4] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable11 = obj13 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj14 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array2[5] = (string)obj14;
			object obj16 = clipGradient;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable13 = obj16 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj17 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array2[6] = (string)obj17;
			object obj19 = numWeights;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable15 = obj19 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj20 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array2[7] = (string)obj20;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.MultiAdamwUpdate_0040912();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void MultiAdamwUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, IEnumerable<double> etas, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_multi_adamw_update");
			string[] names2 = new string[8]
			{
				"lrs",
				"wds",
				"etas",
				"beta1",
				"beta2",
				"epsilon",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[8];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if (etas != null)
			{
				IFormattable formattable5 = etas as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj5 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = etas;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable7 = obj7 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj8 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable9 = obj10 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj11 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[4] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable11 = obj13 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj14 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[5] = (string)obj14;
			object obj16 = clipGradient;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable13 = obj16 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj17 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[6] = (string)obj17;
			object obj19 = numWeights;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable15 = obj19 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj20 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[7] = (string)obj20;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiAdamwUpdate_0040962_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_0040964_002D29();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_0040965_002D30(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiAdamwUpdate MultiAdamwUpdate(IEnumerable<Symbol> data, IEnumerable<double> lrs, IEnumerable<double> wds, IEnumerable<double> etas, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiAdamwUpdate(data, lrs, wds, etas, beta1, beta2, epsilon, clipGradient, numWeights);
		}

		public static SymbolOperators.MultiAdamwUpdate MultiAdamwUpdate(IEnumerable<double> lrs, IEnumerable<double> wds, IEnumerable<double> etas, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiAdamwUpdate(lrs, wds, etas, data, beta1, beta2, epsilon, clipGradient, numWeights);
		}

		public static NDArray[] MultiMpAdamwUpdate(params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, IEnumerable<double> etas, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_multi_mp_adamw_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00401090_002D31();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[8]
			{
				"lrs",
				"wds",
				"etas",
				"beta1",
				"beta2",
				"epsilon",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[8];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array2[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array2[1] = (string)obj3;
			object obj5;
			if (etas != null)
			{
				IFormattable formattable5 = etas as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj5 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = etas;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[2] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable7 = obj7 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj8 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array2[3] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable9 = obj10 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj11 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array2[4] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable11 = obj13 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj14 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array2[5] = (string)obj14;
			object obj16 = clipGradient;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable13 = obj16 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj17 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array2[6] = (string)obj17;
			object obj19 = numWeights;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable15 = obj19 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj20 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array2[7] = (string)obj20;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.MultiMpAdamwUpdate_00401093();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void MultiMpAdamwUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, IEnumerable<double> etas, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_multi_mp_adamw_update");
			string[] names2 = new string[8]
			{
				"lrs",
				"wds",
				"etas",
				"beta1",
				"beta2",
				"epsilon",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[8];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if (etas != null)
			{
				IFormattable formattable5 = etas as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj5 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = etas;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable7 = obj7 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj8 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable9 = obj10 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj11 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[4] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable11 = obj13 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj14 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[5] = (string)obj14;
			object obj16 = clipGradient;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable13 = obj16 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj17 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[6] = (string)obj17;
			object obj19 = numWeights;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable15 = obj19 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj20 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[7] = (string)obj20;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiMpAdamwUpdate_00401143_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00401145_002D32();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401146_002D33(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiMpAdamwUpdate MultiMpAdamwUpdate(IEnumerable<Symbol> data, IEnumerable<double> lrs, IEnumerable<double> wds, IEnumerable<double> etas, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiMpAdamwUpdate(data, lrs, wds, etas, beta1, beta2, epsilon, clipGradient, numWeights);
		}

		public static SymbolOperators.MultiMpAdamwUpdate MultiMpAdamwUpdate(IEnumerable<double> lrs, IEnumerable<double> wds, IEnumerable<double> etas, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiMpAdamwUpdate(lrs, wds, etas, data, beta1, beta2, epsilon, clipGradient, numWeights);
		}

		public static NDArray ContribAdaptiveAvgPooling2D(NDArray data, [Optional] IEnumerable<int> outputSize)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_AdaptiveAvgPooling2D");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401243_002D34(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"output_size"
			};
			string[] array = new string[1];
			object obj;
			if ((outputSize == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00401245_002D35(), outputSize));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribAdaptiveAvgPooling2D(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> outputSize)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_AdaptiveAvgPooling2D");
			string[] names2 = new string[1]
			{
				"output_size"
			};
			string[] array = new string[1];
			object obj;
			if ((outputSize == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00401266_002D6(), outputSize));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribAdaptiveAvgPooling2D_00401267(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401269_002D36(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401270_002D37(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribAdaptiveAvgPooling2D ContribAdaptiveAvgPooling2D([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> outputSize)
		{
			return new SymbolOperators.ContribAdaptiveAvgPooling2D(data, outputSize);
		}

		public static NDArray AllFinite(NDArray data, bool initOutput = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("all_finite");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401302_002D38(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"init_output"
			};
			string[] array = new string[1];
			bool flag = initOutput;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void AllFinite(IEnumerable<NDArray> outputArray, NDArray data, bool initOutput = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("all_finite");
			string[] names2 = new string[1]
			{
				"init_output"
			};
			string[] array = new string[1];
			bool flag = initOutput;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.AllFinite_00401317(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401319_002D39(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401320_002D40(), outputArray)), names, vals);
		}

		public static NDArray MultiAllFinite(params NDArray[] data, int numArrays = 1, bool initOutput = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_all_finite");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00401335_002D41();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_arrays",
				"init_output"
			};
			string[] array2 = new string[2];
			object obj = numArrays;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			bool flag = initOutput;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			return new NDArray(outputs[0]);
		}

		public static void MultiAllFinite(IEnumerable<NDArray> outputArray, params NDArray[] data, int numArrays = 1, bool initOutput = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_all_finite");
			string[] names2 = new string[2]
			{
				"num_arrays",
				"init_output"
			};
			string[] array = new string[2];
			object obj = numArrays;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = initOutput;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiAllFinite_00401351(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00401353_002D42();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401354_002D43(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiAllFinite MultiAllFinite([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> numArrays, [Optional] [OptionalArgument] FSharpOption<bool> initOutput)
		{
			return new SymbolOperators.MultiAllFinite(data, numArrays, initOutput);
		}

		public static NDArray[] ContribAllclose(NDArray a, NDArray b, double rtol = 1E-05, double atol = 1E-08, bool equalNan = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_allclose");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401405_002D44(a, b, 0, current));
			string[] parameterKeys = new string[3]
			{
				"rtol",
				"atol",
				"equal_nan"
			};
			string[] array = new string[3];
			object obj = rtol;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = atol;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = equalNan;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribAllclose_00401408();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribAllclose(IEnumerable<NDArray> outputArray, NDArray a, NDArray b, double rtol = 1E-05, double atol = 1E-08, bool equalNan = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_allclose");
			string[] names2 = new string[3]
			{
				"rtol",
				"atol",
				"equal_nan"
			};
			string[] array = new string[3];
			object obj = rtol;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = atol;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = equalNan;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribAllclose_00401449_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401451_002D45(a, b, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401452_002D46(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribAllclose ContribAllclose([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<Symbol> b, [Optional] [OptionalArgument] FSharpOption<double> rtol, [Optional] [OptionalArgument] FSharpOption<double> atol, [Optional] [OptionalArgument] FSharpOption<bool> equalNan)
		{
			return new SymbolOperators.ContribAllclose(a, b, rtol, atol, equalNan);
		}

		public static NDArray ContribBilinearResize2D(NDArray data, NDArray like, [Optional] [OptionalArgument] FSharpOption<int> height, [Optional] [OptionalArgument] FSharpOption<int> width, [Optional] [OptionalArgument] FSharpOption<double> scaleHeight, [Optional] [OptionalArgument] FSharpOption<double> scaleWidth, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribBilinearResize2DMode> mode, [Optional] [OptionalArgument] FSharpOption<bool> alignCorners)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_BilinearResize2D");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401519_002D47(data, like, 0, current));
			string[] parameterKeys = new string[6]
			{
				"height",
				"width",
				"scale_height",
				"scale_width",
				"mode",
				"align_corners"
			};
			string[] array = new string[6];
			object obj;
			if (height == null)
			{
				obj = "1";
			}
			else
			{
				FSharpOption<int> val = height;
				int height2 = val.get_Value();
				int num = height2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (width == null)
			{
				obj4 = "1";
			}
			else
			{
				FSharpOption<int> val2 = width;
				int width2 = val2.get_Value();
				int num2 = width2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (scaleHeight == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<double> val3 = scaleHeight;
				double scaleHeight2 = val3.get_Value();
				double num3 = scaleHeight2;
				object obj8 = num3;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (scaleWidth == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<double> val4 = scaleWidth;
				double scaleWidth2 = val4.get_Value();
				double num4 = scaleWidth2;
				object obj11 = num4;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (mode == null)
			{
				obj13 = "size";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.ContribBilinearResize2DMode> val5 = mode;
				GeneratedArgumentTypes.ContribBilinearResize2DMode mode2 = val5.get_Value();
				GeneratedArgumentTypes.ContribBilinearResize2DMode contribBilinearResize2DMode = mode2;
				object obj14 = contribBilinearResize2DMode;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			object obj16;
			if (alignCorners == null)
			{
				obj16 = "true";
			}
			else
			{
				FSharpOption<bool> val6 = alignCorners;
				bool alignCorners2 = val6.get_Value();
				bool flag = alignCorners2;
				object obj17 = flag;
				if (obj17 != null)
				{
					IFormattable formattable11 = obj17 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[5] = (string)obj16;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribBilinearResize2D(IEnumerable<NDArray> outputArray, NDArray data, NDArray like, [Optional] [OptionalArgument] FSharpOption<int> height, [Optional] [OptionalArgument] FSharpOption<int> width, [Optional] [OptionalArgument] FSharpOption<double> scaleHeight, [Optional] [OptionalArgument] FSharpOption<double> scaleWidth, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribBilinearResize2DMode> mode, [Optional] [OptionalArgument] FSharpOption<bool> alignCorners)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_BilinearResize2D");
			string[] names2 = new string[6]
			{
				"height",
				"width",
				"scale_height",
				"scale_width",
				"mode",
				"align_corners"
			};
			string[] array = new string[6];
			object obj;
			if (height == null)
			{
				obj = "1";
			}
			else
			{
				FSharpOption<int> val = height;
				int height2 = val.get_Value();
				int num = height2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (width == null)
			{
				obj4 = "1";
			}
			else
			{
				FSharpOption<int> val2 = width;
				int width2 = val2.get_Value();
				int num2 = width2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (scaleHeight == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<double> val3 = scaleHeight;
				double scaleHeight2 = val3.get_Value();
				double num3 = scaleHeight2;
				object obj8 = num3;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (scaleWidth == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<double> val4 = scaleWidth;
				double scaleWidth2 = val4.get_Value();
				double num4 = scaleWidth2;
				object obj11 = num4;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (mode == null)
			{
				obj13 = "size";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.ContribBilinearResize2DMode> val5 = mode;
				GeneratedArgumentTypes.ContribBilinearResize2DMode mode2 = val5.get_Value();
				GeneratedArgumentTypes.ContribBilinearResize2DMode contribBilinearResize2DMode = mode2;
				object obj14 = contribBilinearResize2DMode;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			object obj16;
			if (alignCorners == null)
			{
				obj16 = "true";
			}
			else
			{
				FSharpOption<bool> val6 = alignCorners;
				bool alignCorners2 = val6.get_Value();
				bool flag = alignCorners2;
				object obj17 = flag;
				if (obj17 != null)
				{
					IFormattable formattable11 = obj17 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[5] = (string)obj16;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBilinearResize2D_00401556(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401558_002D48(data, like, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401559_002D49(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBilinearResize2D ContribBilinearResize2D([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> like, [Optional] [OptionalArgument] FSharpOption<int> height, [Optional] [OptionalArgument] FSharpOption<int> width, [Optional] [OptionalArgument] FSharpOption<double> scaleHeight, [Optional] [OptionalArgument] FSharpOption<double> scaleWidth, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribBilinearResize2DMode> mode, [Optional] [OptionalArgument] FSharpOption<bool> alignCorners)
		{
			return new SymbolOperators.ContribBilinearResize2D(data, like, height, width, scaleHeight, scaleWidth, mode, alignCorners);
		}

		public static NDArray ContribBooleanMask(NDArray data, NDArray index, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_boolean_mask");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401609_002D50(data, index, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribBooleanMask(IEnumerable<NDArray> outputArray, NDArray data, NDArray index, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_boolean_mask");
			string[] names2 = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBooleanMask_00401637(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401639_002D51(data, index, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401640_002D52(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBooleanMask ContribBooleanMask([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> index, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.ContribBooleanMask(data, index, axis);
		}

		public static Tuple<NDArray, NDArray> ContribBoxNms(NDArray data, double overlapThresh = 0.5, double validThresh = 0.0, int topk = -1, int coordStart = 2, int scoreIndex = 1, int idIndex = -1, int backgroundId = -1, bool forceSuppress = false, [Optional] GeneratedArgumentTypes.Format inFormat, [Optional] GeneratedArgumentTypes.Format outFormat)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_box_nms");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401751_002D53(data, 0, current));
			string[] parameterKeys = new string[10]
			{
				"overlap_thresh",
				"valid_thresh",
				"topk",
				"coord_start",
				"score_index",
				"id_index",
				"background_id",
				"force_suppress",
				"in_format",
				"out_format"
			};
			string[] array = new string[10];
			object obj = overlapThresh;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = validThresh;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = topk;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = coordStart;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = scoreIndex;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = idIndex;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = backgroundId;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			bool flag = forceSuppress;
			object obj22 = flag;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			object obj25;
			if ((inFormat == null) ? true : false)
			{
				obj25 = "corner";
			}
			else if (inFormat != null)
			{
				IFormattable formattable17 = inFormat as IFormattable;
				if (formattable17 != null)
				{
					IFormattable formattable18 = formattable17;
					obj25 = formattable18.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj26 = inFormat;
					obj25 = obj26.ToString();
				}
			}
			else
			{
				obj25 = "";
			}
			array[8] = (string)obj25;
			object obj27;
			if ((outFormat == null) ? true : false)
			{
				obj27 = "corner";
			}
			else if (outFormat != null)
			{
				IFormattable formattable19 = outFormat as IFormattable;
				if (formattable19 != null)
				{
					IFormattable formattable20 = formattable19;
					obj27 = formattable20.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj28 = outFormat;
					obj27 = obj28.ToString();
				}
			}
			else
			{
				obj27 = "";
			}
			array[9] = (string)obj27;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void ContribBoxNms(IEnumerable<NDArray> outputArray, NDArray data, double overlapThresh = 0.5, double validThresh = 0.0, int topk = -1, int coordStart = 2, int scoreIndex = 1, int idIndex = -1, int backgroundId = -1, bool forceSuppress = false, [Optional] GeneratedArgumentTypes.Format inFormat, [Optional] GeneratedArgumentTypes.Format outFormat)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_box_nms");
			string[] names2 = new string[10]
			{
				"overlap_thresh",
				"valid_thresh",
				"topk",
				"coord_start",
				"score_index",
				"id_index",
				"background_id",
				"force_suppress",
				"in_format",
				"out_format"
			};
			string[] array = new string[10];
			object obj = overlapThresh;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = validThresh;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = topk;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = coordStart;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = scoreIndex;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = idIndex;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = backgroundId;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			bool flag = forceSuppress;
			object obj22 = flag;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			object obj25;
			if ((inFormat == null) ? true : false)
			{
				obj25 = "corner";
			}
			else if (inFormat != null)
			{
				IFormattable formattable17 = inFormat as IFormattable;
				if (formattable17 != null)
				{
					IFormattable formattable18 = formattable17;
					obj25 = formattable18.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj26 = inFormat;
					obj25 = obj26.ToString();
				}
			}
			else
			{
				obj25 = "";
			}
			array[8] = (string)obj25;
			object obj27;
			if ((outFormat == null) ? true : false)
			{
				obj27 = "corner";
			}
			else if (outFormat != null)
			{
				IFormattable formattable19 = outFormat as IFormattable;
				if (formattable19 != null)
				{
					IFormattable formattable20 = formattable19;
					obj27 = formattable20.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj28 = outFormat;
					obj27 = obj28.ToString();
				}
			}
			else
			{
				obj27 = "";
			}
			array[9] = (string)obj27;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBoxNms_00401842(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401844_002D54(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401845_002D55(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBoxNms ContribBoxNms([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> overlapThresh, [Optional] [OptionalArgument] FSharpOption<double> validThresh, [Optional] [OptionalArgument] FSharpOption<int> topk, [Optional] [OptionalArgument] FSharpOption<int> coordStart, [Optional] [OptionalArgument] FSharpOption<int> scoreIndex, [Optional] [OptionalArgument] FSharpOption<int> idIndex, [Optional] [OptionalArgument] FSharpOption<int> backgroundId, [Optional] [OptionalArgument] FSharpOption<bool> forceSuppress, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.Format> inFormat, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.Format> outFormat)
		{
			return new SymbolOperators.ContribBoxNms(data, overlapThresh, validThresh, topk, coordStart, scoreIndex, idIndex, backgroundId, forceSuppress, inFormat, outFormat);
		}

		public static NDArray ContribBoxIou(NDArray lhs, NDArray rhs, [Optional] GeneratedArgumentTypes.Format format)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_box_iou");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401950_002D56(lhs, rhs, 0, current));
			string[] parameterKeys = new string[1]
			{
				"format"
			};
			string[] array = new string[1];
			object obj;
			if ((format == null) ? true : false)
			{
				obj = "corner";
			}
			else if (format != null)
			{
				IFormattable formattable = format as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = format;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribBoxIou(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs, [Optional] GeneratedArgumentTypes.Format format)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_box_iou");
			string[] names2 = new string[1]
			{
				"format"
			};
			string[] array = new string[1];
			object obj;
			if ((format == null) ? true : false)
			{
				obj = "corner";
			}
			else if (format != null)
			{
				IFormattable formattable = format as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = format;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBoxIou_00401982(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00401984_002D57(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00401985_002D58(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBoxIou ContribBoxIou([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.Format> format)
		{
			return new SymbolOperators.ContribBoxIou(lhs, rhs, format);
		}

		public static Tuple<NDArray, NDArray> ContribBipartiteMatching(NDArray data, double threshold, bool isAscend = false, int topk = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_bipartite_matching");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402047_002D59(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"threshold",
				"is_ascend",
				"topk"
			};
			string[] array = new string[3];
			object obj = threshold;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = isAscend;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = topk;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void ContribBipartiteMatching(IEnumerable<NDArray> outputArray, NDArray data, double threshold, bool isAscend = false, int topk = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_bipartite_matching");
			string[] names2 = new string[3]
			{
				"threshold",
				"is_ascend",
				"topk"
			};
			string[] array = new string[3];
			object obj = threshold;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = isAscend;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = topk;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBipartiteMatching_00402084(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402086_002D60(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00402087_002D61(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBipartiteMatching ContribBipartiteMatching(Symbol data, double threshold, [Optional] [OptionalArgument] FSharpOption<bool> isAscend, [Optional] [OptionalArgument] FSharpOption<int> topk)
		{
			return new SymbolOperators.ContribBipartiteMatching(data, threshold, isAscend, topk);
		}

		public static SymbolOperators.ContribBipartiteMatching ContribBipartiteMatching(double threshold, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<bool> isAscend, [Optional] [OptionalArgument] FSharpOption<int> topk)
		{
			return new SymbolOperators.ContribBipartiteMatching(threshold, data, isAscend, topk);
		}

		public static NDArray[] ContribBoxEncode(NDArray samples, NDArray matches, NDArray anchors, NDArray refs, NDArray means, NDArray stds)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_box_encode");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402172_002D62(samples, matches, anchors, refs, means, stds, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribBoxEncode_00402175();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ContribBoxEncode(IEnumerable<NDArray> outputArray, NDArray samples, NDArray matches, NDArray anchors, NDArray refs, NDArray means, NDArray stds)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_box_encode");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00402196_002D6();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00402197_002D7();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBoxEncode_00402198_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402200_002D63(samples, matches, anchors, refs, means, stds, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00402201_002D64(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBoxEncode ContribBoxEncode([Optional] [OptionalArgument] FSharpOption<Symbol> samples, [Optional] [OptionalArgument] FSharpOption<Symbol> matches, [Optional] [OptionalArgument] FSharpOption<Symbol> anchors, [Optional] [OptionalArgument] FSharpOption<Symbol> refs, [Optional] [OptionalArgument] FSharpOption<Symbol> means, [Optional] [OptionalArgument] FSharpOption<Symbol> stds)
		{
			return new SymbolOperators.ContribBoxEncode(samples, matches, anchors, refs, means, stds);
		}

		public static NDArray[] ContribBoxDecode(NDArray data, NDArray anchors, double std0 = 1.0, double std1 = 1.0, double std2 = 1.0, double std3 = 1.0, double clip = -1.0, [Optional] GeneratedArgumentTypes.Format format)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_box_decode");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402244_002D65(data, anchors, 0, current));
			string[] parameterKeys = new string[6]
			{
				"std0",
				"std1",
				"std2",
				"std3",
				"clip",
				"format"
			};
			string[] array = new string[6];
			object obj = std0;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = std1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = std2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = std3;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clip;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16;
			if ((format == null) ? true : false)
			{
				obj16 = "center";
			}
			else if (format != null)
			{
				IFormattable formattable11 = format as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = format;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribBoxDecode_00402247();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribBoxDecode(IEnumerable<NDArray> outputArray, NDArray data, NDArray anchors, double std0 = 1.0, double std1 = 1.0, double std2 = 1.0, double std3 = 1.0, double clip = -1.0, [Optional] GeneratedArgumentTypes.Format format)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_box_decode");
			string[] names2 = new string[6]
			{
				"std0",
				"std1",
				"std2",
				"std3",
				"clip",
				"format"
			};
			string[] array = new string[6];
			object obj = std0;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = std1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = std2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = std3;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clip;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16;
			if ((format == null) ? true : false)
			{
				obj16 = "center";
			}
			else if (format != null)
			{
				IFormattable formattable11 = format as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = format;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBoxDecode_00402276_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402278_002D66(data, anchors, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00402279_002D67(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBoxDecode ContribBoxDecode([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> anchors, [Optional] [OptionalArgument] FSharpOption<double> std0, [Optional] [OptionalArgument] FSharpOption<double> std1, [Optional] [OptionalArgument] FSharpOption<double> std2, [Optional] [OptionalArgument] FSharpOption<double> std3, [Optional] [OptionalArgument] FSharpOption<double> clip, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.Format> format)
		{
			return new SymbolOperators.ContribBoxDecode(data, anchors, std0, std1, std2, std3, clip, format);
		}

		public static NDArray[] ContribDglCsrNeighborUniformSample(NDArray csrMatrix, params NDArray[] seedArrays, long numHops = 1L, long numNeighbor = 2L, long maxNumVertices = 100L)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_csr_neighbor_uniform_sample");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402356_002D68(csrMatrix, seedArrays, 0, current));
			string[] parameterKeys = new string[4]
			{
				"num_args",
				"num_hops",
				"num_neighbor",
				"max_num_vertices"
			};
			string[] array = new string[4];
			int num = seedArrays.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numHops;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = numNeighbor;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = maxNumVertices;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribDglCsrNeighborUniformSample_00402359();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribDglCsrNeighborUniformSample(IEnumerable<NDArray> outputArray, NDArray csrMatrix, params NDArray[] seedArrays, long numHops = 1L, long numNeighbor = 2L, long maxNumVertices = 100L)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_csr_neighbor_uniform_sample");
			string[] names2 = new string[4]
			{
				"num_args",
				"num_hops",
				"num_neighbor",
				"max_num_vertices"
			};
			string[] array = new string[4];
			int num = seedArrays.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numHops;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = numNeighbor;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = maxNumVertices;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribDglCsrNeighborUniformSample_00402418_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402420_002D70(csrMatrix, seedArrays, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00402421_002D72(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribDglCsrNeighborUniformSample ContribDglCsrNeighborUniformSample([Optional] [OptionalArgument] FSharpOption<Symbol> csrMatrix, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> seedArrays, [Optional] [OptionalArgument] FSharpOption<long> numHops, [Optional] [OptionalArgument] FSharpOption<long> numNeighbor, [Optional] [OptionalArgument] FSharpOption<long> maxNumVertices)
		{
			return new SymbolOperators.ContribDglCsrNeighborUniformSample(csrMatrix, seedArrays, numHops, numNeighbor, maxNumVertices);
		}

		public static NDArray[] ContribDglCsrNeighborNonUniformSample(NDArray csrMatrix, NDArray probability, params NDArray[] seedArrays, long numHops = 1L, long numNeighbor = 2L, long maxNumVertices = 100L)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_csr_neighbor_non_uniform_sample");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402537_002D73(csrMatrix, probability, seedArrays, 0, current));
			string[] parameterKeys = new string[4]
			{
				"num_args",
				"num_hops",
				"num_neighbor",
				"max_num_vertices"
			};
			string[] array = new string[4];
			int num = seedArrays.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numHops;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = numNeighbor;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = maxNumVertices;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribDglCsrNeighborNonUniformSample_00402540();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribDglCsrNeighborNonUniformSample(IEnumerable<NDArray> outputArray, NDArray csrMatrix, NDArray probability, params NDArray[] seedArrays, long numHops = 1L, long numNeighbor = 2L, long maxNumVertices = 100L)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_csr_neighbor_non_uniform_sample");
			string[] names2 = new string[4]
			{
				"num_args",
				"num_hops",
				"num_neighbor",
				"max_num_vertices"
			};
			string[] array = new string[4];
			int num = seedArrays.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numHops;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = numNeighbor;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = maxNumVertices;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribDglCsrNeighborNonUniformSample_00402606_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402608_002D75(csrMatrix, probability, seedArrays, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00402609_002D77(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribDglCsrNeighborNonUniformSample ContribDglCsrNeighborNonUniformSample([Optional] [OptionalArgument] FSharpOption<Symbol> csrMatrix, [Optional] [OptionalArgument] FSharpOption<Symbol> probability, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> seedArrays, [Optional] [OptionalArgument] FSharpOption<long> numHops, [Optional] [OptionalArgument] FSharpOption<long> numNeighbor, [Optional] [OptionalArgument] FSharpOption<long> maxNumVertices)
		{
			return new SymbolOperators.ContribDglCsrNeighborNonUniformSample(csrMatrix, probability, seedArrays, numHops, numNeighbor, maxNumVertices);
		}

		public static NDArray[] ContribDglSubgraph(NDArray graph, params NDArray[] data, bool returnMapping)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_subgraph");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402703_002D78(graph, data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"num_args",
				"return_mapping"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = returnMapping;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribDglSubgraph_00402706();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribDglSubgraph(IEnumerable<NDArray> outputArray, NDArray graph, params NDArray[] data, bool returnMapping)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_subgraph");
			string[] names2 = new string[2]
			{
				"num_args",
				"return_mapping"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = returnMapping;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribDglSubgraph_00402743_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402745_002D80(graph, data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00402746_002D82(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribDglSubgraph ContribDglSubgraph(Symbol graph, IEnumerable<Symbol> data, bool returnMapping)
		{
			return new SymbolOperators.ContribDglSubgraph(graph, data, returnMapping);
		}

		public static SymbolOperators.ContribDglSubgraph ContribDglSubgraph(bool returnMapping, [Optional] [OptionalArgument] FSharpOption<Symbol> graph, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data)
		{
			return new SymbolOperators.ContribDglSubgraph(returnMapping, graph, data);
		}

		public static NDArray ContribEdgeId(NDArray data, NDArray u, NDArray v)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_edge_id");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402844_002D83(data, u, v, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ContribEdgeId(IEnumerable<NDArray> outputArray, NDArray data, NDArray u, NDArray v)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_edge_id");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00402877_002D7();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00402878_002D8();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribEdgeId_00402879(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402881_002D84(data, u, v, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00402882_002D85(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribEdgeId ContribEdgeId([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> u, [Optional] [OptionalArgument] FSharpOption<Symbol> v)
		{
			return new SymbolOperators.ContribEdgeId(data, u, v);
		}

		public static NDArray ContribDglAdjacency(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_adjacency");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402938_002D86(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ContribDglAdjacency(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_adjacency");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00402965_002D8();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00402966_002D9();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribDglAdjacency_00402967(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00402969_002D87(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00402970_002D88(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribDglAdjacency ContribDglAdjacency([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ContribDglAdjacency(data);
		}

		public static NDArray[] ContribDglGraphCompact(params NDArray[] graphData, bool returnMapping, IEnumerable<long> graphSizes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_graph_compact");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00403037_002D89();
			if (graphData == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[graphData.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(graphData[i]);
			}
			string[] parameterKeys = new string[3]
			{
				"num_args",
				"return_mapping",
				"graph_sizes"
			};
			string[] array2 = new string[3];
			int num = graphData.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			bool flag = returnMapping;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			object obj7;
			if (graphSizes != null)
			{
				IFormattable formattable5 = graphSizes as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = graphSizes;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array2[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.ContribDglGraphCompact_00403040();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void ContribDglGraphCompact(IEnumerable<NDArray> outputArray, params NDArray[] graphData, bool returnMapping, IEnumerable<long> graphSizes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dgl_graph_compact");
			string[] names2 = new string[3]
			{
				"num_args",
				"return_mapping",
				"graph_sizes"
			};
			string[] array = new string[3];
			int num = graphData.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = returnMapping;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (graphSizes != null)
			{
				IFormattable formattable5 = graphSizes as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = graphSizes;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribDglGraphCompact_00403083_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00403085_002D90();
			if (graphData == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[graphData.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(graphData[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403086_002D91(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribDglGraphCompact ContribDglGraphCompact(IEnumerable<Symbol> graphData, bool returnMapping, IEnumerable<long> graphSizes)
		{
			return new SymbolOperators.ContribDglGraphCompact(graphData, returnMapping, graphSizes);
		}

		public static SymbolOperators.ContribDglGraphCompact ContribDglGraphCompact(bool returnMapping, IEnumerable<long> graphSizes, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> graphData)
		{
			return new SymbolOperators.ContribDglGraphCompact(returnMapping, graphSizes, graphData);
		}

		public static SymbolOperators.ContribDglGraphCompact ContribDglGraphCompact(bool returnMapping, IEnumerable<long> graphSizes, params Symbol[] graphData)
		{
			return new SymbolOperators.ContribDglGraphCompact(returnMapping, graphSizes, graphData);
		}

		public static NDArray ContribGradientmultiplier(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_gradientmultiplier");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403217_002D92(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribGradientmultiplier(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_gradientmultiplier");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribGradientmultiplier_00403235(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403237_002D93(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403238_002D94(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribGradientmultiplier ContribGradientmultiplier(Symbol data, double scalar)
		{
			return new SymbolOperators.ContribGradientmultiplier(data, scalar);
		}

		public static SymbolOperators.ContribGradientmultiplier ContribGradientmultiplier(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ContribGradientmultiplier(scalar, data);
		}

		public static NDArray ContribBackwardGradientmultiplier(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_backward_gradientmultiplier");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403270_002D95(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribBackwardGradientmultiplier(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_backward_gradientmultiplier");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBackwardGradientmultiplier_00403281(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403283_002D96(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403284_002D97(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBackwardGradientmultiplier ContribBackwardGradientmultiplier(Symbol data, double scalar)
		{
			return new SymbolOperators.ContribBackwardGradientmultiplier(data, scalar);
		}

		public static SymbolOperators.ContribBackwardGradientmultiplier ContribBackwardGradientmultiplier(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ContribBackwardGradientmultiplier(scalar, data);
		}

		public static NDArray[] ContribHawkesll(NDArray lda, NDArray alpha, NDArray beta, NDArray state, NDArray lags, NDArray marks, NDArray validLength, NDArray maxTime)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_hawkesll");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403369_002D98(lda, alpha, beta, state, lags, marks, validLength, maxTime, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribHawkesll_00403372();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ContribHawkesll(IEnumerable<NDArray> outputArray, NDArray lda, NDArray alpha, NDArray beta, NDArray state, NDArray lags, NDArray marks, NDArray validLength, NDArray maxTime)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_hawkesll");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00403446_002D9();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00403447_002D10();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribHawkesll_00403448_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403450_002D99(lda, alpha, beta, state, lags, marks, validLength, maxTime, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403451_002D100(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribHawkesll ContribHawkesll([Optional] [OptionalArgument] FSharpOption<Symbol> lda, [Optional] [OptionalArgument] FSharpOption<Symbol> alpha, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<Symbol> state, [Optional] [OptionalArgument] FSharpOption<Symbol> lags, [Optional] [OptionalArgument] FSharpOption<Symbol> marks, [Optional] [OptionalArgument] FSharpOption<Symbol> validLength, [Optional] [OptionalArgument] FSharpOption<Symbol> maxTime)
		{
			return new SymbolOperators.ContribHawkesll(lda, alpha, beta, state, lags, marks, validLength, maxTime);
		}

		public static NDArray[] ContribBackwardHawkesllNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_backward_hawkesll");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribBackwardHawkesllNDArray_00403526();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ContribBackwardHawkesll(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_backward_hawkesll");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00403530_002D10();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00403531_002D11();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBackwardHawkesll_00403532(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403535_002D101(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBackwardHawkesll ContribBackwardHawkesll()
		{
			return new SymbolOperators.ContribBackwardHawkesll();
		}

		public static NDArray ContribIndexArray(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_index_array");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403595_002D102(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj;
			if (axes == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axes;
				IEnumerable<int> axes2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00403597_002D103(), axes2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribIndexArray(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_index_array");
			string[] names2 = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj;
			if (axes == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axes;
				IEnumerable<int> axes2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00403653_002D12(), axes2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribIndexArray_00403654(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403656_002D104(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403657_002D105(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribIndexArray ContribIndexArray([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			return new SymbolOperators.ContribIndexArray(data, axes);
		}

		public static NDArray ContribIndexCopy(NDArray oldTensor, NDArray indexVector, NDArray newTensor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_index_copy");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403750_002D106(oldTensor, indexVector, newTensor, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ContribIndexCopy(IEnumerable<NDArray> outputArray, NDArray oldTensor, NDArray indexVector, NDArray newTensor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_index_copy");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00403790_002D11();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00403791_002D13();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribIndexCopy_00403792(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00403794_002D107(oldTensor, indexVector, newTensor, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403795_002D108(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribIndexCopy ContribIndexCopy([Optional] [OptionalArgument] FSharpOption<Symbol> oldTensor, [Optional] [OptionalArgument] FSharpOption<Symbol> indexVector, [Optional] [OptionalArgument] FSharpOption<Symbol> newTensor)
		{
			return new SymbolOperators.ContribIndexCopy(oldTensor, indexVector, newTensor);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribBackwardIndexCopyNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_backward_index_copy");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribBackwardIndexCopy(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_backward_index_copy");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00403845_002D12();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00403846_002D14();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBackwardIndexCopy_00403847(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403850_002D109(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBackwardIndexCopy ContribBackwardIndexCopy()
		{
			return new SymbolOperators.ContribBackwardIndexCopy();
		}

		public static NDArray KhatriRao(params NDArray[] args)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("khatri_rao");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00403896_002D110();
			if (args == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[args.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(args[i]);
			}
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void KhatriRao(IEnumerable<NDArray> outputArray, params NDArray[] args)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("khatri_rao");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00403939_002D13();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00403940_002D15();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.KhatriRao_00403941(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00403943_002D111();
			if (args == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[args.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(args[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00403944_002D112(), outputArray)), names, vals);
		}

		public static SymbolOperators.KhatriRao KhatriRao(params Symbol[] args)
		{
			return new SymbolOperators.KhatriRao(args);
		}

		public static NDArray[] MultiLars(NDArray lrs, NDArray weightsSumSq, NDArray gradsSumSq, NDArray wds, double eta, double eps, double rescaleGrad = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_lars");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404007_002D113(lrs, weightsSumSq, gradsSumSq, wds, 0, current));
			string[] parameterKeys = new string[3]
			{
				"eta",
				"eps",
				"rescale_grad"
			};
			string[] array = new string[3];
			object obj = eta;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eps;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = rescaleGrad;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.MultiLars_00404010();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void MultiLars(IEnumerable<NDArray> outputArray, NDArray lrs, NDArray weightsSumSq, NDArray gradsSumSq, NDArray wds, double eta, double eps, double rescaleGrad = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_lars");
			string[] names2 = new string[3]
			{
				"eta",
				"eps",
				"rescale_grad"
			};
			string[] array = new string[3];
			object obj = eta;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eps;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = rescaleGrad;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiLars_00404034_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404036_002D114(lrs, weightsSumSq, gradsSumSq, wds, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404037_002D115(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiLars MultiLars(Symbol lrs, Symbol weightsSumSq, Symbol gradsSumSq, Symbol wds, double eta, double eps, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad)
		{
			return new SymbolOperators.MultiLars(lrs, weightsSumSq, gradsSumSq, wds, eta, eps, rescaleGrad);
		}

		public static SymbolOperators.MultiLars MultiLars(double eta, double eps, [Optional] [OptionalArgument] FSharpOption<Symbol> lrs, [Optional] [OptionalArgument] FSharpOption<Symbol> weightsSumSq, [Optional] [OptionalArgument] FSharpOption<Symbol> gradsSumSq, [Optional] [OptionalArgument] FSharpOption<Symbol> wds, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad)
		{
			return new SymbolOperators.MultiLars(eta, eps, lrs, weightsSumSq, gradsSumSq, wds, rescaleGrad);
		}

		public static NDArray[] MultiSumSq(params NDArray[] data, int numArrays)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_sum_sq");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404077_002D116();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[1]
			{
				"num_arrays"
			};
			string[] array2 = new string[1];
			object obj = numArrays;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.MultiSumSq_00404080();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void MultiSumSq(IEnumerable<NDArray> outputArray, params NDArray[] data, int numArrays)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_sum_sq");
			string[] names2 = new string[1]
			{
				"num_arrays"
			};
			string[] array = new string[1];
			object obj = numArrays;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiSumSq_00404092_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404094_002D117();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404095_002D118(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiSumSq MultiSumSq(IEnumerable<Symbol> data, int numArrays)
		{
			return new SymbolOperators.MultiSumSq(data, numArrays);
		}

		public static SymbolOperators.MultiSumSq MultiSumSq(int numArrays, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data)
		{
			return new SymbolOperators.MultiSumSq(numArrays, data);
		}

		public static SymbolOperators.MultiSumSq MultiSumSq(int numArrays, params Symbol[] data)
		{
			return new SymbolOperators.MultiSumSq(numArrays, data);
		}

		public static NDArray[] ContribMultiBoxDetection(NDArray clsProb, NDArray locPred, NDArray anchor, bool clip = true, double threshold = 0.01, int backgroundId = 0, double nmsThreshold = 0.5, bool forceSuppress = false, [Optional] IEnumerable<double> variances, int nmsTopk = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_MultiBoxDetection");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404147_002D119(clsProb, locPred, anchor, 0, current));
			string[] parameterKeys = new string[7]
			{
				"clip",
				"threshold",
				"background_id",
				"nms_threshold",
				"force_suppress",
				"variances",
				"nms_topk"
			};
			string[] array = new string[7];
			bool flag = clip;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = threshold;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = backgroundId;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = nmsThreshold;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag2 = forceSuppress;
			object obj13 = flag2;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16;
			if ((variances == null) ? true : false)
			{
				obj16 = "[0.1,0.1,0.2,0.2]";
			}
			else if (variances != null)
			{
				IFormattable formattable11 = variances as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = variances;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			object obj18 = nmsTopk;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable13 = obj18 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[6] = (string)obj19;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribMultiBoxDetection_00404150();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribMultiBoxDetection(IEnumerable<NDArray> outputArray, NDArray clsProb, NDArray locPred, NDArray anchor, bool clip = true, double threshold = 0.01, int backgroundId = 0, double nmsThreshold = 0.5, bool forceSuppress = false, [Optional] IEnumerable<double> variances, int nmsTopk = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_MultiBoxDetection");
			string[] names2 = new string[7]
			{
				"clip",
				"threshold",
				"background_id",
				"nms_threshold",
				"force_suppress",
				"variances",
				"nms_topk"
			};
			string[] array = new string[7];
			bool flag = clip;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = threshold;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = backgroundId;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = nmsThreshold;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag2 = forceSuppress;
			object obj13 = flag2;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16;
			if ((variances == null) ? true : false)
			{
				obj16 = "[0.1,0.1,0.2,0.2]";
			}
			else if (variances != null)
			{
				IFormattable formattable11 = variances as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = variances;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			object obj18 = nmsTopk;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable13 = obj18 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[6] = (string)obj19;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribMultiBoxDetection_00404177_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404179_002D120(clsProb, locPred, anchor, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404180_002D121(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribMultiBoxDetection ContribMultiBoxDetection([Optional] [OptionalArgument] FSharpOption<Symbol> clsProb, [Optional] [OptionalArgument] FSharpOption<Symbol> locPred, [Optional] [OptionalArgument] FSharpOption<Symbol> anchor, [Optional] [OptionalArgument] FSharpOption<bool> clip, [Optional] [OptionalArgument] FSharpOption<double> threshold, [Optional] [OptionalArgument] FSharpOption<int> backgroundId, [Optional] [OptionalArgument] FSharpOption<double> nmsThreshold, [Optional] [OptionalArgument] FSharpOption<bool> forceSuppress, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> variances, [Optional] [OptionalArgument] FSharpOption<int> nmsTopk)
		{
			return new SymbolOperators.ContribMultiBoxDetection(clsProb, locPred, anchor, clip, threshold, backgroundId, nmsThreshold, forceSuppress, variances, nmsTopk);
		}

		public static NDArray[] ContribMultiBoxPrior(NDArray data, [Optional] IEnumerable<double> sizes, [Optional] IEnumerable<double> ratios, bool clip = false, [Optional] IEnumerable<double> steps, [Optional] IEnumerable<double> offsets)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_MultiBoxPrior");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404213_002D122(data, 0, current));
			string[] parameterKeys = new string[5]
			{
				"sizes",
				"ratios",
				"clip",
				"steps",
				"offsets"
			};
			string[] array = new string[5];
			object obj;
			if ((sizes == null) ? true : false)
			{
				obj = "[1]";
			}
			else if (sizes != null)
			{
				IFormattable formattable = sizes as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = sizes;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((ratios == null) ? true : false)
			{
				obj3 = "[1]";
			}
			else if (ratios != null)
			{
				IFormattable formattable3 = ratios as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = ratios;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			bool flag = clip;
			object obj5 = flag;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			object obj8;
			if ((steps == null) ? true : false)
			{
				obj8 = "[-1,-1]";
			}
			else if (steps != null)
			{
				IFormattable formattable7 = steps as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj8 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = steps;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			object obj10;
			if ((offsets == null) ? true : false)
			{
				obj10 = "[0.5,0.5]";
			}
			else if (offsets != null)
			{
				IFormattable formattable9 = offsets as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj10 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = offsets;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribMultiBoxPrior_00404216();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribMultiBoxPrior(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<double> sizes, [Optional] IEnumerable<double> ratios, bool clip = false, [Optional] IEnumerable<double> steps, [Optional] IEnumerable<double> offsets)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_MultiBoxPrior");
			string[] names2 = new string[5]
			{
				"sizes",
				"ratios",
				"clip",
				"steps",
				"offsets"
			};
			string[] array = new string[5];
			object obj;
			if ((sizes == null) ? true : false)
			{
				obj = "[1]";
			}
			else if (sizes != null)
			{
				IFormattable formattable = sizes as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = sizes;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((ratios == null) ? true : false)
			{
				obj3 = "[1]";
			}
			else if (ratios != null)
			{
				IFormattable formattable3 = ratios as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = ratios;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			bool flag = clip;
			object obj5 = flag;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			object obj8;
			if ((steps == null) ? true : false)
			{
				obj8 = "[-1,-1]";
			}
			else if (steps != null)
			{
				IFormattable formattable7 = steps as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj8 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = steps;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			object obj10;
			if ((offsets == null) ? true : false)
			{
				obj10 = "[0.5,0.5]";
			}
			else if (offsets != null)
			{
				IFormattable formattable9 = offsets as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj10 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = offsets;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribMultiBoxPrior_00404235_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404237_002D123(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404238_002D124(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribMultiBoxPrior ContribMultiBoxPrior([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> sizes, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> ratios, [Optional] [OptionalArgument] FSharpOption<bool> clip, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> steps, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> offsets)
		{
			return new SymbolOperators.ContribMultiBoxPrior(data, sizes, ratios, clip, steps, offsets);
		}

		public static NDArray[] ContribMultiBoxTarget(NDArray anchor, NDArray label, NDArray clsPred, double overlapThreshold = 0.5, double ignoreLabel = -1.0, double negativeMiningRatio = -1.0, double negativeMiningThresh = 0.5, int minimumNegativeSamples = 0, [Optional] IEnumerable<double> variances)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_MultiBoxTarget");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404273_002D125(anchor, label, clsPred, 0, current));
			string[] parameterKeys = new string[6]
			{
				"overlap_threshold",
				"ignore_label",
				"negative_mining_ratio",
				"negative_mining_thresh",
				"minimum_negative_samples",
				"variances"
			};
			string[] array = new string[6];
			object obj = overlapThreshold;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = ignoreLabel;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = negativeMiningRatio;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = negativeMiningThresh;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = minimumNegativeSamples;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16;
			if ((variances == null) ? true : false)
			{
				obj16 = "[0.1,0.1,0.2,0.2]";
			}
			else if (variances != null)
			{
				IFormattable formattable11 = variances as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = variances;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribMultiBoxTarget_00404276();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribMultiBoxTarget(IEnumerable<NDArray> outputArray, NDArray anchor, NDArray label, NDArray clsPred, double overlapThreshold = 0.5, double ignoreLabel = -1.0, double negativeMiningRatio = -1.0, double negativeMiningThresh = 0.5, int minimumNegativeSamples = 0, [Optional] IEnumerable<double> variances)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_MultiBoxTarget");
			string[] names2 = new string[6]
			{
				"overlap_threshold",
				"ignore_label",
				"negative_mining_ratio",
				"negative_mining_thresh",
				"minimum_negative_samples",
				"variances"
			};
			string[] array = new string[6];
			object obj = overlapThreshold;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = ignoreLabel;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = negativeMiningRatio;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = negativeMiningThresh;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = minimumNegativeSamples;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16;
			if ((variances == null) ? true : false)
			{
				obj16 = "[0.1,0.1,0.2,0.2]";
			}
			else if (variances != null)
			{
				IFormattable formattable11 = variances as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = variances;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribMultiBoxTarget_00404301_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404303_002D126(anchor, label, clsPred, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404304_002D127(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribMultiBoxTarget ContribMultiBoxTarget([Optional] [OptionalArgument] FSharpOption<Symbol> anchor, [Optional] [OptionalArgument] FSharpOption<Symbol> label, [Optional] [OptionalArgument] FSharpOption<Symbol> clsPred, [Optional] [OptionalArgument] FSharpOption<double> overlapThreshold, [Optional] [OptionalArgument] FSharpOption<double> ignoreLabel, [Optional] [OptionalArgument] FSharpOption<double> negativeMiningRatio, [Optional] [OptionalArgument] FSharpOption<double> negativeMiningThresh, [Optional] [OptionalArgument] FSharpOption<int> minimumNegativeSamples, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> variances)
		{
			return new SymbolOperators.ContribMultiBoxTarget(anchor, label, clsPred, overlapThreshold, ignoreLabel, negativeMiningRatio, negativeMiningThresh, minimumNegativeSamples, variances);
		}

		public static NDArray ContribGetnnz(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_getnnz");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404333_002D128(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribGetnnz(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_getnnz");
			string[] names2 = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribGetnnz_00404351(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404353_002D129(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404354_002D130(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribGetnnz ContribGetnnz([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.ContribGetnnz(data, axis);
		}

		public static NDArray ContribGroupAdagradUpdate(NDArray weight, NDArray grad, NDArray history, double lr, double rescaleGrad = 1.0, double clipGradient = -1.0, double epsilon = 1E-05)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_group_adagrad_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404406_002D131(weight, grad, history, 0, current));
			string[] parameterKeys = new string[4]
			{
				"lr",
				"rescale_grad",
				"clip_gradient",
				"epsilon"
			};
			string[] array = new string[4];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = rescaleGrad;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = clipGradient;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = epsilon;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribGroupAdagradUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray history, double lr, double rescaleGrad = 1.0, double clipGradient = -1.0, double epsilon = 1E-05)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_group_adagrad_update");
			string[] names2 = new string[4]
			{
				"lr",
				"rescale_grad",
				"clip_gradient",
				"epsilon"
			};
			string[] array = new string[4];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = rescaleGrad;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = clipGradient;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = epsilon;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribGroupAdagradUpdate_00404449(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404451_002D132(weight, grad, history, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404452_002D133(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribGroupAdagradUpdate ContribGroupAdagradUpdate(Symbol weight, Symbol grad, Symbol history, double lr, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<double> epsilon)
		{
			return new SymbolOperators.ContribGroupAdagradUpdate(weight, grad, history, lr, rescaleGrad, clipGradient, epsilon);
		}

		public static SymbolOperators.ContribGroupAdagradUpdate ContribGroupAdagradUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> history, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<double> epsilon)
		{
			return new SymbolOperators.ContribGroupAdagradUpdate(lr, weight, grad, history, rescaleGrad, clipGradient, epsilon);
		}

		public static NDArray[] PreloadedMultiSgdUpdate(params NDArray[] data, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("preloaded_multi_sgd_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404531_002D134();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[3]
			{
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[3];
			object obj = rescaleGrad;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = clipGradient;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			object obj7 = numWeights;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array2[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.PreloadedMultiSgdUpdate_00404534();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void PreloadedMultiSgdUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("preloaded_multi_sgd_update");
			string[] names2 = new string[3]
			{
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[3];
			object obj = rescaleGrad;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = clipGradient;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = numWeights;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.PreloadedMultiSgdUpdate_00404553_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404555_002D135();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404556_002D136(), outputArray)), names, vals);
		}

		public static SymbolOperators.PreloadedMultiSgdUpdate PreloadedMultiSgdUpdate([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.PreloadedMultiSgdUpdate(data, rescaleGrad, clipGradient, numWeights);
		}

		public static NDArray[] PreloadedMultiSgdMomUpdate(params NDArray[] data, double momentum = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("preloaded_multi_sgd_mom_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404609_002D137();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[4]
			{
				"momentum",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[4];
			object obj = momentum;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = rescaleGrad;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			object obj7 = clipGradient;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array2[2] = (string)obj8;
			object obj10 = numWeights;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array2[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.PreloadedMultiSgdMomUpdate_00404612();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void PreloadedMultiSgdMomUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, double momentum = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("preloaded_multi_sgd_mom_update");
			string[] names2 = new string[4]
			{
				"momentum",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[4];
			object obj = momentum;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = rescaleGrad;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = clipGradient;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = numWeights;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.PreloadedMultiSgdMomUpdate_00404649_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404651_002D138();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404652_002D139(), outputArray)), names, vals);
		}

		public static SymbolOperators.PreloadedMultiSgdMomUpdate PreloadedMultiSgdMomUpdate([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.PreloadedMultiSgdMomUpdate(data, momentum, rescaleGrad, clipGradient, numWeights);
		}

		public static NDArray[] PreloadedMultiMpSgdUpdate(params NDArray[] data, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("preloaded_multi_mp_sgd_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404701_002D140();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[3]
			{
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[3];
			object obj = rescaleGrad;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = clipGradient;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			object obj7 = numWeights;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array2[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.PreloadedMultiMpSgdUpdate_00404704();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void PreloadedMultiMpSgdUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("preloaded_multi_mp_sgd_update");
			string[] names2 = new string[3]
			{
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[3];
			object obj = rescaleGrad;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = clipGradient;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = numWeights;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.PreloadedMultiMpSgdUpdate_00404723_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404725_002D141();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404726_002D142(), outputArray)), names, vals);
		}

		public static SymbolOperators.PreloadedMultiMpSgdUpdate PreloadedMultiMpSgdUpdate([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.PreloadedMultiMpSgdUpdate(data, rescaleGrad, clipGradient, numWeights);
		}

		public static NDArray[] PreloadedMultiMpSgdMomUpdate(params NDArray[] data, double momentum = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("preloaded_multi_mp_sgd_mom_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404779_002D143();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[4]
			{
				"momentum",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[4];
			object obj = momentum;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = rescaleGrad;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			object obj7 = clipGradient;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array2[2] = (string)obj8;
			object obj10 = numWeights;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array2[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.PreloadedMultiMpSgdMomUpdate_00404782();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void PreloadedMultiMpSgdMomUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, double momentum = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("preloaded_multi_mp_sgd_mom_update");
			string[] names2 = new string[4]
			{
				"momentum",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[4];
			object obj = momentum;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = rescaleGrad;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = clipGradient;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = numWeights;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.PreloadedMultiMpSgdMomUpdate_00404819_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404821_002D144();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404822_002D145(), outputArray)), names, vals);
		}

		public static SymbolOperators.PreloadedMultiMpSgdMomUpdate PreloadedMultiMpSgdMomUpdate([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.PreloadedMultiMpSgdMomUpdate(data, momentum, rescaleGrad, clipGradient, numWeights);
		}

		public static NDArray ContribQuadratic(NDArray data, double a = 0.0, double b = 0.0, double c = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quadratic");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404883_002D146(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"a",
				"b",
				"c"
			};
			string[] array = new string[3];
			object obj = a;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = b;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = c;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribQuadratic(IEnumerable<NDArray> outputArray, NDArray data, double a = 0.0, double b = 0.0, double c = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quadratic");
			string[] names2 = new string[3]
			{
				"a",
				"b",
				"c"
			};
			string[] array = new string[3];
			object obj = a;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = b;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = c;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuadratic_00404917(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00404919_002D147(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404920_002D148(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuadratic ContribQuadratic([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> a, [Optional] [OptionalArgument] FSharpOption<double> b, [Optional] [OptionalArgument] FSharpOption<double> c)
		{
			return new SymbolOperators.ContribQuadratic(data, a, b, c);
		}

		public static NDArray ContribBackwardQuadraticNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_backward_quadratic");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ContribBackwardQuadratic(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_backward_quadratic");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00404962_002D14();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00404963_002D16();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribBackwardQuadratic_00404964(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00404967_002D149(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribBackwardQuadratic ContribBackwardQuadratic()
		{
			return new SymbolOperators.ContribBackwardQuadratic();
		}

		public static NDArray[] ResetArrays(params NDArray[] data, int numArrays)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("reset_arrays");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00404983_002D150();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[1]
			{
				"num_arrays"
			};
			string[] array2 = new string[1];
			object obj = numArrays;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.ResetArrays_00404986();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void ResetArrays(IEnumerable<NDArray> outputArray, params NDArray[] data, int numArrays)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("reset_arrays");
			string[] names2 = new string[1]
			{
				"num_arrays"
			};
			string[] array = new string[1];
			object obj = numArrays;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ResetArrays_00404998_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00405000_002D151();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00405001_002D152(), outputArray)), names, vals);
		}

		public static SymbolOperators.ResetArrays ResetArrays(IEnumerable<Symbol> data, int numArrays)
		{
			return new SymbolOperators.ResetArrays(data, numArrays);
		}

		public static SymbolOperators.ResetArrays ResetArrays(int numArrays, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data)
		{
			return new SymbolOperators.ResetArrays(numArrays, data);
		}

		public static SymbolOperators.ResetArrays ResetArrays(int numArrays, params Symbol[] data)
		{
			return new SymbolOperators.ResetArrays(numArrays, data);
		}

		public static NDArray ContribROIAlign(NDArray data, NDArray rois, IEnumerable<int> pooledSize, double spatialScale, int sampleRatio = -1, bool positionSensitive = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_ROIAlign");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405066_002D153(data, rois, 0, current));
			string[] parameterKeys = new string[4]
			{
				"pooled_size",
				"spatial_scale",
				"sample_ratio",
				"position_sensitive"
			};
			string[] array = new string[4];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00405068_002D154(), pooledSize));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = spatialScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4 = sampleRatio;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			bool flag = positionSensitive;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribROIAlign(IEnumerable<NDArray> outputArray, NDArray data, NDArray rois, IEnumerable<int> pooledSize, double spatialScale, int sampleRatio = -1, bool positionSensitive = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_ROIAlign");
			string[] names2 = new string[4]
			{
				"pooled_size",
				"spatial_scale",
				"sample_ratio",
				"position_sensitive"
			};
			string[] array = new string[4];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00405108_002D17(), pooledSize));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = spatialScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4 = sampleRatio;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			bool flag = positionSensitive;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribROIAlign_00405109(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405111_002D155(data, rois, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00405112_002D156(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribROIAlign ContribROIAlign(Symbol data, Symbol rois, IEnumerable<int> pooledSize, double spatialScale, [Optional] [OptionalArgument] FSharpOption<int> sampleRatio, [Optional] [OptionalArgument] FSharpOption<bool> positionSensitive)
		{
			return new SymbolOperators.ContribROIAlign(data, rois, pooledSize, spatialScale, sampleRatio, positionSensitive);
		}

		public static SymbolOperators.ContribROIAlign ContribROIAlign(IEnumerable<int> pooledSize, double spatialScale, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> rois, [Optional] [OptionalArgument] FSharpOption<int> sampleRatio, [Optional] [OptionalArgument] FSharpOption<bool> positionSensitive)
		{
			return new SymbolOperators.ContribROIAlign(pooledSize, spatialScale, data, rois, sampleRatio, positionSensitive);
		}

		public static NDArray ContribRROIAlign(NDArray data, NDArray rois, IEnumerable<int> pooledSize, double spatialScale, int samplingRatio = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_RROIAlign");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405211_002D157(data, rois, 0, current));
			string[] parameterKeys = new string[3]
			{
				"pooled_size",
				"spatial_scale",
				"sampling_ratio"
			};
			string[] array = new string[3];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00405213_002D158(), pooledSize));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = spatialScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4 = samplingRatio;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribRROIAlign(IEnumerable<NDArray> outputArray, NDArray data, NDArray rois, IEnumerable<int> pooledSize, double spatialScale, int samplingRatio = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_RROIAlign");
			string[] names2 = new string[3]
			{
				"pooled_size",
				"spatial_scale",
				"sampling_ratio"
			};
			string[] array = new string[3];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00405250_002D18(), pooledSize));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = spatialScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4 = samplingRatio;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribRROIAlign_00405251(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405253_002D159(data, rois, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00405254_002D160(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribRROIAlign ContribRROIAlign(Symbol data, Symbol rois, IEnumerable<int> pooledSize, double spatialScale, [Optional] [OptionalArgument] FSharpOption<int> samplingRatio)
		{
			return new SymbolOperators.ContribRROIAlign(data, rois, pooledSize, spatialScale, samplingRatio);
		}

		public static SymbolOperators.ContribRROIAlign ContribRROIAlign(IEnumerable<int> pooledSize, double spatialScale, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> rois, [Optional] [OptionalArgument] FSharpOption<int> samplingRatio)
		{
			return new SymbolOperators.ContribRROIAlign(pooledSize, spatialScale, data, rois, samplingRatio);
		}

		public static NDArray[] ContribRoundSte(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_round_ste");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405343_002D161(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribRoundSte_00405346();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ContribRoundSte(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_round_ste");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00405374_002D15();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00405375_002D19();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribRoundSte_00405376_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405378_002D162(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00405379_002D163(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribRoundSte ContribRoundSte([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ContribRoundSte(data);
		}

		public static NDArray[] ContribSignSte(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_sign_ste");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405437_002D164(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribSignSte_00405440();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ContribSignSte(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_sign_ste");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00405468_002D16();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00405469_002D20();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribSignSte_00405470_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405472_002D165(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00405473_002D166(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribSignSte ContribSignSte([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ContribSignSte(data);
		}

		public static NDArray[] ContribSyncBatchNorm(NDArray data, NDArray gamma, NDArray beta, NDArray movingMean, NDArray movingVar, string key, double eps = 0.001, double momentum = 0.9, bool fixGamma = true, bool useGlobalStats = false, bool outputMeanVar = false, int ndev = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_SyncBatchNorm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405581_002D167(data, gamma, beta, movingMean, movingVar, 0, current));
			string[] parameterKeys = new string[7]
			{
				"key",
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var",
				"ndev"
			};
			string[] obj = new string[7]
			{
				key,
				null,
				null,
				null,
				null,
				null,
				null
			};
			object obj2 = eps;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			obj[1] = (string)obj3;
			object obj5 = momentum;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable3 = obj5 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj6 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			obj[2] = (string)obj6;
			bool flag = fixGamma;
			object obj8 = flag;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable5 = obj8 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj9 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			obj[3] = (string)obj9;
			bool flag2 = useGlobalStats;
			object obj11 = flag2;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable7 = obj11 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj12 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			obj[4] = (string)obj12;
			bool flag3 = outputMeanVar;
			object obj14 = flag3;
			object obj15;
			if (obj14 != null)
			{
				IFormattable formattable9 = obj14 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj15 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = obj14;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			obj[5] = (string)obj15;
			object obj17 = ndev;
			object obj18;
			if (obj17 != null)
			{
				IFormattable formattable11 = obj17 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj18 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = obj17;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			obj[6] = (string)obj18;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, obj);
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribSyncBatchNorm_00405584();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ContribSyncBatchNorm(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, NDArray beta, NDArray movingMean, NDArray movingVar, string key, double eps = 0.001, double momentum = 0.9, bool fixGamma = true, bool useGlobalStats = false, bool outputMeanVar = false, int ndev = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_SyncBatchNorm");
			string[] names2 = new string[7]
			{
				"key",
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var",
				"ndev"
			};
			string[] obj = new string[7]
			{
				key,
				null,
				null,
				null,
				null,
				null,
				null
			};
			object obj2 = eps;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			obj[1] = (string)obj3;
			object obj5 = momentum;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable3 = obj5 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj6 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			obj[2] = (string)obj6;
			bool flag = fixGamma;
			object obj8 = flag;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable5 = obj8 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj9 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			obj[3] = (string)obj9;
			bool flag2 = useGlobalStats;
			object obj11 = flag2;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable7 = obj11 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj12 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			obj[4] = (string)obj12;
			bool flag3 = outputMeanVar;
			object obj14 = flag3;
			object obj15;
			if (obj14 != null)
			{
				IFormattable formattable9 = obj14 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj15 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = obj14;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			obj[5] = (string)obj15;
			object obj17 = ndev;
			object obj18;
			if (obj17 != null)
			{
				IFormattable formattable11 = obj17 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj18 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = obj17;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			obj[6] = (string)obj18;
			string[] vals2 = obj;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribSyncBatchNorm_00405665_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405667_002D168(data, gamma, beta, movingMean, movingVar, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00405668_002D169(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribSyncBatchNorm ContribSyncBatchNorm(Symbol data, Symbol gamma, Symbol beta, Symbol movingMean, Symbol movingVar, string key, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> ndev)
		{
			return new SymbolOperators.ContribSyncBatchNorm(data, gamma, beta, movingMean, movingVar, key, eps, momentum, fixGamma, useGlobalStats, outputMeanVar, ndev);
		}

		public static SymbolOperators.ContribSyncBatchNorm ContribSyncBatchNorm(string key, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<Symbol> movingMean, [Optional] [OptionalArgument] FSharpOption<Symbol> movingVar, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> ndev)
		{
			return new SymbolOperators.ContribSyncBatchNorm(key, data, gamma, beta, movingMean, movingVar, eps, momentum, fixGamma, useGlobalStats, outputMeanVar, ndev);
		}

		public static NDArray[] ContribInterleavedMatmulSelfattQk(NDArray queriesKeysValues, int heads)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_interleaved_matmul_selfatt_qk");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405828_002D170(queriesKeysValues, 0, current));
			string[] parameterKeys = new string[1]
			{
				"heads"
			};
			string[] array = new string[1];
			object obj = heads;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribInterleavedMatmulSelfattQk_00405831();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribInterleavedMatmulSelfattQk(IEnumerable<NDArray> outputArray, NDArray queriesKeysValues, int heads)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_interleaved_matmul_selfatt_qk");
			string[] names2 = new string[1]
			{
				"heads"
			};
			string[] array = new string[1];
			object obj = heads;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribInterleavedMatmulSelfattQk_00405859_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405861_002D171(queriesKeysValues, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00405862_002D172(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribInterleavedMatmulSelfattQk ContribInterleavedMatmulSelfattQk(Symbol queriesKeysValues, int heads)
		{
			return new SymbolOperators.ContribInterleavedMatmulSelfattQk(queriesKeysValues, heads);
		}

		public static SymbolOperators.ContribInterleavedMatmulSelfattQk ContribInterleavedMatmulSelfattQk(int heads, [Optional] [OptionalArgument] FSharpOption<Symbol> queriesKeysValues)
		{
			return new SymbolOperators.ContribInterleavedMatmulSelfattQk(heads, queriesKeysValues);
		}

		public static NDArray[] ContribInterleavedMatmulSelfattValatt(NDArray queriesKeysValues, NDArray attention, int heads)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_interleaved_matmul_selfatt_valatt");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405945_002D173(queriesKeysValues, attention, 0, current));
			string[] parameterKeys = new string[1]
			{
				"heads"
			};
			string[] array = new string[1];
			object obj = heads;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribInterleavedMatmulSelfattValatt_00405948();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribInterleavedMatmulSelfattValatt(IEnumerable<NDArray> outputArray, NDArray queriesKeysValues, NDArray attention, int heads)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_interleaved_matmul_selfatt_valatt");
			string[] names2 = new string[1]
			{
				"heads"
			};
			string[] array = new string[1];
			object obj = heads;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribInterleavedMatmulSelfattValatt_00405980_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00405982_002D174(queriesKeysValues, attention, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00405983_002D175(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribInterleavedMatmulSelfattValatt ContribInterleavedMatmulSelfattValatt(Symbol queriesKeysValues, Symbol attention, int heads)
		{
			return new SymbolOperators.ContribInterleavedMatmulSelfattValatt(queriesKeysValues, attention, heads);
		}

		public static SymbolOperators.ContribInterleavedMatmulSelfattValatt ContribInterleavedMatmulSelfattValatt(int heads, [Optional] [OptionalArgument] FSharpOption<Symbol> queriesKeysValues, [Optional] [OptionalArgument] FSharpOption<Symbol> attention)
		{
			return new SymbolOperators.ContribInterleavedMatmulSelfattValatt(heads, queriesKeysValues, attention);
		}

		public static NDArray[] ContribInterleavedMatmulEncdecQk(NDArray queries, NDArray keysValues, int heads)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_interleaved_matmul_encdec_qk");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406073_002D176(queries, keysValues, 0, current));
			string[] parameterKeys = new string[1]
			{
				"heads"
			};
			string[] array = new string[1];
			object obj = heads;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribInterleavedMatmulEncdecQk_00406076();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribInterleavedMatmulEncdecQk(IEnumerable<NDArray> outputArray, NDArray queries, NDArray keysValues, int heads)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_interleaved_matmul_encdec_qk");
			string[] names2 = new string[1]
			{
				"heads"
			};
			string[] array = new string[1];
			object obj = heads;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribInterleavedMatmulEncdecQk_00406107_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406109_002D177(queries, keysValues, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406110_002D178(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribInterleavedMatmulEncdecQk ContribInterleavedMatmulEncdecQk(Symbol queries, Symbol keysValues, int heads)
		{
			return new SymbolOperators.ContribInterleavedMatmulEncdecQk(queries, keysValues, heads);
		}

		public static SymbolOperators.ContribInterleavedMatmulEncdecQk ContribInterleavedMatmulEncdecQk(int heads, [Optional] [OptionalArgument] FSharpOption<Symbol> queries, [Optional] [OptionalArgument] FSharpOption<Symbol> keysValues)
		{
			return new SymbolOperators.ContribInterleavedMatmulEncdecQk(heads, queries, keysValues);
		}

		public static NDArray[] ContribInterleavedMatmulEncdecValatt(NDArray keysValues, NDArray attention, int heads)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_interleaved_matmul_encdec_valatt");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406200_002D179(keysValues, attention, 0, current));
			string[] parameterKeys = new string[1]
			{
				"heads"
			};
			string[] array = new string[1];
			object obj = heads;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribInterleavedMatmulEncdecValatt_00406203();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribInterleavedMatmulEncdecValatt(IEnumerable<NDArray> outputArray, NDArray keysValues, NDArray attention, int heads)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_interleaved_matmul_encdec_valatt");
			string[] names2 = new string[1]
			{
				"heads"
			};
			string[] array = new string[1];
			object obj = heads;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribInterleavedMatmulEncdecValatt_00406236_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406238_002D180(keysValues, attention, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406239_002D181(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribInterleavedMatmulEncdecValatt ContribInterleavedMatmulEncdecValatt(Symbol keysValues, Symbol attention, int heads)
		{
			return new SymbolOperators.ContribInterleavedMatmulEncdecValatt(keysValues, attention, heads);
		}

		public static SymbolOperators.ContribInterleavedMatmulEncdecValatt ContribInterleavedMatmulEncdecValatt(int heads, [Optional] [OptionalArgument] FSharpOption<Symbol> keysValues, [Optional] [OptionalArgument] FSharpOption<Symbol> attention)
		{
			return new SymbolOperators.ContribInterleavedMatmulEncdecValatt(heads, keysValues, attention);
		}

		public static NDArray ContribDivSqrtDim(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_div_sqrt_dim");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406314_002D182(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ContribDivSqrtDim(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_div_sqrt_dim");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00406329_002D17();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00406330_002D21();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribDivSqrtDim_00406331(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406333_002D183(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406334_002D184(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribDivSqrtDim ContribDivSqrtDim([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ContribDivSqrtDim(data);
		}

		public static NDArray[] Foreach(NDArray fn, params NDArray[] data, int numOutputs, int numOutData, IEnumerable<long> inStateLocs, IEnumerable<long> inDataLocs, IEnumerable<long> remainLocs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_foreach");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406369_002D185();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[6]
			{
				"num_args",
				"num_outputs",
				"num_out_data",
				"in_state_locs",
				"in_data_locs",
				"remain_locs"
			};
			string[] array2 = new string[6];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = numOutputs;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			object obj7 = numOutData;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array2[2] = (string)obj8;
			object obj10;
			if (inStateLocs != null)
			{
				IFormattable formattable7 = inStateLocs as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = inStateLocs;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array2[3] = (string)obj10;
			object obj12;
			if (inDataLocs != null)
			{
				IFormattable formattable9 = inDataLocs as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = inDataLocs;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array2[4] = (string)obj12;
			object obj14;
			if (remainLocs != null)
			{
				IFormattable formattable11 = remainLocs as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj14 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = remainLocs;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array2[5] = (string)obj14;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.Foreach_00406372();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void Foreach(IEnumerable<NDArray> outputArray, NDArray fn, params NDArray[] data, int numOutputs, int numOutData, IEnumerable<long> inStateLocs, IEnumerable<long> inDataLocs, IEnumerable<long> remainLocs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_foreach");
			string[] names2 = new string[6]
			{
				"num_args",
				"num_outputs",
				"num_out_data",
				"in_state_locs",
				"in_data_locs",
				"remain_locs"
			};
			string[] array = new string[6];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numOutputs;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = numOutData;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10;
			if (inStateLocs != null)
			{
				IFormattable formattable7 = inStateLocs as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = inStateLocs;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			object obj12;
			if (inDataLocs != null)
			{
				IFormattable formattable9 = inDataLocs as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = inDataLocs;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			object obj14;
			if (remainLocs != null)
			{
				IFormattable formattable11 = remainLocs as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj14 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = remainLocs;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[5] = (string)obj14;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Foreach_00406396_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406398_002D186();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406399_002D187(), outputArray)), names, vals);
		}

		public static SymbolOperators.Foreach Foreach(Symbol fn, IEnumerable<Symbol> data, int numOutputs, int numOutData, IEnumerable<long> inStateLocs, IEnumerable<long> inDataLocs, IEnumerable<long> remainLocs)
		{
			return new SymbolOperators.Foreach(fn, data, numOutputs, numOutData, inStateLocs, inDataLocs, remainLocs);
		}

		public static SymbolOperators.Foreach Foreach(int numOutputs, int numOutData, IEnumerable<long> inStateLocs, IEnumerable<long> inDataLocs, IEnumerable<long> remainLocs, [Optional] [OptionalArgument] FSharpOption<Symbol> fn, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data)
		{
			return new SymbolOperators.Foreach(numOutputs, numOutData, inStateLocs, inDataLocs, remainLocs, fn, data);
		}

		public static NDArray[] WhileLoop(NDArray cond, NDArray func, params NDArray[] data, int numOutputs, int numOutData, int maxIterations, IEnumerable<long> condInputLocs, IEnumerable<long> funcInputLocs, IEnumerable<long> funcVarLocs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_while_loop");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406453_002D188();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[7]
			{
				"num_args",
				"num_outputs",
				"num_out_data",
				"max_iterations",
				"cond_input_locs",
				"func_input_locs",
				"func_var_locs"
			};
			string[] array2 = new string[7];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = numOutputs;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			object obj7 = numOutData;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array2[2] = (string)obj8;
			object obj10 = maxIterations;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array2[3] = (string)obj11;
			object obj13;
			if (condInputLocs != null)
			{
				IFormattable formattable9 = condInputLocs as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = condInputLocs;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array2[4] = (string)obj13;
			object obj15;
			if (funcInputLocs != null)
			{
				IFormattable formattable11 = funcInputLocs as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = funcInputLocs;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array2[5] = (string)obj15;
			object obj17;
			if (funcVarLocs != null)
			{
				IFormattable formattable13 = funcVarLocs as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj17 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = funcVarLocs;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array2[6] = (string)obj17;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.WhileLoop_00406456();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void WhileLoop(IEnumerable<NDArray> outputArray, NDArray cond, NDArray func, params NDArray[] data, int numOutputs, int numOutData, int maxIterations, IEnumerable<long> condInputLocs, IEnumerable<long> funcInputLocs, IEnumerable<long> funcVarLocs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_while_loop");
			string[] names2 = new string[7]
			{
				"num_args",
				"num_outputs",
				"num_out_data",
				"max_iterations",
				"cond_input_locs",
				"func_input_locs",
				"func_var_locs"
			};
			string[] array = new string[7];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numOutputs;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = numOutData;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = maxIterations;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13;
			if (condInputLocs != null)
			{
				IFormattable formattable9 = condInputLocs as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = condInputLocs;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15;
			if (funcInputLocs != null)
			{
				IFormattable formattable11 = funcInputLocs as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = funcInputLocs;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array[5] = (string)obj15;
			object obj17;
			if (funcVarLocs != null)
			{
				IFormattable formattable13 = funcVarLocs as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj17 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = funcVarLocs;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[6] = (string)obj17;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.WhileLoop_00406484_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406486_002D189();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406487_002D190(), outputArray)), names, vals);
		}

		public static SymbolOperators.WhileLoop WhileLoop(Symbol cond, Symbol func, IEnumerable<Symbol> data, int numOutputs, int numOutData, int maxIterations, IEnumerable<long> condInputLocs, IEnumerable<long> funcInputLocs, IEnumerable<long> funcVarLocs)
		{
			return new SymbolOperators.WhileLoop(cond, func, data, numOutputs, numOutData, maxIterations, condInputLocs, funcInputLocs, funcVarLocs);
		}

		public static SymbolOperators.WhileLoop WhileLoop(int numOutputs, int numOutData, int maxIterations, IEnumerable<long> condInputLocs, IEnumerable<long> funcInputLocs, IEnumerable<long> funcVarLocs, [Optional] [OptionalArgument] FSharpOption<Symbol> cond, [Optional] [OptionalArgument] FSharpOption<Symbol> func, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data)
		{
			return new SymbolOperators.WhileLoop(numOutputs, numOutData, maxIterations, condInputLocs, funcInputLocs, funcVarLocs, cond, func, data);
		}

		public static NDArray[] Cond(NDArray cond, NDArray thenBranch, NDArray elseBranch, params NDArray[] data, int numOutputs, IEnumerable<long> condInputLocs, IEnumerable<long> thenInputLocs, IEnumerable<long> elseInputLocs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cond");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406543_002D191();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[5]
			{
				"num_args",
				"num_outputs",
				"cond_input_locs",
				"then_input_locs",
				"else_input_locs"
			};
			string[] array2 = new string[5];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = numOutputs;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			object obj7;
			if (condInputLocs != null)
			{
				IFormattable formattable5 = condInputLocs as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = condInputLocs;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array2[2] = (string)obj7;
			object obj9;
			if (thenInputLocs != null)
			{
				IFormattable formattable7 = thenInputLocs as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = thenInputLocs;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array2[3] = (string)obj9;
			object obj11;
			if (elseInputLocs != null)
			{
				IFormattable formattable9 = elseInputLocs as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj11 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = elseInputLocs;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array2[4] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.Cond_00406546();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void Cond(IEnumerable<NDArray> outputArray, NDArray cond, NDArray thenBranch, NDArray elseBranch, params NDArray[] data, int numOutputs, IEnumerable<long> condInputLocs, IEnumerable<long> thenInputLocs, IEnumerable<long> elseInputLocs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_cond");
			string[] names2 = new string[5]
			{
				"num_args",
				"num_outputs",
				"cond_input_locs",
				"then_input_locs",
				"else_input_locs"
			};
			string[] array = new string[5];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numOutputs;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (condInputLocs != null)
			{
				IFormattable formattable5 = condInputLocs as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = condInputLocs;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if (thenInputLocs != null)
			{
				IFormattable formattable7 = thenInputLocs as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = thenInputLocs;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array[3] = (string)obj9;
			object obj11;
			if (elseInputLocs != null)
			{
				IFormattable formattable9 = elseInputLocs as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj11 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = elseInputLocs;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[4] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Cond_00406572_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406574_002D192();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406575_002D193(), outputArray)), names, vals);
		}

		public static SymbolOperators.Cond Cond(Symbol cond, Symbol thenBranch, Symbol elseBranch, IEnumerable<Symbol> data, int numOutputs, IEnumerable<long> condInputLocs, IEnumerable<long> thenInputLocs, IEnumerable<long> elseInputLocs)
		{
			return new SymbolOperators.Cond(cond, thenBranch, elseBranch, data, numOutputs, condInputLocs, thenInputLocs, elseInputLocs);
		}

		public static SymbolOperators.Cond Cond(int numOutputs, IEnumerable<long> condInputLocs, IEnumerable<long> thenInputLocs, IEnumerable<long> elseInputLocs, [Optional] [OptionalArgument] FSharpOption<Symbol> cond, [Optional] [OptionalArgument] FSharpOption<Symbol> thenBranch, [Optional] [OptionalArgument] FSharpOption<Symbol> elseBranch, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data)
		{
			return new SymbolOperators.Cond(numOutputs, condInputLocs, thenInputLocs, elseInputLocs, cond, thenBranch, elseBranch, data);
		}

		public static NDArray[] Custom(params NDArray[] data, string opType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Custom");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406621_002D194();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, new string[1]
			{
				"op_type"
			}, new string[1]
			{
				opType
			});
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.Custom_00406624();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				array4[j] = val2.Invoke(array3[j]);
			}
			return array4;
		}

		public static void Custom(IEnumerable<NDArray> outputArray, params NDArray[] data, string opType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Custom");
			string[] names2 = new string[1]
			{
				"op_type"
			};
			string[] vals2 = new string[1]
			{
				opType
			};
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Custom_00406641_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406643_002D195();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406644_002D196(), outputArray)), names, vals);
		}

		public static SymbolOperators.Custom Custom(IEnumerable<Symbol> data, string opType)
		{
			return new SymbolOperators.Custom(data, opType);
		}

		public static SymbolOperators.Custom Custom(string opType, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data)
		{
			return new SymbolOperators.Custom(opType, data);
		}

		public static SymbolOperators.Custom Custom(string opType, params Symbol[] data)
		{
			return new SymbolOperators.Custom(opType, data);
		}

		public static NDArray[] FusedOp(params NDArray[] data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_FusedOp");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406693_002D197();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.FusedOp_00406696();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				array4[j] = val2.Invoke(array3[j]);
			}
			return array4;
		}

		public static void FusedOp(IEnumerable<NDArray> outputArray, params NDArray[] data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_FusedOp");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00406701_002D18();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00406702_002D22();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.FusedOp_00406703_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00406705_002D198();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406706_002D199(), outputArray)), names, vals);
		}

		public static SymbolOperators.FusedOp FusedOp(params Symbol[] data)
		{
			return new SymbolOperators.FusedOp(data);
		}

		public static NDArray[] FusedOpHelperNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_FusedOpHelper");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.FusedOpHelperNDArray_00406720();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void FusedOpHelper(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_FusedOpHelper");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00406724_002D19();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00406725_002D23();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.FusedOpHelper_00406726(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406729_002D200(), outputArray)), names, vals);
		}

		public static SymbolOperators.FusedOpHelper FusedOpHelper()
		{
			return new SymbolOperators.FusedOpHelper();
		}

		public static NDArray[] FusedOpOutHelperNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_FusedOpOutHelper");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.FusedOpOutHelperNDArray_00406742();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void FusedOpOutHelper(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_FusedOpOutHelper");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00406746_002D20();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00406747_002D24();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.FusedOpOutHelper_00406748(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406751_002D201(), outputArray)), names, vals);
		}

		public static SymbolOperators.FusedOpOutHelper FusedOpOutHelper()
		{
			return new SymbolOperators.FusedOpOutHelper();
		}

		public static NDArray[] IdentityAttachKLSparseReg(NDArray data, double sparsenessTarget = 0.1, double penalty = 0.001, double momentum = 0.9)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("IdentityAttachKLSparseReg");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406766_002D202(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"sparseness_target",
				"penalty",
				"momentum"
			};
			string[] array = new string[3];
			object obj = sparsenessTarget;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = penalty;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = momentum;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.IdentityAttachKLSparseReg_00406769();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void IdentityAttachKLSparseReg(IEnumerable<NDArray> outputArray, NDArray data, double sparsenessTarget = 0.1, double penalty = 0.001, double momentum = 0.9)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("IdentityAttachKLSparseReg");
			string[] names2 = new string[3]
			{
				"sparseness_target",
				"penalty",
				"momentum"
			};
			string[] array = new string[3];
			object obj = sparsenessTarget;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = penalty;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = momentum;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.IdentityAttachKLSparseReg_00406780_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406782_002D203(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406783_002D204(), outputArray)), names, vals);
		}

		public static SymbolOperators.IdentityAttachKLSparseReg IdentityAttachKLSparseReg([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> sparsenessTarget, [Optional] [OptionalArgument] FSharpOption<double> penalty, [Optional] [OptionalArgument] FSharpOption<double> momentum)
		{
			return new SymbolOperators.IdentityAttachKLSparseReg(data, sparsenessTarget, penalty, momentum);
		}

		public static NDArray ImageCrop(NDArray data, int x, int y, int width, int height)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_crop");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406837_002D205(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"x",
				"y",
				"width",
				"height"
			};
			string[] array = new string[4];
			object obj = x;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = y;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = width;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = height;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ImageCrop(IEnumerable<NDArray> outputArray, NDArray data, int x, int y, int width, int height)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_crop");
			string[] names2 = new string[4]
			{
				"x",
				"y",
				"width",
				"height"
			};
			string[] array = new string[4];
			object obj = x;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = y;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = width;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = height;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageCrop_00406886(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00406888_002D206(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00406889_002D207(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageCrop ImageCrop(Symbol data, int x, int y, int width, int height)
		{
			return new SymbolOperators.ImageCrop(data, x, y, width, height);
		}

		public static SymbolOperators.ImageCrop ImageCrop(int x, int y, int width, int height, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageCrop(x, y, width, height, data);
		}

		public static NDArray ImageToTensor(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_to_tensor");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407025_002D208(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ImageToTensor(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_to_tensor");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00407085_002D21();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00407086_002D25();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageToTensor_00407087(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407089_002D209(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407090_002D210(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageToTensor ImageToTensor([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageToTensor(data);
		}

		public static NDArray ImageNormalize(NDArray data, [Optional] IEnumerable<double> mean, [Optional] IEnumerable<double> std)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_normalize");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407219_002D211(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"mean",
				"std"
			};
			string[] array = new string[2];
			object obj;
			if ((mean == null) ? true : false)
			{
				obj = "[0,0,0,0]";
			}
			else if (mean != null)
			{
				IFormattable formattable = mean as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = mean;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((std == null) ? true : false)
			{
				obj3 = "[1,1,1,1]";
			}
			else if (std != null)
			{
				IFormattable formattable3 = std as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = std;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ImageNormalize(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<double> mean, [Optional] IEnumerable<double> std)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_normalize");
			string[] names2 = new string[2]
			{
				"mean",
				"std"
			};
			string[] array = new string[2];
			object obj;
			if ((mean == null) ? true : false)
			{
				obj = "[0,0,0,0]";
			}
			else if (mean != null)
			{
				IFormattable formattable = mean as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = mean;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((std == null) ? true : false)
			{
				obj3 = "[1,1,1,1]";
			}
			else if (std != null)
			{
				IFormattable formattable3 = std as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = std;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageNormalize_00407294(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407296_002D212(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407297_002D213(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageNormalize ImageNormalize([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> mean, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> std)
		{
			return new SymbolOperators.ImageNormalize(data, mean, std);
		}

		public static NDArray[] ImageFlipLeftRight(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_flip_left_right");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407378_002D214(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageFlipLeftRight_00407381();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ImageFlipLeftRight(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_flip_left_right");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00407389_002D22();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00407390_002D26();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageFlipLeftRight_00407391_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407393_002D215(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407394_002D216(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageFlipLeftRight ImageFlipLeftRight([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageFlipLeftRight(data);
		}

		public static NDArray[] ImageRandomFlipLeftRight(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_flip_left_right");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407412_002D217(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageRandomFlipLeftRight_00407415();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ImageRandomFlipLeftRight(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_flip_left_right");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00407423_002D23();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00407424_002D27();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageRandomFlipLeftRight_00407425_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407427_002D218(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407428_002D219(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageRandomFlipLeftRight ImageRandomFlipLeftRight([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageRandomFlipLeftRight(data);
		}

		public static NDArray[] ImageFlipTopBottom(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_flip_top_bottom");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407446_002D220(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageFlipTopBottom_00407449();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ImageFlipTopBottom(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_flip_top_bottom");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00407457_002D24();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00407458_002D28();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageFlipTopBottom_00407459_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407461_002D221(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407462_002D222(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageFlipTopBottom ImageFlipTopBottom([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageFlipTopBottom(data);
		}

		public static NDArray[] ImageRandomFlipTopBottom(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_flip_top_bottom");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407480_002D223(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageRandomFlipTopBottom_00407483();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ImageRandomFlipTopBottom(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_flip_top_bottom");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00407491_002D25();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00407492_002D29();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageRandomFlipTopBottom_00407493_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407495_002D224(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407496_002D225(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageRandomFlipTopBottom ImageRandomFlipTopBottom([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageRandomFlipTopBottom(data);
		}

		public static NDArray[] ImageRandomBrightness(NDArray data, double minFactor, double maxFactor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_brightness");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407516_002D226(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"min_factor",
				"max_factor"
			};
			string[] array = new string[2];
			object obj = minFactor;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxFactor;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageRandomBrightness_00407519();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ImageRandomBrightness(IEnumerable<NDArray> outputArray, NDArray data, double minFactor, double maxFactor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_brightness");
			string[] names2 = new string[2]
			{
				"min_factor",
				"max_factor"
			};
			string[] array = new string[2];
			object obj = minFactor;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxFactor;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageRandomBrightness_00407531_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407533_002D227(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407534_002D228(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageRandomBrightness ImageRandomBrightness(Symbol data, double minFactor, double maxFactor)
		{
			return new SymbolOperators.ImageRandomBrightness(data, minFactor, maxFactor);
		}

		public static SymbolOperators.ImageRandomBrightness ImageRandomBrightness(double minFactor, double maxFactor, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageRandomBrightness(minFactor, maxFactor, data);
		}

		public static NDArray[] ImageRandomContrast(NDArray data, double minFactor, double maxFactor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_contrast");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407564_002D229(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"min_factor",
				"max_factor"
			};
			string[] array = new string[2];
			object obj = minFactor;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxFactor;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageRandomContrast_00407567();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ImageRandomContrast(IEnumerable<NDArray> outputArray, NDArray data, double minFactor, double maxFactor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_contrast");
			string[] names2 = new string[2]
			{
				"min_factor",
				"max_factor"
			};
			string[] array = new string[2];
			object obj = minFactor;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxFactor;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageRandomContrast_00407579_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407581_002D230(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407582_002D231(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageRandomContrast ImageRandomContrast(Symbol data, double minFactor, double maxFactor)
		{
			return new SymbolOperators.ImageRandomContrast(data, minFactor, maxFactor);
		}

		public static SymbolOperators.ImageRandomContrast ImageRandomContrast(double minFactor, double maxFactor, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageRandomContrast(minFactor, maxFactor, data);
		}

		public static NDArray[] ImageRandomSaturation(NDArray data, double minFactor, double maxFactor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_saturation");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407612_002D232(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"min_factor",
				"max_factor"
			};
			string[] array = new string[2];
			object obj = minFactor;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxFactor;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageRandomSaturation_00407615();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ImageRandomSaturation(IEnumerable<NDArray> outputArray, NDArray data, double minFactor, double maxFactor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_saturation");
			string[] names2 = new string[2]
			{
				"min_factor",
				"max_factor"
			};
			string[] array = new string[2];
			object obj = minFactor;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxFactor;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageRandomSaturation_00407627_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407629_002D233(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407630_002D234(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageRandomSaturation ImageRandomSaturation(Symbol data, double minFactor, double maxFactor)
		{
			return new SymbolOperators.ImageRandomSaturation(data, minFactor, maxFactor);
		}

		public static SymbolOperators.ImageRandomSaturation ImageRandomSaturation(double minFactor, double maxFactor, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageRandomSaturation(minFactor, maxFactor, data);
		}

		public static NDArray[] ImageRandomHue(NDArray data, double minFactor, double maxFactor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_hue");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407660_002D235(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"min_factor",
				"max_factor"
			};
			string[] array = new string[2];
			object obj = minFactor;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxFactor;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageRandomHue_00407663();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ImageRandomHue(IEnumerable<NDArray> outputArray, NDArray data, double minFactor, double maxFactor)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_hue");
			string[] names2 = new string[2]
			{
				"min_factor",
				"max_factor"
			};
			string[] array = new string[2];
			object obj = minFactor;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxFactor;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageRandomHue_00407675_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407677_002D236(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407678_002D237(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageRandomHue ImageRandomHue(Symbol data, double minFactor, double maxFactor)
		{
			return new SymbolOperators.ImageRandomHue(data, minFactor, maxFactor);
		}

		public static SymbolOperators.ImageRandomHue ImageRandomHue(double minFactor, double maxFactor, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageRandomHue(minFactor, maxFactor, data);
		}

		public static NDArray[] ImageRandomColorJitter(NDArray data, double brightness, double contrast, double saturation, double hue)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_color_jitter");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407714_002D238(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"brightness",
				"contrast",
				"saturation",
				"hue"
			};
			string[] array = new string[4];
			object obj = brightness;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = contrast;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = saturation;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = hue;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageRandomColorJitter_00407717();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ImageRandomColorJitter(IEnumerable<NDArray> outputArray, NDArray data, double brightness, double contrast, double saturation, double hue)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_color_jitter");
			string[] names2 = new string[4]
			{
				"brightness",
				"contrast",
				"saturation",
				"hue"
			};
			string[] array = new string[4];
			object obj = brightness;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = contrast;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = saturation;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = hue;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageRandomColorJitter_00407736_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407738_002D239(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407739_002D240(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageRandomColorJitter ImageRandomColorJitter(Symbol data, double brightness, double contrast, double saturation, double hue)
		{
			return new SymbolOperators.ImageRandomColorJitter(data, brightness, contrast, saturation, hue);
		}

		public static SymbolOperators.ImageRandomColorJitter ImageRandomColorJitter(double brightness, double contrast, double saturation, double hue, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageRandomColorJitter(brightness, contrast, saturation, hue, data);
		}

		public static NDArray[] ImageAdjustLighting(NDArray data, IEnumerable<double> alpha)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_adjust_lighting");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407772_002D241(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"alpha"
			};
			string[] array = new string[1];
			object obj;
			if (alpha != null)
			{
				IFormattable formattable = alpha as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = alpha;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageAdjustLighting_00407775();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ImageAdjustLighting(IEnumerable<NDArray> outputArray, NDArray data, IEnumerable<double> alpha)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_adjust_lighting");
			string[] names2 = new string[1]
			{
				"alpha"
			};
			string[] array = new string[1];
			object obj;
			if (alpha != null)
			{
				IFormattable formattable = alpha as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = alpha;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageAdjustLighting_00407786_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407788_002D242(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407789_002D243(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageAdjustLighting ImageAdjustLighting(Symbol data, IEnumerable<double> alpha)
		{
			return new SymbolOperators.ImageAdjustLighting(data, alpha);
		}

		public static SymbolOperators.ImageAdjustLighting ImageAdjustLighting(IEnumerable<double> alpha, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ImageAdjustLighting(alpha, data);
		}

		public static NDArray[] ImageRandomLighting(NDArray data, double alphaStd = 0.05)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_lighting");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407816_002D244(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"alpha_std"
			};
			string[] array = new string[1];
			object obj = alphaStd;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ImageRandomLighting_00407819();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ImageRandomLighting(IEnumerable<NDArray> outputArray, NDArray data, double alphaStd = 0.05)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_random_lighting");
			string[] names2 = new string[1]
			{
				"alpha_std"
			};
			string[] array = new string[1];
			object obj = alphaStd;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageRandomLighting_00407830_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407832_002D245(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407833_002D246(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageRandomLighting ImageRandomLighting([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> alphaStd)
		{
			return new SymbolOperators.ImageRandomLighting(data, alphaStd);
		}

		public static NDArray ImageResize(NDArray data, [Optional] IEnumerable<int> size, bool keepRatio = false, int interp = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_resize");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407888_002D247(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"size",
				"keep_ratio",
				"interp"
			};
			string[] array = new string[3];
			object obj;
			if ((size == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00407890_002D248(), size));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			bool flag = keepRatio;
			object obj2 = flag;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5 = interp;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable3 = obj5 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj6 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ImageResize(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> size, bool keepRatio = false, int interp = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_image_resize");
			string[] names2 = new string[3]
			{
				"size",
				"keep_ratio",
				"interp"
			};
			string[] array = new string[3];
			object obj;
			if ((size == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00407936_002D30(), size));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			bool flag = keepRatio;
			object obj2 = flag;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5 = interp;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable3 = obj5 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj6 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ImageResize_00407937(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00407939_002D249(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00407940_002D250(), outputArray)), names, vals);
		}

		public static SymbolOperators.ImageResize ImageResize([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<bool> keepRatio, [Optional] [OptionalArgument] FSharpOption<int> interp)
		{
			return new SymbolOperators.ImageResize(data, size, keepRatio, interp);
		}

		public static NDArray LeakyReLU(NDArray data, NDArray gamma, [Optional] GeneratedArgumentTypes.LeakyReLUType actType, double slope = 0.25, double lowerBound = 0.125, double upperBound = 0.334)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LeakyReLU");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408020_002D251(data, gamma, 0, current));
			string[] parameterKeys = new string[4]
			{
				"act_type",
				"slope",
				"lower_bound",
				"upper_bound"
			};
			string[] array = new string[4];
			object obj;
			if ((actType == null) ? true : false)
			{
				obj = "leaky";
			}
			else if (actType != null)
			{
				IFormattable formattable = actType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = actType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = slope;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = lowerBound;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9 = upperBound;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LeakyReLU(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, [Optional] GeneratedArgumentTypes.LeakyReLUType actType, double slope = 0.25, double lowerBound = 0.125, double upperBound = 0.334)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LeakyReLU");
			string[] names2 = new string[4]
			{
				"act_type",
				"slope",
				"lower_bound",
				"upper_bound"
			};
			string[] array = new string[4];
			object obj;
			if ((actType == null) ? true : false)
			{
				obj = "leaky";
			}
			else if (actType != null)
			{
				IFormattable formattable = actType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = actType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = slope;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = lowerBound;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9 = upperBound;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LeakyReLU_00408060(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408062_002D252(data, gamma, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00408063_002D253(), outputArray)), names, vals);
		}

		public static SymbolOperators.LeakyReLU LeakyReLU([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.LeakyReLUType> actType, [Optional] [OptionalArgument] FSharpOption<double> slope, [Optional] [OptionalArgument] FSharpOption<double> lowerBound, [Optional] [OptionalArgument] FSharpOption<double> upperBound)
		{
			return new SymbolOperators.LeakyReLU(data, gamma, actType, slope, lowerBound, upperBound);
		}

		public static NDArray SoftmaxCrossEntropy(NDArray data, NDArray label)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("softmax_cross_entropy");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408132_002D254(data, label, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void SoftmaxCrossEntropy(IEnumerable<NDArray> outputArray, NDArray data, NDArray label)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("softmax_cross_entropy");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_00408172_002D26();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_00408173_002D31();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SoftmaxCrossEntropy_00408174(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408176_002D255(data, label, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00408177_002D256(), outputArray)), names, vals);
		}

		public static SymbolOperators.SoftmaxCrossEntropy SoftmaxCrossEntropy([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> label)
		{
			return new SymbolOperators.SoftmaxCrossEntropy(data, label);
		}

		public static NDArray Activation(NDArray data, GeneratedArgumentTypes.ActType actType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Activation");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408236_002D257(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"act_type"
			};
			string[] array = new string[1];
			object obj;
			if (actType != null)
			{
				IFormattable formattable = actType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = actType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Activation(IEnumerable<NDArray> outputArray, NDArray data, GeneratedArgumentTypes.ActType actType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Activation");
			string[] names2 = new string[1]
			{
				"act_type"
			};
			string[] array = new string[1];
			object obj;
			if (actType != null)
			{
				IFormattable formattable = actType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = actType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Activation_00408260(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408262_002D258(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00408263_002D259(), outputArray)), names, vals);
		}

		public static SymbolOperators.Activation Activation(Symbol data, GeneratedArgumentTypes.ActType actType)
		{
			return new SymbolOperators.Activation(data, actType);
		}

		public static SymbolOperators.Activation Activation(GeneratedArgumentTypes.ActType actType, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Activation(actType, data);
		}

		public static NDArray[] BatchNorm(NDArray data, NDArray gamma, NDArray beta, NDArray movingMean, NDArray movingVar, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("BatchNorm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408385_002D260(data, gamma, beta, movingMean, movingVar, 0, current));
			string[] parameterKeys = new string[9]
			{
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var",
				"axis",
				"cudnn_off",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[9];
			object obj;
			if (eps == null)
			{
				obj = "0.001";
			}
			else
			{
				FSharpOption<double> val = eps;
				double eps2 = val.get_Value();
				double num = eps2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (momentum == null)
			{
				obj4 = "0.9";
			}
			else
			{
				FSharpOption<double> val2 = momentum;
				double momentum2 = val2.get_Value();
				double num2 = momentum2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (fixGamma == null)
			{
				obj7 = "true";
			}
			else
			{
				FSharpOption<bool> val3 = fixGamma;
				bool fixGamma2 = val3.get_Value();
				bool flag = fixGamma2;
				object obj8 = flag;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useGlobalStats == null)
			{
				obj10 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = useGlobalStats;
				bool useGlobalStats2 = val4.get_Value();
				bool flag2 = useGlobalStats2;
				object obj11 = flag2;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (outputMeanVar == null)
			{
				obj13 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = outputMeanVar;
				bool outputMeanVar2 = val5.get_Value();
				bool flag3 = outputMeanVar2;
				object obj14 = flag3;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			object obj16;
			if (axis == null)
			{
				obj16 = "1";
			}
			else
			{
				FSharpOption<int> val6 = axis;
				int axis2 = val6.get_Value();
				int num3 = axis2;
				object obj17 = num3;
				if (obj17 != null)
				{
					IFormattable formattable11 = obj17 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[5] = (string)obj16;
			object obj19;
			if (cudnnOff == null)
			{
				obj19 = "false";
			}
			else
			{
				FSharpOption<bool> val7 = cudnnOff;
				bool cudnnOff2 = val7.get_Value();
				bool flag4 = cudnnOff2;
				object obj20 = flag4;
				if (obj20 != null)
				{
					IFormattable formattable13 = obj20 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[6] = (string)obj19;
			object obj22;
			if (minCalibRange == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<double> val8 = minCalibRange;
				double minCalibRange2 = val8.get_Value();
				double num4 = minCalibRange2;
				object obj23 = num4;
				if (obj23 != null)
				{
					IFormattable formattable15 = obj23 as IFormattable;
					if (formattable15 != null)
					{
						IFormattable formattable16 = formattable15;
						obj22 = formattable16.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[7] = (string)obj22;
			object obj25;
			if (maxCalibRange == null)
			{
				obj25 = "None";
			}
			else
			{
				FSharpOption<double> val9 = maxCalibRange;
				double maxCalibRange2 = val9.get_Value();
				double num5 = maxCalibRange2;
				object obj26 = num5;
				if (obj26 != null)
				{
					IFormattable formattable17 = obj26 as IFormattable;
					if (formattable17 != null)
					{
						IFormattable formattable18 = formattable17;
						obj25 = formattable18.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj27 = obj26;
						obj25 = obj27.ToString();
					}
				}
				else
				{
					obj25 = "";
				}
			}
			array[8] = (string)obj25;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val10 = new _0024Operators.BatchNorm_00408388();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val10.Invoke(array3[i]);
			}
			return array4;
		}

		public static void BatchNorm(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, NDArray beta, NDArray movingMean, NDArray movingVar, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("BatchNorm");
			string[] names2 = new string[9]
			{
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var",
				"axis",
				"cudnn_off",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[9];
			object obj;
			if (eps == null)
			{
				obj = "0.001";
			}
			else
			{
				FSharpOption<double> val = eps;
				double eps2 = val.get_Value();
				double num = eps2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (momentum == null)
			{
				obj4 = "0.9";
			}
			else
			{
				FSharpOption<double> val2 = momentum;
				double momentum2 = val2.get_Value();
				double num2 = momentum2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (fixGamma == null)
			{
				obj7 = "true";
			}
			else
			{
				FSharpOption<bool> val3 = fixGamma;
				bool fixGamma2 = val3.get_Value();
				bool flag = fixGamma2;
				object obj8 = flag;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useGlobalStats == null)
			{
				obj10 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = useGlobalStats;
				bool useGlobalStats2 = val4.get_Value();
				bool flag2 = useGlobalStats2;
				object obj11 = flag2;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (outputMeanVar == null)
			{
				obj13 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = outputMeanVar;
				bool outputMeanVar2 = val5.get_Value();
				bool flag3 = outputMeanVar2;
				object obj14 = flag3;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			object obj16;
			if (axis == null)
			{
				obj16 = "1";
			}
			else
			{
				FSharpOption<int> val6 = axis;
				int axis2 = val6.get_Value();
				int num3 = axis2;
				object obj17 = num3;
				if (obj17 != null)
				{
					IFormattable formattable11 = obj17 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[5] = (string)obj16;
			object obj19;
			if (cudnnOff == null)
			{
				obj19 = "false";
			}
			else
			{
				FSharpOption<bool> val7 = cudnnOff;
				bool cudnnOff2 = val7.get_Value();
				bool flag4 = cudnnOff2;
				object obj20 = flag4;
				if (obj20 != null)
				{
					IFormattable formattable13 = obj20 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[6] = (string)obj19;
			object obj22;
			if (minCalibRange == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<double> val8 = minCalibRange;
				double minCalibRange2 = val8.get_Value();
				double num4 = minCalibRange2;
				object obj23 = num4;
				if (obj23 != null)
				{
					IFormattable formattable15 = obj23 as IFormattable;
					if (formattable15 != null)
					{
						IFormattable formattable16 = formattable15;
						obj22 = formattable16.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[7] = (string)obj22;
			object obj25;
			if (maxCalibRange == null)
			{
				obj25 = "None";
			}
			else
			{
				FSharpOption<double> val9 = maxCalibRange;
				double maxCalibRange2 = val9.get_Value();
				double num5 = maxCalibRange2;
				object obj26 = num5;
				if (obj26 != null)
				{
					IFormattable formattable17 = obj26 as IFormattable;
					if (formattable17 != null)
					{
						IFormattable formattable18 = formattable17;
						obj25 = formattable18.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj27 = obj26;
						obj25 = obj27.ToString();
					}
				}
				else
				{
					obj25 = "";
				}
			}
			array[8] = (string)obj25;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BatchNorm_00408474_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408476_002D261(data, gamma, beta, movingMean, movingVar, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00408477_002D262(), outputArray)), names, vals);
		}

		public static SymbolOperators.BatchNorm BatchNorm([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<Symbol> movingMean, [Optional] [OptionalArgument] FSharpOption<Symbol> movingVar, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			return new SymbolOperators.BatchNorm(data, gamma, beta, movingMean, movingVar, eps, momentum, fixGamma, useGlobalStats, outputMeanVar, axis, cudnnOff, minCalibRange, maxCalibRange);
		}

		public static NDArray Concat(params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Concat");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00408596_002D263();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array2 = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			return new NDArray(outputs[0]);
		}

		public static void Concat(IEnumerable<NDArray> outputArray, params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Concat");
			string[] names2 = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Concat_00408647(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00408649_002D264();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00408650_002D265(), outputArray)), names, vals);
		}

		public static SymbolOperators.Concat Concat([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> dim)
		{
			return new SymbolOperators.Concat(data, dim);
		}

		public static NDArray[] RnnParamConcat(params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rnn_param_concat");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00408705_002D266();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array2 = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.RnnParamConcat_00408708();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void RnnParamConcat(IEnumerable<NDArray> outputArray, params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rnn_param_concat");
			string[] names2 = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RnnParamConcat_00408717_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_00408719_002D267();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00408720_002D268(), outputArray)), names, vals);
		}

		public static SymbolOperators.RnnParamConcat RnnParamConcat([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> dim)
		{
			return new SymbolOperators.RnnParamConcat(data, dim);
		}

		public static NDArray Convolution(NDArray data, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, long workspace = 1024L, bool noBias = false, [Optional] GeneratedArgumentTypes.CudnnTune cudnnTune, bool cudnnOff = false, [Optional] GeneratedArgumentTypes.ConvolutionLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Convolution");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408835_002D269(data, weight, bias, 0, current));
			string[] parameterKeys = new string[11]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"workspace",
				"no_bias",
				"cudnn_tune",
				"cudnn_off",
				"layout"
			};
			string[] array = new string[11];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00408837_002D270(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00408837_002D271(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00408837_002D272(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00408837_002D273(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = workspace;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			bool flag = noBias;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			object obj16;
			if ((cudnnTune == null) ? true : false)
			{
				obj16 = "None";
			}
			else if (cudnnTune != null)
			{
				IFormattable formattable9 = cudnnTune as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = cudnnTune;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[8] = (string)obj16;
			bool flag2 = cudnnOff;
			object obj18 = flag2;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable11 = obj18 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[9] = (string)obj19;
			object obj21;
			if ((layout == null) ? true : false)
			{
				obj21 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj21 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = layout;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[10] = (string)obj21;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Convolution(IEnumerable<NDArray> outputArray, NDArray data, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, long workspace = 1024L, bool noBias = false, [Optional] GeneratedArgumentTypes.CudnnTune cudnnTune, bool cudnnOff = false, [Optional] GeneratedArgumentTypes.ConvolutionLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Convolution");
			string[] names2 = new string[11]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"workspace",
				"no_bias",
				"cudnn_tune",
				"cudnn_off",
				"layout"
			};
			string[] array = new string[11];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00408947_002D32(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00408947_002D33(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00408947_002D34(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00408947_002D35(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = workspace;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			bool flag = noBias;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			object obj16;
			if ((cudnnTune == null) ? true : false)
			{
				obj16 = "None";
			}
			else if (cudnnTune != null)
			{
				IFormattable formattable9 = cudnnTune as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = cudnnTune;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[8] = (string)obj16;
			bool flag2 = cudnnOff;
			object obj18 = flag2;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable11 = obj18 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[9] = (string)obj19;
			object obj21;
			if ((layout == null) ? true : false)
			{
				obj21 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj21 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = layout;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[10] = (string)obj21;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Convolution_00408948(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00408950_002D274(data, weight, bias, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00408951_002D275(), outputArray)), names, vals);
		}

		public static SymbolOperators.Convolution Convolution(Symbol data, Symbol weight, Symbol bias, IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.CudnnTune> cudnnTune, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ConvolutionLayout> layout)
		{
			return new SymbolOperators.Convolution(data, weight, bias, kernel, numFilter, stride, dilate, pad, numGroup, workspace, noBias, cudnnTune, cudnnOff, layout);
		}

		public static SymbolOperators.Convolution Convolution(IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> bias, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.CudnnTune> cudnnTune, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ConvolutionLayout> layout)
		{
			return new SymbolOperators.Convolution(kernel, numFilter, data, weight, bias, stride, dilate, pad, numGroup, workspace, noBias, cudnnTune, cudnnOff, layout);
		}

		public static NDArray CTCLoss(NDArray data, NDArray label, NDArray dataLengths, NDArray labelLengths, bool useDataLengths = false, bool useLabelLengths = false, [Optional] GeneratedArgumentTypes.BlankLabel blankLabel)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("CTCLoss");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409205_002D276(data, label, dataLengths, labelLengths, 0, current));
			string[] parameterKeys = new string[3]
			{
				"use_data_lengths",
				"use_label_lengths",
				"blank_label"
			};
			string[] array = new string[3];
			bool flag = useDataLengths;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = useLabelLengths;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((blankLabel == null) ? true : false)
			{
				obj7 = "first";
			}
			else if (blankLabel != null)
			{
				IFormattable formattable5 = blankLabel as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = blankLabel;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void CTCLoss(IEnumerable<NDArray> outputArray, NDArray data, NDArray label, NDArray dataLengths, NDArray labelLengths, bool useDataLengths = false, bool useLabelLengths = false, [Optional] GeneratedArgumentTypes.BlankLabel blankLabel)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("CTCLoss");
			string[] names2 = new string[3]
			{
				"use_data_lengths",
				"use_label_lengths",
				"blank_label"
			};
			string[] array = new string[3];
			bool flag = useDataLengths;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = useLabelLengths;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((blankLabel == null) ? true : false)
			{
				obj7 = "first";
			}
			else if (blankLabel != null)
			{
				IFormattable formattable5 = blankLabel as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = blankLabel;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.CTCLoss_00409276(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409278_002D277(data, label, dataLengths, labelLengths, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00409279_002D278(), outputArray)), names, vals);
		}

		public static SymbolOperators.CTCLoss CTCLoss([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> label, [Optional] [OptionalArgument] FSharpOption<Symbol> dataLengths, [Optional] [OptionalArgument] FSharpOption<Symbol> labelLengths, [Optional] [OptionalArgument] FSharpOption<bool> useDataLengths, [Optional] [OptionalArgument] FSharpOption<bool> useLabelLengths, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.BlankLabel> blankLabel)
		{
			return new SymbolOperators.CTCLoss(data, label, dataLengths, labelLengths, useDataLengths, useLabelLengths, blankLabel);
		}

		public static NDArray CuDNNBatchNorm(NDArray data, NDArray gamma, NDArray beta, NDArray movingMean, NDArray movingVar, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("CuDNNBatchNorm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409373_002D279(data, gamma, beta, movingMean, movingVar, 0, current));
			string[] parameterKeys = new string[9]
			{
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var",
				"axis",
				"cudnn_off",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[9];
			object obj;
			if (eps == null)
			{
				obj = "0.001";
			}
			else
			{
				FSharpOption<double> val = eps;
				double eps2 = val.get_Value();
				double num = eps2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (momentum == null)
			{
				obj4 = "0.9";
			}
			else
			{
				FSharpOption<double> val2 = momentum;
				double momentum2 = val2.get_Value();
				double num2 = momentum2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (fixGamma == null)
			{
				obj7 = "true";
			}
			else
			{
				FSharpOption<bool> val3 = fixGamma;
				bool fixGamma2 = val3.get_Value();
				bool flag = fixGamma2;
				object obj8 = flag;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useGlobalStats == null)
			{
				obj10 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = useGlobalStats;
				bool useGlobalStats2 = val4.get_Value();
				bool flag2 = useGlobalStats2;
				object obj11 = flag2;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (outputMeanVar == null)
			{
				obj13 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = outputMeanVar;
				bool outputMeanVar2 = val5.get_Value();
				bool flag3 = outputMeanVar2;
				object obj14 = flag3;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			object obj16;
			if (axis == null)
			{
				obj16 = "1";
			}
			else
			{
				FSharpOption<int> val6 = axis;
				int axis2 = val6.get_Value();
				int num3 = axis2;
				object obj17 = num3;
				if (obj17 != null)
				{
					IFormattable formattable11 = obj17 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[5] = (string)obj16;
			object obj19;
			if (cudnnOff == null)
			{
				obj19 = "false";
			}
			else
			{
				FSharpOption<bool> val7 = cudnnOff;
				bool cudnnOff2 = val7.get_Value();
				bool flag4 = cudnnOff2;
				object obj20 = flag4;
				if (obj20 != null)
				{
					IFormattable formattable13 = obj20 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[6] = (string)obj19;
			object obj22;
			if (minCalibRange == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<double> val8 = minCalibRange;
				double minCalibRange2 = val8.get_Value();
				double num4 = minCalibRange2;
				object obj23 = num4;
				if (obj23 != null)
				{
					IFormattable formattable15 = obj23 as IFormattable;
					if (formattable15 != null)
					{
						IFormattable formattable16 = formattable15;
						obj22 = formattable16.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[7] = (string)obj22;
			object obj25;
			if (maxCalibRange == null)
			{
				obj25 = "None";
			}
			else
			{
				FSharpOption<double> val9 = maxCalibRange;
				double maxCalibRange2 = val9.get_Value();
				double num5 = maxCalibRange2;
				object obj26 = num5;
				if (obj26 != null)
				{
					IFormattable formattable17 = obj26 as IFormattable;
					if (formattable17 != null)
					{
						IFormattable formattable18 = formattable17;
						obj25 = formattable18.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj27 = obj26;
						obj25 = obj27.ToString();
					}
				}
				else
				{
					obj25 = "";
				}
			}
			array[8] = (string)obj25;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void CuDNNBatchNorm(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, NDArray beta, NDArray movingMean, NDArray movingVar, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("CuDNNBatchNorm");
			string[] names2 = new string[9]
			{
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var",
				"axis",
				"cudnn_off",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[9];
			object obj;
			if (eps == null)
			{
				obj = "0.001";
			}
			else
			{
				FSharpOption<double> val = eps;
				double eps2 = val.get_Value();
				double num = eps2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (momentum == null)
			{
				obj4 = "0.9";
			}
			else
			{
				FSharpOption<double> val2 = momentum;
				double momentum2 = val2.get_Value();
				double num2 = momentum2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (fixGamma == null)
			{
				obj7 = "true";
			}
			else
			{
				FSharpOption<bool> val3 = fixGamma;
				bool fixGamma2 = val3.get_Value();
				bool flag = fixGamma2;
				object obj8 = flag;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useGlobalStats == null)
			{
				obj10 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = useGlobalStats;
				bool useGlobalStats2 = val4.get_Value();
				bool flag2 = useGlobalStats2;
				object obj11 = flag2;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (outputMeanVar == null)
			{
				obj13 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = outputMeanVar;
				bool outputMeanVar2 = val5.get_Value();
				bool flag3 = outputMeanVar2;
				object obj14 = flag3;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			object obj16;
			if (axis == null)
			{
				obj16 = "1";
			}
			else
			{
				FSharpOption<int> val6 = axis;
				int axis2 = val6.get_Value();
				int num3 = axis2;
				object obj17 = num3;
				if (obj17 != null)
				{
					IFormattable formattable11 = obj17 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[5] = (string)obj16;
			object obj19;
			if (cudnnOff == null)
			{
				obj19 = "false";
			}
			else
			{
				FSharpOption<bool> val7 = cudnnOff;
				bool cudnnOff2 = val7.get_Value();
				bool flag4 = cudnnOff2;
				object obj20 = flag4;
				if (obj20 != null)
				{
					IFormattable formattable13 = obj20 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[6] = (string)obj19;
			object obj22;
			if (minCalibRange == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<double> val8 = minCalibRange;
				double minCalibRange2 = val8.get_Value();
				double num4 = minCalibRange2;
				object obj23 = num4;
				if (obj23 != null)
				{
					IFormattable formattable15 = obj23 as IFormattable;
					if (formattable15 != null)
					{
						IFormattable formattable16 = formattable15;
						obj22 = formattable16.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[7] = (string)obj22;
			object obj25;
			if (maxCalibRange == null)
			{
				obj25 = "None";
			}
			else
			{
				FSharpOption<double> val9 = maxCalibRange;
				double maxCalibRange2 = val9.get_Value();
				double num5 = maxCalibRange2;
				object obj26 = num5;
				if (obj26 != null)
				{
					IFormattable formattable17 = obj26 as IFormattable;
					if (formattable17 != null)
					{
						IFormattable formattable18 = formattable17;
						obj25 = formattable18.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj27 = obj26;
						obj25 = obj27.ToString();
					}
				}
				else
				{
					obj25 = "";
				}
			}
			array[8] = (string)obj25;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.CuDNNBatchNorm_00409411(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409413_002D280(data, gamma, beta, movingMean, movingVar, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00409414_002D281(), outputArray)), names, vals);
		}

		public static SymbolOperators.CuDNNBatchNorm CuDNNBatchNorm([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<Symbol> movingMean, [Optional] [OptionalArgument] FSharpOption<Symbol> movingVar, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			return new SymbolOperators.CuDNNBatchNorm(data, gamma, beta, movingMean, movingVar, eps, momentum, fixGamma, useGlobalStats, outputMeanVar, axis, cudnnOff, minCalibRange, maxCalibRange);
		}

		public static NDArray Deconvolution(NDArray data, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, [Optional] IEnumerable<int> adj, [Optional] IEnumerable<int> targetShape, int numGroup = 1, long workspace = 512L, bool noBias = true, [Optional] GeneratedArgumentTypes.CudnnTune cudnnTune, bool cudnnOff = false, [Optional] GeneratedArgumentTypes.DeconvolutionLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Deconvolution");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409472_002D282(data, weight, bias, 0, current));
			string[] parameterKeys = new string[13]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"adj",
				"target_shape",
				"num_group",
				"workspace",
				"no_bias",
				"cudnn_tune",
				"cudnn_off",
				"layout"
			};
			string[] array = new string[13];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00409474_002D283(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00409474_002D284(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00409474_002D285(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00409474_002D286(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7;
			if ((adj == null) ? true : false)
			{
				obj7 = "[]";
			}
			else
			{
				string text9 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00409474_002D287(), adj));
				FSharpFunc<string, string> val5 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text10 = text9;
				obj7 = val5.Invoke(text10);
			}
			array[5] = (string)obj7;
			object obj8;
			if ((targetShape == null) ? true : false)
			{
				obj8 = "[]";
			}
			else
			{
				string text11 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00409474_002D288(), targetShape));
				FSharpFunc<string, string> val6 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text12 = text11;
				obj8 = val6.Invoke(text12);
			}
			array[6] = (string)obj8;
			object obj9 = numGroup;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable3 = obj9 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj10 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[7] = (string)obj10;
			object obj12 = workspace;
			object obj13;
			if (obj12 != null)
			{
				IFormattable formattable5 = obj12 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj13 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = obj12;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[8] = (string)obj13;
			bool flag = noBias;
			object obj15 = flag;
			object obj16;
			if (obj15 != null)
			{
				IFormattable formattable7 = obj15 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj16 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = obj15;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[9] = (string)obj16;
			object obj18;
			if ((cudnnTune == null) ? true : false)
			{
				obj18 = "None";
			}
			else if (cudnnTune != null)
			{
				IFormattable formattable9 = cudnnTune as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj18 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = cudnnTune;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			array[10] = (string)obj18;
			bool flag2 = cudnnOff;
			object obj20 = flag2;
			object obj21;
			if (obj20 != null)
			{
				IFormattable formattable11 = obj20 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj21 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = obj20;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[11] = (string)obj21;
			object obj23;
			if ((layout == null) ? true : false)
			{
				obj23 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj23 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = layout;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[12] = (string)obj23;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Deconvolution(IEnumerable<NDArray> outputArray, NDArray data, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, [Optional] IEnumerable<int> adj, [Optional] IEnumerable<int> targetShape, int numGroup = 1, long workspace = 512L, bool noBias = true, [Optional] GeneratedArgumentTypes.CudnnTune cudnnTune, bool cudnnOff = false, [Optional] GeneratedArgumentTypes.DeconvolutionLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Deconvolution");
			string[] names2 = new string[13]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"adj",
				"target_shape",
				"num_group",
				"workspace",
				"no_bias",
				"cudnn_tune",
				"cudnn_off",
				"layout"
			};
			string[] array = new string[13];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00409513_002D36(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00409513_002D37(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00409513_002D38(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00409513_002D39(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7;
			if ((adj == null) ? true : false)
			{
				obj7 = "[]";
			}
			else
			{
				string text9 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00409513_002D40(), adj));
				FSharpFunc<string, string> val5 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text10 = text9;
				obj7 = val5.Invoke(text10);
			}
			array[5] = (string)obj7;
			object obj8;
			if ((targetShape == null) ? true : false)
			{
				obj8 = "[]";
			}
			else
			{
				string text11 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00409513_002D41(), targetShape));
				FSharpFunc<string, string> val6 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text12 = text11;
				obj8 = val6.Invoke(text12);
			}
			array[6] = (string)obj8;
			object obj9 = numGroup;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable3 = obj9 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj10 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[7] = (string)obj10;
			object obj12 = workspace;
			object obj13;
			if (obj12 != null)
			{
				IFormattable formattable5 = obj12 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj13 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = obj12;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[8] = (string)obj13;
			bool flag = noBias;
			object obj15 = flag;
			object obj16;
			if (obj15 != null)
			{
				IFormattable formattable7 = obj15 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj16 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = obj15;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[9] = (string)obj16;
			object obj18;
			if ((cudnnTune == null) ? true : false)
			{
				obj18 = "None";
			}
			else if (cudnnTune != null)
			{
				IFormattable formattable9 = cudnnTune as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj18 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = cudnnTune;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			array[10] = (string)obj18;
			bool flag2 = cudnnOff;
			object obj20 = flag2;
			object obj21;
			if (obj20 != null)
			{
				IFormattable formattable11 = obj20 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj21 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = obj20;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[11] = (string)obj21;
			object obj23;
			if ((layout == null) ? true : false)
			{
				obj23 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj23 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = layout;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[12] = (string)obj23;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Deconvolution_00409514(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409516_002D289(data, weight, bias, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00409517_002D290(), outputArray)), names, vals);
		}

		public static SymbolOperators.Deconvolution Deconvolution(Symbol data, Symbol weight, Symbol bias, IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> adj, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.CudnnTune> cudnnTune, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.DeconvolutionLayout> layout)
		{
			return new SymbolOperators.Deconvolution(data, weight, bias, kernel, numFilter, stride, dilate, pad, adj, targetShape, numGroup, workspace, noBias, cudnnTune, cudnnOff, layout);
		}

		public static SymbolOperators.Deconvolution Deconvolution(IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> bias, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> adj, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.CudnnTune> cudnnTune, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.DeconvolutionLayout> layout)
		{
			return new SymbolOperators.Deconvolution(kernel, numFilter, data, weight, bias, stride, dilate, pad, adj, targetShape, numGroup, workspace, noBias, cudnnTune, cudnnOff, layout);
		}

		public static NDArray Dropout(NDArray data, [Optional] [OptionalArgument] FSharpOption<double> p, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.DropoutMode> mode, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Dropout");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409605_002D291(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"p",
				"mode",
				"axes",
				"cudnn_off"
			};
			string[] array = new string[4];
			object obj;
			if (p == null)
			{
				obj = "0.5";
			}
			else
			{
				FSharpOption<double> val = p;
				double p2 = val.get_Value();
				double num = p2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (mode == null)
			{
				obj4 = "training";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.DropoutMode> val2 = mode;
				GeneratedArgumentTypes.DropoutMode mode2 = val2.get_Value();
				GeneratedArgumentTypes.DropoutMode dropoutMode = mode2;
				object obj5 = dropoutMode;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (axes == null)
			{
				obj7 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = axes;
				IEnumerable<int> axes2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_00409607_002D292(), axes2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj7 = val4.Invoke(text2);
			}
			array[2] = (string)obj7;
			object obj8;
			if (cudnnOff == null)
			{
				obj8 = "None";
			}
			else
			{
				FSharpOption<bool> val5 = cudnnOff;
				bool cudnnOff2 = val5.get_Value();
				bool flag = cudnnOff2;
				object obj9 = flag;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Dropout(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<double> p, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.DropoutMode> mode, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Dropout");
			string[] names2 = new string[4]
			{
				"p",
				"mode",
				"axes",
				"cudnn_off"
			};
			string[] array = new string[4];
			object obj;
			if (p == null)
			{
				obj = "0.5";
			}
			else
			{
				FSharpOption<double> val = p;
				double p2 = val.get_Value();
				double num = p2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (mode == null)
			{
				obj4 = "training";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.DropoutMode> val2 = mode;
				GeneratedArgumentTypes.DropoutMode mode2 = val2.get_Value();
				GeneratedArgumentTypes.DropoutMode dropoutMode = mode2;
				object obj5 = dropoutMode;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (axes == null)
			{
				obj7 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = axes;
				IEnumerable<int> axes2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_00409655_002D42(), axes2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj7 = val4.Invoke(text2);
			}
			array[2] = (string)obj7;
			object obj8;
			if (cudnnOff == null)
			{
				obj8 = "None";
			}
			else
			{
				FSharpOption<bool> val5 = cudnnOff;
				bool cudnnOff2 = val5.get_Value();
				bool flag = cudnnOff2;
				object obj9 = flag;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Dropout_00409656(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409658_002D293(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00409659_002D294(), outputArray)), names, vals);
		}

		public static SymbolOperators.Dropout Dropout([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> p, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.DropoutMode> mode, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			return new SymbolOperators.Dropout(data, p, mode, axes, cudnnOff);
		}

		public static NDArray FullyConnected(NDArray data, NDArray weight, NDArray bias, int numHidden, bool noBias = false, bool flatten = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("FullyConnected");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409751_002D295(data, weight, bias, 0, current));
			string[] parameterKeys = new string[3]
			{
				"num_hidden",
				"no_bias",
				"flatten"
			};
			string[] array = new string[3];
			object obj = numHidden;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = noBias;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag2 = flatten;
			object obj7 = flag2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void FullyConnected(IEnumerable<NDArray> outputArray, NDArray data, NDArray weight, NDArray bias, int numHidden, bool noBias = false, bool flatten = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("FullyConnected");
			string[] names2 = new string[3]
			{
				"num_hidden",
				"no_bias",
				"flatten"
			};
			string[] array = new string[3];
			object obj = numHidden;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = noBias;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag2 = flatten;
			object obj7 = flag2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.FullyConnected_00409805(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409807_002D296(data, weight, bias, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00409808_002D297(), outputArray)), names, vals);
		}

		public static SymbolOperators.FullyConnected FullyConnected(Symbol data, Symbol weight, Symbol bias, int numHidden, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<bool> flatten)
		{
			return new SymbolOperators.FullyConnected(data, weight, bias, numHidden, noBias, flatten);
		}

		public static SymbolOperators.FullyConnected FullyConnected(int numHidden, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> bias, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<bool> flatten)
		{
			return new SymbolOperators.FullyConnected(numHidden, data, weight, bias, noBias, flatten);
		}

		public static NDArray[] GroupNorm(NDArray data, NDArray gamma, NDArray beta, int numGroups = 1, double eps = 1E-05, bool outputMeanVar = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("GroupNorm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409926_002D298(data, gamma, beta, 0, current));
			string[] parameterKeys = new string[3]
			{
				"num_groups",
				"eps",
				"output_mean_var"
			};
			string[] array = new string[3];
			object obj = numGroups;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eps;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = outputMeanVar;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.GroupNorm_00409929();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void GroupNorm(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, NDArray beta, int numGroups = 1, double eps = 1E-05, bool outputMeanVar = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("GroupNorm");
			string[] names2 = new string[3]
			{
				"num_groups",
				"eps",
				"output_mean_var"
			};
			string[] array = new string[3];
			object obj = numGroups;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eps;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = outputMeanVar;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.GroupNorm_00409962_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_00409964_002D299(data, gamma, beta, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_00409965_002D300(), outputArray)), names, vals);
		}

		public static SymbolOperators.GroupNorm GroupNorm([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<int> numGroups, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar)
		{
			return new SymbolOperators.GroupNorm(data, gamma, beta, numGroups, eps, outputMeanVar);
		}

		public static NDArray[] LayerNorm(NDArray data, NDArray gamma, NDArray beta, int axis = -1, double eps = 1E-05, bool outputMeanVar = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LayerNorm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010036_002D301(data, gamma, beta, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"eps",
				"output_mean_var"
			};
			string[] array = new string[3];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eps;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = outputMeanVar;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.LayerNorm_004010039();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void LayerNorm(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, NDArray beta, int axis = -1, double eps = 1E-05, bool outputMeanVar = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LayerNorm");
			string[] names2 = new string[3]
			{
				"axis",
				"eps",
				"output_mean_var"
			};
			string[] array = new string[3];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = eps;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = outputMeanVar;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LayerNorm_004010085_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010087_002D302(data, gamma, beta, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004010088_002D303(), outputArray)), names, vals);
		}

		public static SymbolOperators.LayerNorm LayerNorm([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar)
		{
			return new SymbolOperators.LayerNorm(data, gamma, beta, axis, eps, outputMeanVar);
		}

		public static NDArray LogSoftmax(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log_softmax");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010158_002D304(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"axis",
				"temperature",
				"dtype",
				"use_length"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "-1";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (temperature == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = temperature;
				double temperature2 = val2.get_Value();
				double num2 = temperature2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (dtype == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val3 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val3.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj8 = floatDType;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useLength == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<bool> val4 = useLength;
				bool useLength2 = val4.get_Value();
				bool flag = useLength2;
				object obj11 = flag;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LogSoftmax(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log_softmax");
			string[] names2 = new string[4]
			{
				"axis",
				"temperature",
				"dtype",
				"use_length"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "-1";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (temperature == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = temperature;
				double temperature2 = val2.get_Value();
				double num2 = temperature2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (dtype == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val3 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val3.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj8 = floatDType;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useLength == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<bool> val4 = useLength;
				bool useLength2 = val4.get_Value();
				bool flag = useLength2;
				object obj11 = flag;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogSoftmax_004010193(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010195_002D305(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004010196_002D306(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogSoftmax LogSoftmax([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			return new SymbolOperators.LogSoftmax(data, axis, temperature, dtype, useLength);
		}

		public static Tuple<NDArray, NDArray> LRN(NDArray data, int nsize, double alpha = 0.0001, double beta = 0.75, double knorm = 2.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LRN");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010255_002D307(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"nsize",
				"alpha",
				"beta",
				"knorm"
			};
			string[] array = new string[4];
			object obj = nsize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = alpha;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = knorm;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void LRN(IEnumerable<NDArray> outputArray, NDArray data, int nsize, double alpha = 0.0001, double beta = 0.75, double knorm = 2.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LRN");
			string[] names2 = new string[4]
			{
				"nsize",
				"alpha",
				"beta",
				"knorm"
			};
			string[] array = new string[4];
			object obj = nsize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = alpha;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = knorm;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LRN_004010292(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010294_002D308(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004010295_002D309(), outputArray)), names, vals);
		}

		public static SymbolOperators.LRN LRN(Symbol data, int nsize, [Optional] [OptionalArgument] FSharpOption<double> alpha, [Optional] [OptionalArgument] FSharpOption<double> beta, [Optional] [OptionalArgument] FSharpOption<double> knorm)
		{
			return new SymbolOperators.LRN(data, nsize, alpha, beta, knorm);
		}

		public static SymbolOperators.LRN LRN(int nsize, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> alpha, [Optional] [OptionalArgument] FSharpOption<double> beta, [Optional] [OptionalArgument] FSharpOption<double> knorm)
		{
			return new SymbolOperators.LRN(nsize, data, alpha, beta, knorm);
		}

		public static Tuple<NDArray, NDArray> Moments(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("moments");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010379_002D310(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axes",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axes == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axes;
				IEnumerable<int> axes2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004010381_002D311(), axes2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void Moments(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("moments");
			string[] names2 = new string[2]
			{
				"axes",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axes == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axes;
				IEnumerable<int> axes2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004010412_002D43(), axes2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Moments_004010413(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010415_002D312(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004010416_002D313(), outputArray)), names, vals);
		}

		public static SymbolOperators.Moments Moments([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			return new SymbolOperators.Moments(data, axes, keepdims);
		}

		public static NDArray Pooling(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> kernel, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolType> poolType, [Optional] [OptionalArgument] FSharpOption<bool> globalPool, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingConvention> poolingConvention, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> pValue, [Optional] [OptionalArgument] FSharpOption<bool> countIncludePad, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingLayout> layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Pooling");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010526_002D314(data, 0, current));
			string[] parameterKeys = new string[10]
			{
				"kernel",
				"pool_type",
				"global_pool",
				"cudnn_off",
				"pooling_convention",
				"stride",
				"pad",
				"p_value",
				"count_include_pad",
				"layout"
			};
			string[] array = new string[10];
			object obj;
			if (kernel == null)
			{
				obj = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = kernel;
				IEnumerable<int> kernel2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004010528_002D315(), kernel2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (poolType == null)
			{
				obj2 = "max";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolType> val3 = poolType;
				GeneratedArgumentTypes.PoolType poolType2 = val3.get_Value();
				GeneratedArgumentTypes.PoolType poolType3 = poolType2;
				object obj3 = poolType3;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (globalPool == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = globalPool;
				bool globalPool2 = val4.get_Value();
				bool flag = globalPool2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (cudnnOff == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = cudnnOff;
				bool cudnnOff2 = val5.get_Value();
				bool flag2 = cudnnOff2;
				object obj9 = flag2;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			object obj11;
			if (poolingConvention == null)
			{
				obj11 = "valid";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolingConvention> val6 = poolingConvention;
				GeneratedArgumentTypes.PoolingConvention poolingConvention2 = val6.get_Value();
				GeneratedArgumentTypes.PoolingConvention poolingConvention3 = poolingConvention2;
				object obj12 = poolingConvention3;
				if (obj12 != null)
				{
					IFormattable formattable7 = obj12 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj13 = obj12;
						obj11 = obj13.ToString();
					}
				}
				else
				{
					obj11 = "";
				}
			}
			array[4] = (string)obj11;
			object obj14;
			if (stride == null)
			{
				obj14 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val7 = stride;
				IEnumerable<int> stride2 = val7.get_Value();
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004010528_002D316(), stride2));
				FSharpFunc<string, string> val8 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj14 = val8.Invoke(text4);
			}
			array[5] = (string)obj14;
			object obj15;
			if (pad == null)
			{
				obj15 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val9 = pad;
				IEnumerable<int> pad2 = val9.get_Value();
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004010528_002D317(), pad2));
				FSharpFunc<string, string> val10 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj15 = val10.Invoke(text6);
			}
			array[6] = (string)obj15;
			object obj16;
			if (pValue == null)
			{
				obj16 = "None";
			}
			else
			{
				FSharpOption<int> val11 = pValue;
				int pValue2 = val11.get_Value();
				int num = pValue2;
				object obj17 = num;
				if (obj17 != null)
				{
					IFormattable formattable9 = obj17 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[7] = (string)obj16;
			object obj19;
			if (countIncludePad == null)
			{
				obj19 = "None";
			}
			else
			{
				FSharpOption<bool> val12 = countIncludePad;
				bool countIncludePad2 = val12.get_Value();
				bool flag3 = countIncludePad2;
				object obj20 = flag3;
				if (obj20 != null)
				{
					IFormattable formattable11 = obj20 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[8] = (string)obj19;
			object obj22;
			if (layout == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolingLayout> val13 = layout;
				GeneratedArgumentTypes.PoolingLayout layout2 = val13.get_Value();
				GeneratedArgumentTypes.PoolingLayout poolingLayout = layout2;
				object obj23 = poolingLayout;
				if (obj23 != null)
				{
					IFormattable formattable13 = obj23 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj22 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[9] = (string)obj22;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Pooling(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> kernel, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolType> poolType, [Optional] [OptionalArgument] FSharpOption<bool> globalPool, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingConvention> poolingConvention, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> pValue, [Optional] [OptionalArgument] FSharpOption<bool> countIncludePad, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingLayout> layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Pooling");
			string[] names2 = new string[10]
			{
				"kernel",
				"pool_type",
				"global_pool",
				"cudnn_off",
				"pooling_convention",
				"stride",
				"pad",
				"p_value",
				"count_include_pad",
				"layout"
			};
			string[] array = new string[10];
			object obj;
			if (kernel == null)
			{
				obj = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = kernel;
				IEnumerable<int> kernel2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004010609_002D44(), kernel2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (poolType == null)
			{
				obj2 = "max";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolType> val3 = poolType;
				GeneratedArgumentTypes.PoolType poolType2 = val3.get_Value();
				GeneratedArgumentTypes.PoolType poolType3 = poolType2;
				object obj3 = poolType3;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (globalPool == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = globalPool;
				bool globalPool2 = val4.get_Value();
				bool flag = globalPool2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (cudnnOff == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = cudnnOff;
				bool cudnnOff2 = val5.get_Value();
				bool flag2 = cudnnOff2;
				object obj9 = flag2;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			object obj11;
			if (poolingConvention == null)
			{
				obj11 = "valid";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolingConvention> val6 = poolingConvention;
				GeneratedArgumentTypes.PoolingConvention poolingConvention2 = val6.get_Value();
				GeneratedArgumentTypes.PoolingConvention poolingConvention3 = poolingConvention2;
				object obj12 = poolingConvention3;
				if (obj12 != null)
				{
					IFormattable formattable7 = obj12 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj13 = obj12;
						obj11 = obj13.ToString();
					}
				}
				else
				{
					obj11 = "";
				}
			}
			array[4] = (string)obj11;
			object obj14;
			if (stride == null)
			{
				obj14 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val7 = stride;
				IEnumerable<int> stride2 = val7.get_Value();
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004010609_002D45(), stride2));
				FSharpFunc<string, string> val8 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj14 = val8.Invoke(text4);
			}
			array[5] = (string)obj14;
			object obj15;
			if (pad == null)
			{
				obj15 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val9 = pad;
				IEnumerable<int> pad2 = val9.get_Value();
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004010609_002D46(), pad2));
				FSharpFunc<string, string> val10 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj15 = val10.Invoke(text6);
			}
			array[6] = (string)obj15;
			object obj16;
			if (pValue == null)
			{
				obj16 = "None";
			}
			else
			{
				FSharpOption<int> val11 = pValue;
				int pValue2 = val11.get_Value();
				int num = pValue2;
				object obj17 = num;
				if (obj17 != null)
				{
					IFormattable formattable9 = obj17 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[7] = (string)obj16;
			object obj19;
			if (countIncludePad == null)
			{
				obj19 = "None";
			}
			else
			{
				FSharpOption<bool> val12 = countIncludePad;
				bool countIncludePad2 = val12.get_Value();
				bool flag3 = countIncludePad2;
				object obj20 = flag3;
				if (obj20 != null)
				{
					IFormattable formattable11 = obj20 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[8] = (string)obj19;
			object obj22;
			if (layout == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolingLayout> val13 = layout;
				GeneratedArgumentTypes.PoolingLayout layout2 = val13.get_Value();
				GeneratedArgumentTypes.PoolingLayout poolingLayout = layout2;
				object obj23 = poolingLayout;
				if (obj23 != null)
				{
					IFormattable formattable13 = obj23 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj22 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[9] = (string)obj22;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Pooling_004010610(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010612_002D318(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004010613_002D319(), outputArray)), names, vals);
		}

		public static SymbolOperators.Pooling Pooling([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> kernel, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolType> poolType, [Optional] [OptionalArgument] FSharpOption<bool> globalPool, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingConvention> poolingConvention, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> pValue, [Optional] [OptionalArgument] FSharpOption<bool> countIncludePad, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingLayout> layout)
		{
			return new SymbolOperators.Pooling(data, kernel, poolType, globalPool, cudnnOff, poolingConvention, stride, pad, pValue, countIncludePad, layout);
		}

		public static NDArray Softmax(NDArray data, NDArray length, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("softmax");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010724_002D320(data, length, 0, current));
			string[] parameterKeys = new string[4]
			{
				"axis",
				"temperature",
				"dtype",
				"use_length"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "-1";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (temperature == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = temperature;
				double temperature2 = val2.get_Value();
				double num2 = temperature2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (dtype == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val3 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val3.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj8 = floatDType;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useLength == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<bool> val4 = useLength;
				bool useLength2 = val4.get_Value();
				bool flag = useLength2;
				object obj11 = flag;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Softmax(IEnumerable<NDArray> outputArray, NDArray data, NDArray length, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("softmax");
			string[] names2 = new string[4]
			{
				"axis",
				"temperature",
				"dtype",
				"use_length"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "-1";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (temperature == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = temperature;
				double temperature2 = val2.get_Value();
				double num2 = temperature2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (dtype == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val3 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val3.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj8 = floatDType;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useLength == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<bool> val4 = useLength;
				bool useLength2 = val4.get_Value();
				bool flag = useLength2;
				object obj11 = flag;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Softmax_004010770(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010772_002D321(data, length, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004010773_002D322(), outputArray)), names, vals);
		}

		public static SymbolOperators.Softmax Softmax([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> length, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			return new SymbolOperators.Softmax(data, length, axis, temperature, dtype, useLength);
		}

		public static NDArray SoftmaxActivation(NDArray data, [Optional] GeneratedArgumentTypes.SoftmaxActivationMode mode)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SoftmaxActivation");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010843_002D323(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"mode"
			};
			string[] array = new string[1];
			object obj;
			if ((mode == null) ? true : false)
			{
				obj = "instance";
			}
			else if (mode != null)
			{
				IFormattable formattable = mode as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = mode;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SoftmaxActivation(IEnumerable<NDArray> outputArray, NDArray data, [Optional] GeneratedArgumentTypes.SoftmaxActivationMode mode)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SoftmaxActivation");
			string[] names2 = new string[1]
			{
				"mode"
			};
			string[] array = new string[1];
			object obj;
			if ((mode == null) ? true : false)
			{
				obj = "instance";
			}
			else if (mode != null)
			{
				IFormattable formattable = mode as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = mode;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SoftmaxActivation_004010880(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010882_002D324(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004010883_002D325(), outputArray)), names, vals);
		}

		public static SymbolOperators.SoftmaxActivation SoftmaxActivation([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.SoftmaxActivationMode> mode)
		{
			return new SymbolOperators.SoftmaxActivation(data, mode);
		}

		public static NDArray Softmin(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("softmin");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004010957_002D326(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"axis",
				"temperature",
				"dtype",
				"use_length"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "-1";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (temperature == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = temperature;
				double temperature2 = val2.get_Value();
				double num2 = temperature2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (dtype == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val3 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val3.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj8 = floatDType;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useLength == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<bool> val4 = useLength;
				bool useLength2 = val4.get_Value();
				bool flag = useLength2;
				object obj11 = flag;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Softmin(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("softmin");
			string[] names2 = new string[4]
			{
				"axis",
				"temperature",
				"dtype",
				"use_length"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "-1";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (temperature == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = temperature;
				double temperature2 = val2.get_Value();
				double num2 = temperature2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (dtype == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val3 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val3.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj8 = floatDType;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useLength == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<bool> val4 = useLength;
				bool useLength2 = val4.get_Value();
				bool flag = useLength2;
				object obj11 = flag;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Softmin_004011002(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011004_002D327(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011005_002D328(), outputArray)), names, vals);
		}

		public static SymbolOperators.Softmin Softmin([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<double> temperature, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> useLength)
		{
			return new SymbolOperators.Softmin(data, axis, temperature, dtype, useLength);
		}

		public static NDArray UpSampling(params NDArray[] data, int scale, GeneratedArgumentTypes.SampleType sampleType, int numFilter = 0, [Optional] GeneratedArgumentTypes.MultiInputMode multiInputMode, long workspace = 512L)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("UpSampling");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004011111_002D329();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[6]
			{
				"scale",
				"sample_type",
				"num_args",
				"num_filter",
				"multi_input_mode",
				"workspace"
			};
			string[] array2 = new string[6];
			object obj = scale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4;
			if (sampleType != null)
			{
				IFormattable formattable3 = sampleType as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = sampleType;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array2[1] = (string)obj4;
			int num = data.Length;
			object obj6 = num;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array2[2] = (string)obj7;
			object obj9 = numFilter;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array2[3] = (string)obj10;
			object obj12;
			if ((multiInputMode == null) ? true : false)
			{
				obj12 = "concat";
			}
			else if (multiInputMode != null)
			{
				IFormattable formattable9 = multiInputMode as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = multiInputMode;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array2[4] = (string)obj12;
			object obj14 = workspace;
			object obj15;
			if (obj14 != null)
			{
				IFormattable formattable11 = obj14 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = obj14;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array2[5] = (string)obj15;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			return new NDArray(outputs[0]);
		}

		public static void UpSampling(IEnumerable<NDArray> outputArray, params NDArray[] data, int scale, GeneratedArgumentTypes.SampleType sampleType, int numFilter = 0, [Optional] GeneratedArgumentTypes.MultiInputMode multiInputMode, long workspace = 512L)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("UpSampling");
			string[] names2 = new string[6]
			{
				"scale",
				"sample_type",
				"num_args",
				"num_filter",
				"multi_input_mode",
				"workspace"
			};
			string[] array = new string[6];
			object obj = scale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (sampleType != null)
			{
				IFormattable formattable3 = sampleType as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = sampleType;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			int num = data.Length;
			object obj6 = num;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9 = numFilter;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			object obj12;
			if ((multiInputMode == null) ? true : false)
			{
				obj12 = "concat";
			}
			else if (multiInputMode != null)
			{
				IFormattable formattable9 = multiInputMode as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = multiInputMode;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			object obj14 = workspace;
			object obj15;
			if (obj14 != null)
			{
				IFormattable formattable11 = obj14 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = obj14;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array[5] = (string)obj15;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.UpSampling_004011185(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004011187_002D330();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011188_002D331(), outputArray)), names, vals);
		}

		public static SymbolOperators.UpSampling UpSampling(IEnumerable<Symbol> data, int scale, GeneratedArgumentTypes.SampleType sampleType, [Optional] [OptionalArgument] FSharpOption<int> numFilter, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.MultiInputMode> multiInputMode, [Optional] [OptionalArgument] FSharpOption<long> workspace)
		{
			return new SymbolOperators.UpSampling(data, scale, sampleType, numFilter, multiInputMode, workspace);
		}

		public static SymbolOperators.UpSampling UpSampling(int scale, GeneratedArgumentTypes.SampleType sampleType, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> numFilter, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.MultiInputMode> multiInputMode, [Optional] [OptionalArgument] FSharpOption<long> workspace)
		{
			return new SymbolOperators.UpSampling(scale, sampleType, data, numFilter, multiInputMode, workspace);
		}

		public static NDArray[] NpiSvd(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_svd");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011321_002D332(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiSvd_004011324();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiSvd(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_svd");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004011332_002D27();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004011333_002D47();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiSvd_004011334_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011336_002D333(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011337_002D334(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiSvd NpiSvd([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.NpiSvd(A);
		}

		public static NDArray[] NpiCholesky(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_cholesky");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011356_002D335(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiCholesky_004011359();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiCholesky(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_cholesky");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004011367_002D28();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004011368_002D48();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiCholesky_004011369_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011371_002D336(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011372_002D337(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiCholesky NpiCholesky([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.NpiCholesky(A);
		}

		public static NDArray[] NpiBooleanMaskAssignScalar(NDArray data, NDArray mask, double value)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_boolean_mask_assign_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011392_002D338(data, mask, 0, current));
			string[] parameterKeys = new string[1]
			{
				"value"
			};
			string[] array = new string[1];
			object obj = value;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiBooleanMaskAssignScalar_004011395();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiBooleanMaskAssignScalar(IEnumerable<NDArray> outputArray, NDArray data, NDArray mask, double value)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_boolean_mask_assign_scalar");
			string[] names2 = new string[1]
			{
				"value"
			};
			string[] array = new string[1];
			object obj = value;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBooleanMaskAssignScalar_004011407_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011409_002D339(data, mask, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011410_002D340(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBooleanMaskAssignScalar NpiBooleanMaskAssignScalar(Symbol data, Symbol mask, double value)
		{
			return new SymbolOperators.NpiBooleanMaskAssignScalar(data, mask, value);
		}

		public static SymbolOperators.NpiBooleanMaskAssignScalar NpiBooleanMaskAssignScalar(double value, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> mask)
		{
			return new SymbolOperators.NpiBooleanMaskAssignScalar(value, data, mask);
		}

		public static NDArray[] NpiBooleanMaskAssignTensor(NDArray data, NDArray mask, NDArray value)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_boolean_mask_assign_tensor");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011440_002D341(data, mask, value, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiBooleanMaskAssignTensor_004011443();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiBooleanMaskAssignTensor(IEnumerable<NDArray> outputArray, NDArray data, NDArray mask, NDArray value)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_boolean_mask_assign_tensor");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004011453_002D29();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004011454_002D49();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBooleanMaskAssignTensor_004011455_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011457_002D342(data, mask, value, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011458_002D343(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBooleanMaskAssignTensor NpiBooleanMaskAssignTensor([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> mask, [Optional] [OptionalArgument] FSharpOption<Symbol> value)
		{
			return new SymbolOperators.NpiBooleanMaskAssignTensor(data, mask, value);
		}

		public static NDArray NpiArgmax(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_argmax");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011477_002D344(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axis",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiArgmax(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_argmax");
			string[] names2 = new string[2]
			{
				"axis",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArgmax_004011489(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011491_002D345(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011492_002D346(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArgmax NpiArgmax([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			return new SymbolOperators.NpiArgmax(data, axis, keepdims);
		}

		public static NDArray[] NpiArgmin(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_argmin");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011508_002D347(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axis",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val3 = new _0024Operators.NpiArgmin_004011511();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val3.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiArgmin(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_argmin");
			string[] names2 = new string[2]
			{
				"axis",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArgmin_004011520_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011522_002D348(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011523_002D349(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArgmin NpiArgmin([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			return new SymbolOperators.NpiArgmin(data, axis, keepdims);
		}

		public static NDArray NpSum(NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_sum");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011548_002D350(a, 0, current));
			string[] parameterKeys = new string[4]
			{
				"axis",
				"dtype",
				"keepdims",
				"initial"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004011550_002D351(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (keepdims == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = keepdims;
				bool keepdims2 = val4.get_Value();
				bool flag = keepdims2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (initial == null)
			{
				obj8 = "None";
			}
			else
			{
				FSharpOption<double> val5 = initial;
				double initial2 = val5.get_Value();
				double num = initial2;
				object obj9 = num;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpSum(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_sum");
			string[] names2 = new string[4]
			{
				"axis",
				"dtype",
				"keepdims",
				"initial"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004011569_002D50(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (keepdims == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = keepdims;
				bool keepdims2 = val4.get_Value();
				bool flag = keepdims2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (initial == null)
			{
				obj8 = "None";
			}
			else
			{
				FSharpOption<double> val5 = initial;
				double initial2 = val5.get_Value();
				double num = initial2;
				object obj9 = num;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpSum_004011570(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011572_002D352(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011573_002D353(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpSum NpSum([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			return new SymbolOperators.NpSum(a, axis, dtype, keepdims, initial);
		}

		public static NDArray NpMax(NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_max");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011599_002D354(a, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"initial"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004011601_002D355(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (initial == null)
			{
				obj5 = "None";
			}
			else
			{
				FSharpOption<double> val4 = initial;
				double initial2 = val4.get_Value();
				double num = initial2;
				object obj6 = num;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpMax(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_max");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"initial"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004011614_002D51(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (initial == null)
			{
				obj5 = "None";
			}
			else
			{
				FSharpOption<double> val4 = initial;
				double initial2 = val4.get_Value();
				double num = initial2;
				object obj6 = num;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpMax_004011615(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011617_002D356(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011618_002D357(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpMax NpMax([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			return new SymbolOperators.NpMax(a, axis, keepdims, initial);
		}

		public static NDArray NpMin(NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_min");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011643_002D358(a, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"initial"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004011645_002D359(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (initial == null)
			{
				obj5 = "None";
			}
			else
			{
				FSharpOption<double> val4 = initial;
				double initial2 = val4.get_Value();
				double num = initial2;
				object obj6 = num;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpMin(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_min");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"initial"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004011658_002D52(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (initial == null)
			{
				obj5 = "None";
			}
			else
			{
				FSharpOption<double> val4 = initial;
				double initial2 = val4.get_Value();
				double num = initial2;
				object obj6 = num;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpMin_004011659(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011661_002D360(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011662_002D361(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpMin NpMin([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			return new SymbolOperators.NpMin(a, axis, keepdims, initial);
		}

		public static NDArray NpProd(NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_prod");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011689_002D362(a, 0, current));
			string[] parameterKeys = new string[4]
			{
				"axis",
				"dtype",
				"keepdims",
				"initial"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004011691_002D363(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (keepdims == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = keepdims;
				bool keepdims2 = val4.get_Value();
				bool flag = keepdims2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (initial == null)
			{
				obj8 = "None";
			}
			else
			{
				FSharpOption<double> val5 = initial;
				double initial2 = val5.get_Value();
				double num = initial2;
				object obj9 = num;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpProd(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_prod");
			string[] names2 = new string[4]
			{
				"axis",
				"dtype",
				"keepdims",
				"initial"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004011707_002D53(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (keepdims == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = keepdims;
				bool keepdims2 = val4.get_Value();
				bool flag = keepdims2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (initial == null)
			{
				obj8 = "None";
			}
			else
			{
				FSharpOption<double> val5 = initial;
				double initial2 = val5.get_Value();
				double num = initial2;
				object obj9 = num;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpProd_004011708(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011710_002D364(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011711_002D365(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpProd NpProd([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			return new SymbolOperators.NpProd(a, axis, dtype, keepdims, initial);
		}

		public static NDArray NpiMean(NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_mean");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011736_002D366(a, 0, current));
			string[] parameterKeys = new string[4]
			{
				"axis",
				"dtype",
				"keepdims",
				"initial"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004011738_002D367(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (keepdims == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = keepdims;
				bool keepdims2 = val4.get_Value();
				bool flag = keepdims2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (initial == null)
			{
				obj8 = "None";
			}
			else
			{
				FSharpOption<double> val5 = initial;
				double initial2 = val5.get_Value();
				double num = initial2;
				object obj9 = num;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiMean(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_mean");
			string[] names2 = new string[4]
			{
				"axis",
				"dtype",
				"keepdims",
				"initial"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004011754_002D54(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (keepdims == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = keepdims;
				bool keepdims2 = val4.get_Value();
				bool flag = keepdims2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (initial == null)
			{
				obj8 = "None";
			}
			else
			{
				FSharpOption<double> val5 = initial;
				double initial2 = val5.get_Value();
				double num = initial2;
				object obj9 = num;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiMean_004011755(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011757_002D368(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011758_002D369(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiMean NpiMean([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<double> initial)
		{
			return new SymbolOperators.NpiMean(a, axis, dtype, keepdims, initial);
		}

		public static NDArray NpiStd(NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<int> ddof, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_std");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011783_002D370(a, 0, current));
			string[] parameterKeys = new string[4]
			{
				"axis",
				"dtype",
				"ddof",
				"keepdims"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004011785_002D371(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (ddof == null)
			{
				obj5 = "0";
			}
			else
			{
				FSharpOption<int> val4 = ddof;
				int ddof2 = val4.get_Value();
				int num = ddof2;
				object obj6 = num;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (keepdims == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = keepdims;
				bool keepdims2 = val5.get_Value();
				bool flag = keepdims2;
				object obj9 = flag;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiStd(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<int> ddof, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_std");
			string[] names2 = new string[4]
			{
				"axis",
				"dtype",
				"ddof",
				"keepdims"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004011801_002D55(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (ddof == null)
			{
				obj5 = "0";
			}
			else
			{
				FSharpOption<int> val4 = ddof;
				int ddof2 = val4.get_Value();
				int num = ddof2;
				object obj6 = num;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (keepdims == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = keepdims;
				bool keepdims2 = val5.get_Value();
				bool flag = keepdims2;
				object obj9 = flag;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiStd_004011802(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011804_002D372(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011805_002D373(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiStd NpiStd([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<int> ddof, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			return new SymbolOperators.NpiStd(a, axis, dtype, ddof, keepdims);
		}

		public static NDArray NpiVar(NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<int> ddof, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_var");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011829_002D374(a, 0, current));
			string[] parameterKeys = new string[4]
			{
				"axis",
				"dtype",
				"ddof",
				"keepdims"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004011831_002D375(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (ddof == null)
			{
				obj5 = "0";
			}
			else
			{
				FSharpOption<int> val4 = ddof;
				int ddof2 = val4.get_Value();
				int num = ddof2;
				object obj6 = num;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (keepdims == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = keepdims;
				bool keepdims2 = val5.get_Value();
				bool flag = keepdims2;
				object obj9 = flag;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiVar(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<int> ddof, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_var");
			string[] names2 = new string[4]
			{
				"axis",
				"dtype",
				"ddof",
				"keepdims"
			};
			string[] array = new string[4];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004011847_002D56(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (dtype == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj3 = dataType;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (ddof == null)
			{
				obj5 = "0";
			}
			else
			{
				FSharpOption<int> val4 = ddof;
				int ddof2 = val4.get_Value();
				int num = ddof2;
				object obj6 = num;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (keepdims == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = keepdims;
				bool keepdims2 = val5.get_Value();
				bool flag = keepdims2;
				object obj9 = flag;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiVar_004011848(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011850_002D376(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011851_002D377(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiVar NpiVar([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<int> ddof, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			return new SymbolOperators.NpiVar(a, axis, dtype, ddof, keepdims);
		}

		public static NDArray NpBroadcastTo(NDArray array, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_broadcast_to");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011868_002D378(array, 0, current));
			string[] parameterKeys = new string[1]
			{
				"shape"
			};
			string[] array2 = new string[1];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004011870_002D379(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array2[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array2);
			return new NDArray(outputs[0]);
		}

		public static void NpBroadcastTo(IEnumerable<NDArray> outputArray, NDArray array, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_broadcast_to");
			string[] names2 = new string[1]
			{
				"shape"
			};
			string[] array2 = new string[1];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004011878_002D57(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array2[0] = (string)obj;
			string[] vals2 = array2;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpBroadcastTo_004011879(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011881_002D380(array, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011882_002D381(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpBroadcastTo NpBroadcastTo([Optional] [OptionalArgument] FSharpOption<Symbol> array, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape)
		{
			return new SymbolOperators.NpBroadcastTo(array, shape);
		}

		public static NDArray NpCumsum(NDArray a, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_cumsum");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011901_002D382(a, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axis",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (dtype == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<DataType> val2 = dtype;
				DataType dtype2 = val2.get_Value();
				DataType dataType = dtype2;
				object obj5 = dataType;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpCumsum(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_cumsum");
			string[] names2 = new string[2]
			{
				"axis",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (dtype == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<DataType> val2 = dtype;
				DataType dtype2 = val2.get_Value();
				DataType dataType = dtype2;
				object obj5 = dataType;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpCumsum_004011916(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011918_002D383(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011919_002D384(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpCumsum NpCumsum([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpCumsum(a, axis, dtype);
		}

		public static NDArray[] NpiDiff(NDArray a, int n = 1, int axis = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_diff");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011939_002D385(a, 0, current));
			string[] parameterKeys = new string[2]
			{
				"n",
				"axis"
			};
			string[] array = new string[2];
			object obj = n;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiDiff_004011942();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiDiff(IEnumerable<NDArray> outputArray, NDArray a, int n = 1, int axis = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_diff");
			string[] names2 = new string[2]
			{
				"n",
				"axis"
			};
			string[] array = new string[2];
			object obj = n;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiDiff_004011951_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011953_002D386(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004011954_002D387(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiDiff NpiDiff([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<int> n, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.NpiDiff(a, n, axis);
		}

		public static NDArray NpDot(NDArray a, NDArray b)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_dot");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004011989_002D388(a, b, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpDot(IEnumerable<NDArray> outputArray, NDArray a, NDArray b)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_dot");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012017_002D30();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012018_002D58();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpDot_004012019(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012021_002D389(a, b, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012022_002D390(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpDot NpDot([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<Symbol> b)
		{
			return new SymbolOperators.NpDot(a, b);
		}

		public static NDArray[] NpiEinsum(params NDArray[] data, string subscripts = "", int optimize = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_einsum");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004012061_002D391();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[3]
			{
				"num_args",
				"subscripts",
				"optimize"
			};
			string[] array2 = new string[3];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			array2[1] = subscripts;
			object obj4 = optimize;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.NpiEinsum_004012064();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void NpiEinsum(IEnumerable<NDArray> outputArray, params NDArray[] data, string subscripts = "", int optimize = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_einsum");
			string[] names2 = new string[3]
			{
				"num_args",
				"subscripts",
				"optimize"
			};
			string[] array = new string[3];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			array[1] = subscripts;
			object obj4 = optimize;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiEinsum_004012077_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004012079_002D392();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012080_002D393(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiEinsum NpiEinsum([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<string> subscripts, [Optional] [OptionalArgument] FSharpOption<int> optimize)
		{
			return new SymbolOperators.NpiEinsum(data, subscripts, optimize);
		}

		public static NDArray[] NpiEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012099_002D394(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiEqual_004012102();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012108_002D31();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012109_002D59();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiEqual_004012110_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012112_002D395(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012113_002D396(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiEqual NpiEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiEqual(lhs, rhs);
		}

		public static NDArray[] NpiNotEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_not_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012127_002D397(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiNotEqual_004012130();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiNotEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_not_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012136_002D32();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012137_002D60();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiNotEqual_004012138_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012140_002D398(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012141_002D399(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiNotEqual NpiNotEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiNotEqual(lhs, rhs);
		}

		public static NDArray[] NpiGreater(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_greater");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012155_002D400(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiGreater_004012158();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiGreater(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_greater");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012164_002D33();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012165_002D61();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiGreater_004012166_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012168_002D401(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012169_002D402(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiGreater NpiGreater([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiGreater(lhs, rhs);
		}

		public static NDArray[] NpiLess(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_less");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012183_002D403(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiLess_004012186();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiLess(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_less");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012192_002D34();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012193_002D62();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLess_004012194_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012196_002D404(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012197_002D405(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLess NpiLess([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiLess(lhs, rhs);
		}

		public static NDArray[] NpiGreaterEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_greater_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012211_002D406(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiGreaterEqual_004012214();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiGreaterEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_greater_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012220_002D35();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012221_002D63();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiGreaterEqual_004012222_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012224_002D407(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012225_002D408(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiGreaterEqual NpiGreaterEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiGreaterEqual(lhs, rhs);
		}

		public static NDArray[] NpiLessEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_less_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012239_002D409(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiLessEqual_004012242();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiLessEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_less_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012248_002D36();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012249_002D64();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLessEqual_004012250_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012252_002D410(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012253_002D411(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLessEqual NpiLessEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiLessEqual(lhs, rhs);
		}

		public static NDArray[] NpiEqualScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_equal_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012267_002D412(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiEqualScalar_004012270();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiEqualScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_equal_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiEqualScalar_004012278_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012280_002D413(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012281_002D414(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiEqualScalar NpiEqualScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiEqualScalar(data, scalar);
		}

		public static SymbolOperators.NpiEqualScalar NpiEqualScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiEqualScalar(scalar, data);
		}

		public static NDArray[] NpiNotEqualScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_not_equal_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012299_002D415(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiNotEqualScalar_004012302();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiNotEqualScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_not_equal_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiNotEqualScalar_004012310_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012312_002D416(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012313_002D417(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiNotEqualScalar NpiNotEqualScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiNotEqualScalar(data, scalar);
		}

		public static SymbolOperators.NpiNotEqualScalar NpiNotEqualScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiNotEqualScalar(scalar, data);
		}

		public static NDArray[] NpiGreaterScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_greater_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012331_002D418(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiGreaterScalar_004012334();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiGreaterScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_greater_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiGreaterScalar_004012342_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012344_002D419(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012345_002D420(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiGreaterScalar NpiGreaterScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiGreaterScalar(data, scalar);
		}

		public static SymbolOperators.NpiGreaterScalar NpiGreaterScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiGreaterScalar(scalar, data);
		}

		public static NDArray[] NpiLessScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_less_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012363_002D421(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiLessScalar_004012366();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiLessScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_less_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLessScalar_004012374_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012376_002D422(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012377_002D423(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLessScalar NpiLessScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiLessScalar(data, scalar);
		}

		public static SymbolOperators.NpiLessScalar NpiLessScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiLessScalar(scalar, data);
		}

		public static NDArray[] NpiGreaterEqualScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_greater_equal_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012395_002D424(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiGreaterEqualScalar_004012398();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiGreaterEqualScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_greater_equal_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiGreaterEqualScalar_004012406_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012408_002D425(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012409_002D426(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiGreaterEqualScalar NpiGreaterEqualScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiGreaterEqualScalar(data, scalar);
		}

		public static SymbolOperators.NpiGreaterEqualScalar NpiGreaterEqualScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiGreaterEqualScalar(scalar, data);
		}

		public static NDArray[] NpiLessEqualScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_less_equal_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012427_002D427(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiLessEqualScalar_004012430();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiLessEqualScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_less_equal_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLessEqualScalar_004012438_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012440_002D428(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012441_002D429(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLessEqualScalar NpiLessEqualScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiLessEqualScalar(data, scalar);
		}

		public static SymbolOperators.NpiLessEqualScalar NpiLessEqualScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiLessEqualScalar(scalar, data);
		}

		public static NDArray NpiAdd(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_add");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012459_002D430(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiAdd(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_add");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012468_002D37();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012469_002D65();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiAdd_004012470(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012472_002D431(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012473_002D432(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiAdd NpiAdd([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiAdd(lhs, rhs);
		}

		public static NDArray NpiSubtract(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_subtract");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012487_002D433(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiSubtract(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_subtract");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012496_002D38();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012497_002D66();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiSubtract_004012498(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012500_002D434(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012501_002D435(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiSubtract NpiSubtract([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiSubtract(lhs, rhs);
		}

		public static NDArray NpiMultiply(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_multiply");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012515_002D436(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiMultiply(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_multiply");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012524_002D39();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012525_002D67();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiMultiply_004012526(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012528_002D437(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012529_002D438(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiMultiply NpiMultiply([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiMultiply(lhs, rhs);
		}

		public static NDArray NpiMod(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_mod");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012544_002D439(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiMod(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_mod");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012553_002D40();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012554_002D68();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiMod_004012555(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012557_002D440(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012558_002D441(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiMod NpiMod([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiMod(lhs, rhs);
		}

		public static NDArray NpiPower(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_power");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012572_002D442(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiPower(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_power");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012581_002D41();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012582_002D69();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiPower_004012583(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012585_002D443(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012586_002D444(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiPower NpiPower([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiPower(lhs, rhs);
		}

		public static NDArray NpiAddScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_add_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012600_002D445(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiAddScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_add_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiAddScalar_004012611(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012613_002D446(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012614_002D447(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiAddScalar NpiAddScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiAddScalar(data, scalar);
		}

		public static SymbolOperators.NpiAddScalar NpiAddScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiAddScalar(scalar, data);
		}

		public static NDArray NpiSubtractScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_subtract_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012632_002D448(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiSubtractScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_subtract_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiSubtractScalar_004012643(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012645_002D449(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012646_002D450(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiSubtractScalar NpiSubtractScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiSubtractScalar(data, scalar);
		}

		public static SymbolOperators.NpiSubtractScalar NpiSubtractScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiSubtractScalar(scalar, data);
		}

		public static NDArray NpiRsubtractScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rsubtract_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012664_002D451(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiRsubtractScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rsubtract_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRsubtractScalar_004012675(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012677_002D452(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012678_002D453(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRsubtractScalar NpiRsubtractScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiRsubtractScalar(data, scalar);
		}

		public static SymbolOperators.NpiRsubtractScalar NpiRsubtractScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiRsubtractScalar(scalar, data);
		}

		public static NDArray NpiMultiplyScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_multiply_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012696_002D454(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiMultiplyScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_multiply_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiMultiplyScalar_004012707(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012709_002D455(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012710_002D456(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiMultiplyScalar NpiMultiplyScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiMultiplyScalar(data, scalar);
		}

		public static SymbolOperators.NpiMultiplyScalar NpiMultiplyScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiMultiplyScalar(scalar, data);
		}

		public static NDArray NpiModScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_mod_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012728_002D457(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiModScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_mod_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiModScalar_004012739(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012741_002D458(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012742_002D459(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiModScalar NpiModScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiModScalar(data, scalar);
		}

		public static SymbolOperators.NpiModScalar NpiModScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiModScalar(scalar, data);
		}

		public static NDArray NpiRmodScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rmod_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012760_002D460(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiRmodScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rmod_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRmodScalar_004012771(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012773_002D461(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012774_002D462(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRmodScalar NpiRmodScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiRmodScalar(data, scalar);
		}

		public static SymbolOperators.NpiRmodScalar NpiRmodScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiRmodScalar(scalar, data);
		}

		public static NDArray NpiPowerScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_power_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012792_002D463(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiPowerScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_power_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiPowerScalar_004012803(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012805_002D464(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012806_002D465(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiPowerScalar NpiPowerScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiPowerScalar(data, scalar);
		}

		public static SymbolOperators.NpiPowerScalar NpiPowerScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiPowerScalar(scalar, data);
		}

		public static NDArray NpiRpowerScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rpower_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012824_002D466(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiRpowerScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rpower_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRpowerScalar_004012835(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012837_002D467(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012838_002D468(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRpowerScalar NpiRpowerScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiRpowerScalar(data, scalar);
		}

		public static SymbolOperators.NpiRpowerScalar NpiRpowerScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiRpowerScalar(scalar, data);
		}

		public static NDArray NpiCopysign(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_copysign");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012859_002D469(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiCopysign(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_copysign");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012871_002D42();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012872_002D70();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiCopysign_004012873(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012875_002D470(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012876_002D471(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiCopysign NpiCopysign([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiCopysign(lhs, rhs);
		}

		public static NDArray NpiLcm(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_lcm");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012894_002D472(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiLcm(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_lcm");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012903_002D43();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012904_002D71();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLcm_004012905(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012907_002D473(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012908_002D474(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLcm NpiLcm([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiLcm(lhs, rhs);
		}

		public static NDArray NpiLcmScalar(NDArray data, int scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_lcm_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012922_002D475(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiLcmScalar(IEnumerable<NDArray> outputArray, NDArray data, int scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_lcm_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLcmScalar_004012933(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012935_002D476(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012936_002D477(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLcmScalar NpiLcmScalar(Symbol data, int scalar)
		{
			return new SymbolOperators.NpiLcmScalar(data, scalar);
		}

		public static SymbolOperators.NpiLcmScalar NpiLcmScalar(int scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiLcmScalar(scalar, data);
		}

		public static NDArray[] NpiBitwiseXor(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bitwise_xor");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012954_002D478(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiBitwiseXor_004012957();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiBitwiseXor(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bitwise_xor");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012963_002D44();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012964_002D72();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBitwiseXor_004012965_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012967_002D479(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012968_002D480(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBitwiseXor NpiBitwiseXor([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiBitwiseXor(lhs, rhs);
		}

		public static NDArray[] NpiBitwiseOr(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bitwise_or");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012982_002D481(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiBitwiseOr_004012985();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiBitwiseOr(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bitwise_or");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004012991_002D45();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004012992_002D73();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBitwiseOr_004012993_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004012995_002D482(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004012996_002D483(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBitwiseOr NpiBitwiseOr([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiBitwiseOr(lhs, rhs);
		}

		public static NDArray[] NpiBitwiseXorScalar(NDArray data, int scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bitwise_xor_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013010_002D484(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiBitwiseXorScalar_004013013();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiBitwiseXorScalar(IEnumerable<NDArray> outputArray, NDArray data, int scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bitwise_xor_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBitwiseXorScalar_004013021_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013023_002D485(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013024_002D486(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBitwiseXorScalar NpiBitwiseXorScalar(Symbol data, int scalar)
		{
			return new SymbolOperators.NpiBitwiseXorScalar(data, scalar);
		}

		public static SymbolOperators.NpiBitwiseXorScalar NpiBitwiseXorScalar(int scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiBitwiseXorScalar(scalar, data);
		}

		public static NDArray[] NpiBitwiseOrScalar(NDArray data, int scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bitwise_or_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013042_002D487(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiBitwiseOrScalar_004013045();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiBitwiseOrScalar(IEnumerable<NDArray> outputArray, NDArray data, int scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bitwise_or_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBitwiseOrScalar_004013053_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013055_002D488(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013056_002D489(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBitwiseOrScalar NpiBitwiseOrScalar(Symbol data, int scalar)
		{
			return new SymbolOperators.NpiBitwiseOrScalar(data, scalar);
		}

		public static SymbolOperators.NpiBitwiseOrScalar NpiBitwiseOrScalar(int scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiBitwiseOrScalar(scalar, data);
		}

		public static NDArray NpiCopysignScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_copysign_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013074_002D490(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiCopysignScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_copysign_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiCopysignScalar_004013085(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013087_002D491(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013088_002D492(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiCopysignScalar NpiCopysignScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiCopysignScalar(data, scalar);
		}

		public static SymbolOperators.NpiCopysignScalar NpiCopysignScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiCopysignScalar(scalar, data);
		}

		public static NDArray NpiRcopysignScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rcopysign_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013106_002D493(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiRcopysignScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rcopysign_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRcopysignScalar_004013117(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013119_002D494(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013120_002D495(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRcopysignScalar NpiRcopysignScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiRcopysignScalar(data, scalar);
		}

		public static SymbolOperators.NpiRcopysignScalar NpiRcopysignScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiRcopysignScalar(scalar, data);
		}

		public static NDArray NpiArctan2(NDArray x1, NDArray x2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arctan2");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013140_002D496(x1, x2, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiArctan2(IEnumerable<NDArray> outputArray, NDArray x1, NDArray x2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arctan2");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013149_002D46();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013150_002D74();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArctan2_004013151(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013153_002D497(x1, x2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013154_002D498(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArctan2 NpiArctan2([Optional] [OptionalArgument] FSharpOption<Symbol> x1, [Optional] [OptionalArgument] FSharpOption<Symbol> x2)
		{
			return new SymbolOperators.NpiArctan2(x1, x2);
		}

		public static NDArray NpiArctan2Scalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arctan2_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013169_002D499(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiArctan2Scalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arctan2_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArctan2Scalar_004013180(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013182_002D500(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013183_002D501(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArctan2Scalar NpiArctan2Scalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiArctan2Scalar(data, scalar);
		}

		public static SymbolOperators.NpiArctan2Scalar NpiArctan2Scalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiArctan2Scalar(scalar, data);
		}

		public static NDArray NpiRarctan2Scalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rarctan2_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013201_002D502(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiRarctan2Scalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rarctan2_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRarctan2Scalar_004013212(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013214_002D503(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013215_002D504(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRarctan2Scalar NpiRarctan2Scalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiRarctan2Scalar(data, scalar);
		}

		public static SymbolOperators.NpiRarctan2Scalar NpiRarctan2Scalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiRarctan2Scalar(scalar, data);
		}

		public static NDArray NpiHypot(NDArray x1, NDArray x2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hypot");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013235_002D505(x1, x2, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiHypot(IEnumerable<NDArray> outputArray, NDArray x1, NDArray x2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hypot");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013244_002D47();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013245_002D75();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiHypot_004013246(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013248_002D506(x1, x2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013249_002D507(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiHypot NpiHypot([Optional] [OptionalArgument] FSharpOption<Symbol> x1, [Optional] [OptionalArgument] FSharpOption<Symbol> x2)
		{
			return new SymbolOperators.NpiHypot(x1, x2);
		}

		public static NDArray[] NpiLdexp(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_ldexp");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013264_002D508(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiLdexp_004013267();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiLdexp(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_ldexp");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013273_002D48();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013274_002D76();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLdexp_004013275_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013277_002D509(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013278_002D510(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLdexp NpiLdexp([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiLdexp(lhs, rhs);
		}

		public static NDArray[] NpiLdexpScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_ldexp_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013292_002D511(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiLdexpScalar_004013295();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiLdexpScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_ldexp_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLdexpScalar_004013303_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013305_002D512(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013306_002D513(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLdexpScalar NpiLdexpScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiLdexpScalar(data, scalar);
		}

		public static SymbolOperators.NpiLdexpScalar NpiLdexpScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiLdexpScalar(scalar, data);
		}

		public static NDArray[] NpiRldexpScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rldexp_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013324_002D514(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiRldexpScalar_004013327();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiRldexpScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rldexp_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRldexpScalar_004013335_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013337_002D515(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013338_002D516(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRldexpScalar NpiRldexpScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiRldexpScalar(data, scalar);
		}

		public static SymbolOperators.NpiRldexpScalar NpiRldexpScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiRldexpScalar(scalar, data);
		}

		public static NDArray NpxRelu(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npx_relu");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013364_002D517(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpxRelu(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npx_relu");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013378_002D49();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013379_002D77();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpxRelu_004013380(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013382_002D518(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013383_002D519(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpxRelu NpxRelu([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpxRelu(data);
		}

		public static NDArray NpxSigmoid(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npx_sigmoid");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013407_002D520(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpxSigmoid(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npx_sigmoid");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013421_002D50();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013422_002D78();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpxSigmoid_004013423(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013425_002D521(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013426_002D522(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpxSigmoid NpxSigmoid([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpxSigmoid(data);
		}

		public static NDArray NpCopy(NDArray a)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_copy");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013447_002D523(a, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpCopy(IEnumerable<NDArray> outputArray, NDArray a)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_copy");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013458_002D51();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013459_002D79();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpCopy_004013460(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013462_002D524(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013463_002D525(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpCopy NpCopy([Optional] [OptionalArgument] FSharpOption<Symbol> a)
		{
			return new SymbolOperators.NpCopy(a);
		}

		public static NDArray NpiNegative(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_negative");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013482_002D526(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiNegative(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_negative");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013494_002D52();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013495_002D80();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiNegative_004013496(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013498_002D527(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013499_002D528(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiNegative NpiNegative([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiNegative(x);
		}

		public static NDArray NpiReciprocal(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_reciprocal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013519_002D529(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiReciprocal(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_reciprocal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013531_002D53();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013532_002D81();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiReciprocal_004013533(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013535_002D530(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013536_002D531(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiReciprocal NpiReciprocal([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiReciprocal(x);
		}

		public static NDArray NpiAbsolute(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_absolute");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013558_002D532(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiAbsolute(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_absolute");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013572_002D54();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013573_002D82();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiAbsolute_004013574(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013576_002D533(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013577_002D534(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiAbsolute NpiAbsolute([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiAbsolute(x);
		}

		public static NDArray NpiSign(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_sign");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013602_002D535(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiSign(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_sign");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013617_002D55();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013618_002D83();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiSign_004013619(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013621_002D536(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013622_002D537(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiSign NpiSign([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiSign(x);
		}

		public static NDArray NpiRint(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rint");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013647_002D538(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiRint(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rint");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013661_002D56();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013662_002D84();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRint_004013663(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013665_002D539(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013666_002D540(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRint NpiRint([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiRint(x);
		}

		public static NDArray NpiCeil(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_ceil");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013691_002D541(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiCeil(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_ceil");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013706_002D57();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013707_002D85();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiCeil_004013708(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013710_002D542(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013711_002D543(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiCeil NpiCeil([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiCeil(x);
		}

		public static NDArray NpiFloor(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_floor");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013737_002D544(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiFloor(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_floor");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013752_002D58();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013753_002D86();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiFloor_004013754(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013756_002D545(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013757_002D546(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiFloor NpiFloor([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiFloor(x);
		}

		public static NDArray NpiTrunc(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_trunc");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013784_002D547(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiTrunc(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_trunc");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013800_002D59();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013801_002D87();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiTrunc_004013802(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013804_002D548(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013805_002D549(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiTrunc NpiTrunc([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiTrunc(x);
		}

		public static NDArray NpiFix(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_fix");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013833_002D550(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiFix(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_fix");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013849_002D60();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013850_002D88();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiFix_004013851(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013853_002D551(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013854_002D552(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiFix NpiFix([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiFix(x);
		}

		public static NDArray NpiSquare(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_square");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013880_002D553(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiSquare(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_square");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013894_002D61();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013895_002D89();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiSquare_004013896(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013898_002D554(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013899_002D555(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiSquare NpiSquare([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiSquare(x);
		}

		public static NDArray NpiSqrt(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_sqrt");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013923_002D556(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiSqrt(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_sqrt");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013937_002D62();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013938_002D90();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiSqrt_004013939(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013941_002D557(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013942_002D558(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiSqrt NpiSqrt([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiSqrt(x);
		}

		public static NDArray NpiCbrt(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_cbrt");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013966_002D559(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiCbrt(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_cbrt");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004013980_002D63();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004013981_002D91();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiCbrt_004013982(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004013984_002D560(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004013985_002D561(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiCbrt NpiCbrt([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiCbrt(x);
		}

		public static NDArray NpiExp(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_exp");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014009_002D562(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiExp(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_exp");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014023_002D64();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014024_002D92();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiExp_004014025(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014027_002D563(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014028_002D564(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiExp NpiExp([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiExp(x);
		}

		public static NDArray NpiLog(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_log");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014051_002D565(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiLog(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_log");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014064_002D65();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014065_002D93();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLog_004014066(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014068_002D566(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014069_002D567(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLog NpiLog([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiLog(x);
		}

		public static NDArray NpiLog10(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_log10");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014091_002D568(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiLog10(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_log10");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014104_002D66();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014105_002D94();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLog10_004014106(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014108_002D569(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014109_002D570(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLog10 NpiLog10([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiLog10(x);
		}

		public static NDArray NpiLog2(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_log2");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014131_002D571(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiLog2(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_log2");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014144_002D67();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014145_002D95();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLog2_004014146(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014148_002D572(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014149_002D573(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLog2 NpiLog2([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiLog2(x);
		}

		public static NDArray NpiLog1p(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_log1p");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014171_002D574(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiLog1p(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_log1p");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014184_002D68();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014185_002D96();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLog1p_004014186(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014188_002D575(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014189_002D576(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLog1p NpiLog1p([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiLog1p(x);
		}

		public static NDArray NpiExpm1(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_expm1");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014209_002D577(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiExpm1(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_expm1");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014220_002D69();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014221_002D97();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiExpm1_004014222(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014224_002D578(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014225_002D579(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiExpm1 NpiExpm1([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiExpm1(x);
		}

		public static NDArray NpiLogicalNot(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_logical_not");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014240_002D580(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiLogicalNot(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_logical_not");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014248_002D70();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014249_002D98();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLogicalNot_004014250(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014252_002D581(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014253_002D582(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLogicalNot NpiLogicalNot([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiLogicalNot(x);
		}

		public static NDArray NpiSin(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_sin");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014271_002D583(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiSin(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_sin");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014285_002D71();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014286_002D99();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiSin_004014287(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014289_002D584(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014290_002D585(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiSin NpiSin([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiSin(x);
		}

		public static NDArray NpiCos(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_cos");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014314_002D586(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiCos(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_cos");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014328_002D72();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014329_002D100();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiCos_004014330(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014332_002D587(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014333_002D588(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiCos NpiCos([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiCos(x);
		}

		public static NDArray NpiTan(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tan");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014357_002D589(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiTan(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tan");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014371_002D73();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014372_002D101();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiTan_004014373(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014375_002D590(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014376_002D591(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiTan NpiTan([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiTan(x);
		}

		public static NDArray NpiArcsin(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arcsin");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014400_002D592(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiArcsin(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arcsin");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014414_002D74();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014415_002D102();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArcsin_004014416(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014418_002D593(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014419_002D594(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArcsin NpiArcsin([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiArcsin(x);
		}

		public static NDArray NpiArccos(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arccos");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014446_002D595(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiArccos(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arccos");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014463_002D75();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014464_002D103();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArccos_004014465(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014467_002D596(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014468_002D597(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArccos NpiArccos([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiArccos(x);
		}

		public static NDArray NpiArctan(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arctan");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014495_002D598(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiArctan(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arctan");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014509_002D76();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014510_002D104();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArctan_004014511(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014513_002D599(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014514_002D600(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArctan NpiArctan([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiArctan(x);
		}

		public static NDArray NpiDegrees(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_degrees");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014538_002D601(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiDegrees(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_degrees");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014552_002D77();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014553_002D105();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiDegrees_004014554(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014556_002D602(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014557_002D603(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiDegrees NpiDegrees([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiDegrees(x);
		}

		public static NDArray NpiRadians(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_radians");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014581_002D604(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiRadians(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_radians");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014595_002D78();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014596_002D106();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRadians_004014597(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014599_002D605(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014600_002D606(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRadians NpiRadians([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiRadians(x);
		}

		public static NDArray NpiSinh(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_sinh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014624_002D607(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiSinh(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_sinh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014638_002D79();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014639_002D107();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiSinh_004014640(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014642_002D608(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014643_002D609(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiSinh NpiSinh([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiSinh(x);
		}

		public static NDArray NpiCosh(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_cosh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014667_002D610(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiCosh(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_cosh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014681_002D80();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014682_002D108();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiCosh_004014683(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014685_002D611(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014686_002D612(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiCosh NpiCosh([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiCosh(x);
		}

		public static NDArray NpiTanh(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tanh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014710_002D613(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiTanh(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tanh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014724_002D81();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014725_002D109();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiTanh_004014726(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014728_002D614(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014729_002D615(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiTanh NpiTanh([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiTanh(x);
		}

		public static NDArray NpiArcsinh(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arcsinh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014752_002D616(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiArcsinh(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arcsinh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014765_002D82();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014766_002D110();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArcsinh_004014767(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014769_002D617(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014770_002D618(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArcsinh NpiArcsinh([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiArcsinh(x);
		}

		public static NDArray NpiArccosh(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arccosh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014792_002D619(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiArccosh(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arccosh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014805_002D83();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014806_002D111();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArccosh_004014807(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014809_002D620(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014810_002D621(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArccosh NpiArccosh([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiArccosh(x);
		}

		public static NDArray NpiArctanh(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arctanh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014832_002D622(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiArctanh(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arctanh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014845_002D84();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014846_002D112();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArctanh_004014847(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014849_002D623(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014850_002D624(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArctanh NpiArctanh([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpiArctanh(x);
		}

		public static NDArray NpiAround(NDArray x, int decimals = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_around");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014868_002D625(x, 0, current));
			string[] parameterKeys = new string[1]
			{
				"decimals"
			};
			string[] array = new string[1];
			object obj = decimals;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiAround(IEnumerable<NDArray> outputArray, NDArray x, int decimals = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_around");
			string[] names2 = new string[1]
			{
				"decimals"
			};
			string[] array = new string[1];
			object obj = decimals;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiAround_004014879(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014881_002D626(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014882_002D627(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiAround NpiAround([Optional] [OptionalArgument] FSharpOption<Symbol> x, [Optional] [OptionalArgument] FSharpOption<int> decimals)
		{
			return new SymbolOperators.NpiAround(x, decimals);
		}

		public static NDArray[] NpiNanToNum(NDArray data, [Optional] [OptionalArgument] FSharpOption<bool> copy, [Optional] [OptionalArgument] FSharpOption<double> nan, [Optional] [OptionalArgument] FSharpOption<double> posinf, [Optional] [OptionalArgument] FSharpOption<double> neginf)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_nan_to_num");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014906_002D628(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"copy",
				"nan",
				"posinf",
				"neginf"
			};
			string[] array = new string[4];
			object obj;
			if (copy == null)
			{
				obj = "true";
			}
			else
			{
				FSharpOption<bool> val = copy;
				bool copy2 = val.get_Value();
				bool flag = copy2;
				object obj2 = flag;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (nan == null)
			{
				obj4 = "0.0";
			}
			else
			{
				FSharpOption<double> val2 = nan;
				double nan2 = val2.get_Value();
				double num = nan2;
				object obj5 = num;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (posinf == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<double> val3 = posinf;
				double posinf2 = val3.get_Value();
				double num2 = posinf2;
				object obj8 = num2;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (neginf == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<double> val4 = neginf;
				double neginf2 = val4.get_Value();
				double num3 = neginf2;
				object obj11 = num3;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val5 = new _0024Operators.NpiNanToNum_004014909();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val5.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiNanToNum(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<bool> copy, [Optional] [OptionalArgument] FSharpOption<double> nan, [Optional] [OptionalArgument] FSharpOption<double> posinf, [Optional] [OptionalArgument] FSharpOption<double> neginf)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_nan_to_num");
			string[] names2 = new string[4]
			{
				"copy",
				"nan",
				"posinf",
				"neginf"
			};
			string[] array = new string[4];
			object obj;
			if (copy == null)
			{
				obj = "true";
			}
			else
			{
				FSharpOption<bool> val = copy;
				bool copy2 = val.get_Value();
				bool flag = copy2;
				object obj2 = flag;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (nan == null)
			{
				obj4 = "0.0";
			}
			else
			{
				FSharpOption<double> val2 = nan;
				double nan2 = val2.get_Value();
				double num = nan2;
				object obj5 = num;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (posinf == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<double> val3 = posinf;
				double posinf2 = val3.get_Value();
				double num2 = posinf2;
				object obj8 = num2;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (neginf == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<double> val4 = neginf;
				double neginf2 = val4.get_Value();
				double num3 = neginf2;
				object obj11 = num3;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiNanToNum_004014928_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004014930_002D629(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014931_002D630(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiNanToNum NpiNanToNum([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<bool> copy, [Optional] [OptionalArgument] FSharpOption<double> nan, [Optional] [OptionalArgument] FSharpOption<double> posinf, [Optional] [OptionalArgument] FSharpOption<double> neginf)
		{
			return new SymbolOperators.NpiNanToNum(data, copy, nan, posinf, neginf);
		}

		public static NDArray[] NpiBackwardNanToNumNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_backward_nan_to_num");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiBackwardNanToNumNDArray_004014952();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiBackwardNanToNum(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_backward_nan_to_num");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004014956_002D85();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004014957_002D113();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBackwardNanToNum_004014958(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014961_002D631(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBackwardNanToNum NpiBackwardNanToNum()
		{
			return new SymbolOperators.NpiBackwardNanToNum();
		}

		public static NDArray NpiZerosNDArray(Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_zeros");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004014976_002D632(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiZeros(IEnumerable<NDArray> outputArray, Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_zeros");
			string[] names2 = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004014985_002D114(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiZeros_004014986(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004014989_002D633(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiZeros NpiZeros([Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiZeros(shape, dtype);
		}

		public static NDArray NpiOnesNDArray(Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_ones");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015007_002D634(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiOnes(IEnumerable<NDArray> outputArray, Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_ones");
			string[] names2 = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015017_002D115(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiOnes_004015018(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015021_002D635(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiOnes NpiOnes([Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiOnes(shape, dtype);
		}

		public static NDArray NpiIdentityNDArray(Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_identity");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015040_002D636(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiIdentity(IEnumerable<NDArray> outputArray, Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_identity");
			string[] names2 = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015050_002D116(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiIdentity_004015051(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015054_002D637(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiIdentity NpiIdentity([Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiIdentity(shape, dtype);
		}

		public static NDArray NpZerosLike(NDArray a)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_zeros_like");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015068_002D638(a, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpZerosLike(IEnumerable<NDArray> outputArray, NDArray a)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_zeros_like");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004015076_002D86();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004015077_002D117();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpZerosLike_004015078(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015080_002D639(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015081_002D640(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpZerosLike NpZerosLike([Optional] [OptionalArgument] FSharpOption<Symbol> a)
		{
			return new SymbolOperators.NpZerosLike(a);
		}

		public static NDArray NpOnesLike(NDArray a)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_ones_like");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015093_002D641(a, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpOnesLike(IEnumerable<NDArray> outputArray, NDArray a)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_ones_like");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004015101_002D87();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004015102_002D118();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpOnesLike_004015103(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015105_002D642(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015106_002D643(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpOnesLike NpOnesLike([Optional] [OptionalArgument] FSharpOption<Symbol> a)
		{
			return new SymbolOperators.NpOnesLike(a);
		}

		public static NDArray NpiArangeNDArray(double start, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arange");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[7]
			{
				"start",
				"ctx",
				"stop",
				"step",
				"repeat",
				"infer_range",
				"dtype"
			};
			string[] array = new string[7];
			object obj = start;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (stop == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val = stop;
				double stop2 = val.get_Value();
				double num = stop2;
				object obj7 = num;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (step == null)
			{
				obj9 = "1.0";
			}
			else
			{
				FSharpOption<double> val2 = step;
				double step2 = val2.get_Value();
				double num2 = step2;
				object obj10 = num2;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (repeat == null)
			{
				obj12 = "1";
			}
			else
			{
				FSharpOption<int> val3 = repeat;
				int repeat2 = val3.get_Value();
				int num3 = repeat2;
				object obj13 = num3;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			object obj15;
			if (inferRange == null)
			{
				obj15 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = inferRange;
				bool inferRange2 = val4.get_Value();
				bool flag = inferRange2;
				object obj16 = flag;
				if (obj16 != null)
				{
					IFormattable formattable11 = obj16 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj17 = obj16;
						obj15 = obj17.ToString();
					}
				}
				else
				{
					obj15 = "";
				}
			}
			array[5] = (string)obj15;
			object obj18;
			if (dtype == null)
			{
				obj18 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj19 = dataType;
				if (obj19 != null)
				{
					IFormattable formattable13 = obj19 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj20 = obj19;
						obj18 = obj20.ToString();
					}
				}
				else
				{
					obj18 = "";
				}
			}
			array[6] = (string)obj18;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiArange(IEnumerable<NDArray> outputArray, double start, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_arange");
			string[] names2 = new string[7]
			{
				"start",
				"ctx",
				"stop",
				"step",
				"repeat",
				"infer_range",
				"dtype"
			};
			string[] array = new string[7];
			object obj = start;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (stop == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val = stop;
				double stop2 = val.get_Value();
				double num = stop2;
				object obj7 = num;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (step == null)
			{
				obj9 = "1.0";
			}
			else
			{
				FSharpOption<double> val2 = step;
				double step2 = val2.get_Value();
				double num2 = step2;
				object obj10 = num2;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (repeat == null)
			{
				obj12 = "1";
			}
			else
			{
				FSharpOption<int> val3 = repeat;
				int repeat2 = val3.get_Value();
				int num3 = repeat2;
				object obj13 = num3;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			object obj15;
			if (inferRange == null)
			{
				obj15 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = inferRange;
				bool inferRange2 = val4.get_Value();
				bool flag = inferRange2;
				object obj16 = flag;
				if (obj16 != null)
				{
					IFormattable formattable11 = obj16 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj17 = obj16;
						obj15 = obj17.ToString();
					}
				}
				else
				{
					obj15 = "";
				}
			}
			array[5] = (string)obj15;
			object obj18;
			if (dtype == null)
			{
				obj18 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj19 = dataType;
				if (obj19 != null)
				{
					IFormattable formattable13 = obj19 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj20 = obj19;
						obj18 = obj20.ToString();
					}
				}
				else
				{
					obj18 = "";
				}
			}
			array[6] = (string)obj18;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiArange_004015153(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015156_002D644(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiArange NpiArange(double start, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiArange(start, stop, step, repeat, inferRange, dtype);
		}

		public static NDArray[] NpiEyeNDArray(long N, long M, Context ctx, long k = 0L, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_eye");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[5]
			{
				"N",
				"M",
				"ctx",
				"k",
				"dtype"
			};
			string[] array = new string[5];
			object obj = N;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = M;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (ctx != null)
			{
				IFormattable formattable5 = ctx as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = ctx;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9 = k;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			object obj12;
			if ((dtype == null) ? true : false)
			{
				obj12 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable9 = dtype as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = dtype;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiEyeNDArray_004015185();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiEye(IEnumerable<NDArray> outputArray, long N, long M, Context ctx, long k = 0L, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_eye");
			string[] names2 = new string[5]
			{
				"N",
				"M",
				"ctx",
				"k",
				"dtype"
			};
			string[] array = new string[5];
			object obj = N;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = M;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (ctx != null)
			{
				IFormattable formattable5 = ctx as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = ctx;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9 = k;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			object obj12;
			if ((dtype == null) ? true : false)
			{
				obj12 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable9 = dtype as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = dtype;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiEye_004015202(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015205_002D645(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiEye NpiEye(long N, long M, [Optional] [OptionalArgument] FSharpOption<long> k, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiEye(N, M, k, dtype);
		}

		public static NDArray NpiIndicesNDArray(IEnumerable<int> dimensions, Context ctx, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_indices");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"dimensions",
				"ctx",
				"dtype"
			};
			string[] array = new string[3];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015226_002D646(), dimensions));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[1] = (string)obj;
			object obj3;
			if ((dtype == null) ? true : false)
			{
				obj3 = "int32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = dtype;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[2] = (string)obj3;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiIndices(IEnumerable<NDArray> outputArray, IEnumerable<int> dimensions, Context ctx, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_indices");
			string[] names2 = new string[3]
			{
				"dimensions",
				"ctx",
				"dtype"
			};
			string[] array = new string[3];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015236_002D119(), dimensions));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[1] = (string)obj;
			object obj3;
			if ((dtype == null) ? true : false)
			{
				obj3 = "int32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = dtype;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[2] = (string)obj3;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiIndices_004015237(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015240_002D647(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiIndices NpiIndices(IEnumerable<int> dimensions, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiIndices(dimensions, dtype);
		}

		public static NDArray[] NpiLogspaceNDArray(double start, double stop, int num, Context ctx, bool endpoint = true, double lbase = 10.0, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_logspace");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[7]
			{
				"start",
				"stop",
				"num",
				"ctx",
				"endpoint",
				"base",
				"dtype"
			};
			string[] array = new string[7];
			object obj = start;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = stop;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = num;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10;
			if (ctx != null)
			{
				IFormattable formattable7 = ctx as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = ctx;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			bool flag = endpoint;
			object obj12 = flag;
			object obj13;
			if (obj12 != null)
			{
				IFormattable formattable9 = obj12 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = obj12;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15 = lbase;
			object obj16;
			if (obj15 != null)
			{
				IFormattable formattable11 = obj15 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = obj15;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			object obj18;
			if ((dtype == null) ? true : false)
			{
				obj18 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable13 = dtype as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = dtype;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			array[6] = (string)obj18;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiLogspaceNDArray_004015270();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiLogspace(IEnumerable<NDArray> outputArray, double start, double stop, int num, Context ctx, bool endpoint = true, double lbase = 10.0, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_logspace");
			string[] names2 = new string[7]
			{
				"start",
				"stop",
				"num",
				"ctx",
				"endpoint",
				"base",
				"dtype"
			};
			string[] array = new string[7];
			object obj = start;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = stop;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = num;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10;
			if (ctx != null)
			{
				IFormattable formattable7 = ctx as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = ctx;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			bool flag = endpoint;
			object obj12 = flag;
			object obj13;
			if (obj12 != null)
			{
				IFormattable formattable9 = obj12 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = obj12;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15 = lbase;
			object obj16;
			if (obj15 != null)
			{
				IFormattable formattable11 = obj15 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = obj15;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			object obj18;
			if ((dtype == null) ? true : false)
			{
				obj18 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable13 = dtype as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = dtype;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			array[6] = (string)obj18;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiLogspace_004015291(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015294_002D648(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiLogspace NpiLogspace(double start, double stop, int num, [Optional] [OptionalArgument] FSharpOption<bool> endpoint, [Optional] [OptionalArgument] FSharpOption<double> lbase, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiLogspace(start, stop, num, endpoint, lbase, dtype);
		}

		public static NDArray NpTranspose(NDArray a, [Optional] IEnumerable<int> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_transpose");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015313_002D649(a, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj;
			if ((axes == null) ? true : false)
			{
				obj = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015315_002D650(), axes));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpTranspose(IEnumerable<NDArray> outputArray, NDArray a, [Optional] IEnumerable<int> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_transpose");
			string[] names2 = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj;
			if ((axes == null) ? true : false)
			{
				obj = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015323_002D120(), axes));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpTranspose_004015324(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015326_002D651(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015327_002D652(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpTranspose NpTranspose([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			return new SymbolOperators.NpTranspose(a, axes);
		}

		public static NDArray NpReshape(NDArray a, IEnumerable<int> newshape, string order = "C")
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_reshape");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015345_002D653(a, 0, current));
			string[] parameterKeys = new string[2]
			{
				"newshape",
				"order"
			};
			string[] array = new string[2];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015347_002D654(), newshape));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			array[1] = order;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpReshape(IEnumerable<NDArray> outputArray, NDArray a, IEnumerable<int> newshape, string order = "C")
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_reshape");
			string[] names2 = new string[2]
			{
				"newshape",
				"order"
			};
			string[] array = new string[2];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015359_002D121(), newshape));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			array[1] = order;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpReshape_004015360(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015362_002D655(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015363_002D656(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpReshape NpReshape(Symbol a, IEnumerable<int> newshape, [Optional] [OptionalArgument] FSharpOption<string> order)
		{
			return new SymbolOperators.NpReshape(a, newshape, order);
		}

		public static SymbolOperators.NpReshape NpReshape(IEnumerable<int> newshape, [Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<string> order)
		{
			return new SymbolOperators.NpReshape(newshape, a, order);
		}

		public static NDArray[] NpxReshape(NDArray a, IEnumerable<int> newshape, bool reverse = false, string order = "C")
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npx_reshape");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015394_002D657(a, 0, current));
			string[] parameterKeys = new string[3]
			{
				"newshape",
				"reverse",
				"order"
			};
			string[] array = new string[3];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015396_002D658(), newshape));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			bool flag = reverse;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			array[2] = order;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.NpxReshape_004015397();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpxReshape(IEnumerable<NDArray> outputArray, NDArray a, IEnumerable<int> newshape, bool reverse = false, string order = "C")
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npx_reshape");
			string[] names2 = new string[3]
			{
				"newshape",
				"reverse",
				"order"
			};
			string[] array = new string[3];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015409_002D122(), newshape));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			bool flag = reverse;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			array[2] = order;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpxReshape_004015410_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015412_002D659(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015413_002D660(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpxReshape NpxReshape(Symbol a, IEnumerable<int> newshape, [Optional] [OptionalArgument] FSharpOption<bool> reverse, [Optional] [OptionalArgument] FSharpOption<string> order)
		{
			return new SymbolOperators.NpxReshape(a, newshape, reverse, order);
		}

		public static SymbolOperators.NpxReshape NpxReshape(IEnumerable<int> newshape, [Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<bool> reverse, [Optional] [OptionalArgument] FSharpOption<string> order)
		{
			return new SymbolOperators.NpxReshape(newshape, a, reverse, order);
		}

		public static NDArray NpSqueeze(NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_squeeze");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015441_002D661(a, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015443_002D662(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpSqueeze(IEnumerable<NDArray> outputArray, NDArray a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_squeeze");
			string[] names2 = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015451_002D123(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpSqueeze_004015452(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015454_002D663(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015455_002D664(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpSqueeze NpSqueeze([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			return new SymbolOperators.NpSqueeze(a, axis);
		}

		public static NDArray NpiConcatenate(params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_concatenate");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015473_002D665();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array2 = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			return new NDArray(outputs[0]);
		}

		public static void NpiConcatenate(IEnumerable<NDArray> outputArray, params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_concatenate");
			string[] names2 = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiConcatenate_004015488(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015490_002D666();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015491_002D667(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiConcatenate NpiConcatenate([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> dim)
		{
			return new SymbolOperators.NpiConcatenate(data, dim);
		}

		public static NDArray NpiStack(params NDArray[] data, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_stack");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015526_002D668();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_args",
				"axis"
			};
			string[] array2 = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			return new NDArray(outputs[0]);
		}

		public static void NpiStack(IEnumerable<NDArray> outputArray, params NDArray[] data, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_stack");
			string[] names2 = new string[2]
			{
				"num_args",
				"axis"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiStack_004015554(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015556_002D669();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015557_002D670(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiStack NpiStack([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.NpiStack(data, axis);
		}

		public static NDArray[] NpiColumnStack(params NDArray[] data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_column_stack");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015590_002D671();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[1]
			{
				"num_args"
			};
			string[] array2 = new string[1];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.NpiColumnStack_004015593();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void NpiColumnStack(IEnumerable<NDArray> outputArray, params NDArray[] data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_column_stack");
			string[] names2 = new string[1]
			{
				"num_args"
			};
			string[] array = new string[1];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiColumnStack_004015604_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015606_002D672();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015607_002D673(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiColumnStack NpiColumnStack(params Symbol[] data)
		{
			return new SymbolOperators.NpiColumnStack(data);
		}

		public static NDArray NpiVstack(params NDArray[] data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_vstack");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015627_002D674();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[1]
			{
				"num_args"
			};
			string[] array2 = new string[1];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			return new NDArray(outputs[0]);
		}

		public static void NpiVstack(IEnumerable<NDArray> outputArray, params NDArray[] data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_vstack");
			string[] names2 = new string[1]
			{
				"num_args"
			};
			string[] array = new string[1];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiVstack_004015641(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015643_002D675();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015644_002D676(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiVstack NpiVstack(params Symbol[] data)
		{
			return new SymbolOperators.NpiVstack(data);
		}

		public static NDArray[] NpiDstack(params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_dstack");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015665_002D677();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array2 = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.NpiDstack_004015668();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void NpiDstack(IEnumerable<NDArray> outputArray, params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_dstack");
			string[] names2 = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiDstack_004015680_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004015682_002D678();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015683_002D679(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiDstack NpiDstack([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> dim)
		{
			return new SymbolOperators.NpiDstack(data, dim);
		}

		public static NDArray NpRoll(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shift, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_roll");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015702_002D680(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"shift",
				"axis"
			};
			string[] array = new string[2];
			object obj;
			if (shift == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = shift;
				IEnumerable<int> shift2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015704_002D681(), shift2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (axis == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = axis;
				IEnumerable<int> axis2 = val3.get_Value();
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015704_002D682(), axis2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj2 = val4.Invoke(text4);
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpRoll(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shift, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_roll");
			string[] names2 = new string[2]
			{
				"shift",
				"axis"
			};
			string[] array = new string[2];
			object obj;
			if (shift == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = shift;
				IEnumerable<int> shift2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015713_002D124(), shift2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (axis == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = axis;
				IEnumerable<int> axis2 = val3.get_Value();
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015713_002D125(), axis2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj2 = val4.Invoke(text4);
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpRoll_004015714(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015716_002D683(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015717_002D684(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpRoll NpRoll([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shift, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			return new SymbolOperators.NpRoll(data, shift, axis);
		}

		public static NDArray NpiFlip(NDArray data, IEnumerable<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_flip");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015732_002D685(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015734_002D686(), axis));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiFlip(IEnumerable<NDArray> outputArray, NDArray data, IEnumerable<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_flip");
			string[] names2 = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015742_002D126(), axis));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiFlip_004015743(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015745_002D687(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015746_002D688(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiFlip NpiFlip(Symbol data, IEnumerable<int> axis)
		{
			return new SymbolOperators.NpiFlip(data, axis);
		}

		public static SymbolOperators.NpiFlip NpiFlip(IEnumerable<int> axis, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiFlip(axis, data);
		}

		public static NDArray[] NpMoveaxis(NDArray a, IEnumerable<int> source, IEnumerable<int> destination)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_moveaxis");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015771_002D689(a, 0, current));
			string[] parameterKeys = new string[2]
			{
				"source",
				"destination"
			};
			string[] array = new string[2];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015773_002D690(), source));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015773_002D691(), destination));
			FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text4 = text3;
			array[1] = val2.Invoke(text4);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val3 = new _0024Operators.NpMoveaxis_004015774();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val3.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpMoveaxis(IEnumerable<NDArray> outputArray, NDArray a, IEnumerable<int> source, IEnumerable<int> destination)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_moveaxis");
			string[] names2 = new string[2]
			{
				"source",
				"destination"
			};
			string[] array = new string[2];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015787_002D127(), source));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015787_002D128(), destination));
			FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text4 = text3;
			array[1] = val2.Invoke(text4);
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpMoveaxis_004015788_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015790_002D692(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015791_002D693(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpMoveaxis NpMoveaxis(Symbol a, IEnumerable<int> source, IEnumerable<int> destination)
		{
			return new SymbolOperators.NpMoveaxis(a, source, destination);
		}

		public static SymbolOperators.NpMoveaxis NpMoveaxis(IEnumerable<int> source, IEnumerable<int> destination, [Optional] [OptionalArgument] FSharpOption<Symbol> a)
		{
			return new SymbolOperators.NpMoveaxis(source, destination, a);
		}

		public static NDArray[] NpiRot90(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rot90");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015822_002D694(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"k",
				"axes"
			};
			string[] array = new string[2];
			object obj;
			if (k == null)
			{
				obj = "1";
			}
			else
			{
				FSharpOption<int> val = k;
				int i = val.get_Value();
				int num = i;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (axes == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val2 = axes;
				IEnumerable<int> axes2 = val2.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015824_002D695(), axes2));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj4 = val3.Invoke(text2);
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val4 = new _0024Operators.NpiRot90_004015825();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				array4[j] = val4.Invoke(array3[j]);
			}
			return array4;
		}

		public static void NpiRot90(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rot90");
			string[] names2 = new string[2]
			{
				"k",
				"axes"
			};
			string[] array = new string[2];
			object obj;
			if (k == null)
			{
				obj = "1";
			}
			else
			{
				FSharpOption<int> val = k;
				int i = val.get_Value();
				int num = i;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (axes == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val2 = axes;
				IEnumerable<int> axes2 = val2.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015833_002D129(), axes2));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj4 = val3.Invoke(text2);
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRot90_004015834_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015836_002D696(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015837_002D697(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRot90 NpiRot90([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			return new SymbolOperators.NpiRot90(data, k, axes);
		}

		public static NDArray[] NpiHsplit(NDArray data, IEnumerable<int> indices, int axis = 1, bool squeezeAxis = false, int sections = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hsplit");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015859_002D698(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"indices",
				"axis",
				"squeeze_axis",
				"sections"
			};
			string[] array = new string[4];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004015861_002D699(), indices));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			bool flag = squeezeAxis;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			object obj7 = sections;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.NpiHsplit_004015862();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiHsplit(IEnumerable<NDArray> outputArray, NDArray data, IEnumerable<int> indices, int axis = 1, bool squeezeAxis = false, int sections = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hsplit");
			string[] names2 = new string[4]
			{
				"indices",
				"axis",
				"squeeze_axis",
				"sections"
			};
			string[] array = new string[4];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004015877_002D130(), indices));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			bool flag = squeezeAxis;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			object obj7 = sections;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiHsplit_004015878_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015880_002D700(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015881_002D701(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiHsplit NpiHsplit(Symbol data, IEnumerable<int> indices, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> squeezeAxis, [Optional] [OptionalArgument] FSharpOption<int> sections)
		{
			return new SymbolOperators.NpiHsplit(data, indices, axis, squeezeAxis, sections);
		}

		public static SymbolOperators.NpiHsplit NpiHsplit(IEnumerable<int> indices, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> squeezeAxis, [Optional] [OptionalArgument] FSharpOption<int> sections)
		{
			return new SymbolOperators.NpiHsplit(indices, data, axis, squeezeAxis, sections);
		}

		public static NDArray[] NpiHsplitBackwardNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hsplit_backward");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiHsplitBackwardNDArray_004015906();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiHsplitBackward(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hsplit_backward");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004015910_002D88();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004015911_002D131();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiHsplitBackward_004015912(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015915_002D702(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiHsplitBackward NpiHsplitBackward()
		{
			return new SymbolOperators.NpiHsplitBackward();
		}

		public static NDArray[] NpDiag(NDArray data, int k = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_diag");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015927_002D703(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"k"
			};
			string[] array = new string[1];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpDiag_004015930();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpDiag(IEnumerable<NDArray> outputArray, NDArray data, int k = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_diag");
			string[] names2 = new string[1]
			{
				"k"
			};
			string[] array = new string[1];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpDiag_004015938_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015940_002D704(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015941_002D705(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpDiag NpDiag([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> k)
		{
			return new SymbolOperators.NpDiag(data, k);
		}

		public static NDArray[] NpDiagflat(NDArray data, int k = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_diagflat");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015956_002D706(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"k"
			};
			string[] array = new string[1];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpDiagflat_004015959();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpDiagflat(IEnumerable<NDArray> outputArray, NDArray data, int k = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_diagflat");
			string[] names2 = new string[1]
			{
				"k"
			};
			string[] array = new string[1];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpDiagflat_004015967_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015969_002D707(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015970_002D708(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpDiagflat NpDiagflat([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> k)
		{
			return new SymbolOperators.NpDiagflat(data, k);
		}

		public static NDArray[] NpiShareMemory(NDArray a, NDArray b)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_share_memory");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015985_002D709(a, b, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiShareMemory_004015988();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiShareMemory(IEnumerable<NDArray> outputArray, NDArray a, NDArray b)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_share_memory");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004015994_002D89();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004015995_002D132();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiShareMemory_004015996_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004015998_002D710(a, b, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004015999_002D711(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiShareMemory NpiShareMemory([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<Symbol> b)
		{
			return new SymbolOperators.NpiShareMemory(a, b);
		}

		public static NDArray NpxNonzero(NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npx_nonzero");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016012_002D712(x, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpxNonzero(IEnumerable<NDArray> outputArray, NDArray x)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npx_nonzero");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004016020_002D90();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004016021_002D133();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpxNonzero_004016022(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016024_002D713(x, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016025_002D714(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpxNonzero NpxNonzero([Optional] [OptionalArgument] FSharpOption<Symbol> x)
		{
			return new SymbolOperators.NpxNonzero(x);
		}

		public static NDArray NpiTensordot(NDArray a, NDArray b, IEnumerable<int> aAxesSummed, IEnumerable<int> bAxesSummed)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tensordot");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016040_002D715(a, b, 0, current));
			string[] parameterKeys = new string[2]
			{
				"a_axes_summed",
				"b_axes_summed"
			};
			string[] array = new string[2];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016042_002D716(), aAxesSummed));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016042_002D717(), bAxesSummed));
			FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text4 = text3;
			array[1] = val2.Invoke(text4);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiTensordot(IEnumerable<NDArray> outputArray, NDArray a, NDArray b, IEnumerable<int> aAxesSummed, IEnumerable<int> bAxesSummed)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tensordot");
			string[] names2 = new string[2]
			{
				"a_axes_summed",
				"b_axes_summed"
			};
			string[] array = new string[2];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016052_002D134(), aAxesSummed));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016052_002D135(), bAxesSummed));
			FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text4 = text3;
			array[1] = val2.Invoke(text4);
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiTensordot_004016053(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016055_002D718(a, b, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016056_002D719(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiTensordot NpiTensordot(Symbol a, Symbol b, IEnumerable<int> aAxesSummed, IEnumerable<int> bAxesSummed)
		{
			return new SymbolOperators.NpiTensordot(a, b, aAxesSummed, bAxesSummed);
		}

		public static SymbolOperators.NpiTensordot NpiTensordot(IEnumerable<int> aAxesSummed, IEnumerable<int> bAxesSummed, [Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<Symbol> b)
		{
			return new SymbolOperators.NpiTensordot(aAxesSummed, bAxesSummed, a, b);
		}

		public static NDArray NpiTensordotIntAxes(NDArray a, NDArray b, int axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tensordot_int_axes");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016080_002D720(a, b, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj = axes;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiTensordotIntAxes(IEnumerable<NDArray> outputArray, NDArray a, NDArray b, int axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tensordot_int_axes");
			string[] names2 = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj = axes;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiTensordotIntAxes_004016092(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016094_002D721(a, b, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016095_002D722(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiTensordotIntAxes NpiTensordotIntAxes(Symbol a, Symbol b, int axes)
		{
			return new SymbolOperators.NpiTensordotIntAxes(a, b, axes);
		}

		public static SymbolOperators.NpiTensordotIntAxes NpiTensordotIntAxes(int axes, [Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<Symbol> b)
		{
			return new SymbolOperators.NpiTensordotIntAxes(axes, a, b);
		}

		public static NDArray NpTrace(NDArray data, int offset = 0, int axis1 = 0, int axis2 = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_trace");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016138_002D723(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"offset",
				"axis1",
				"axis2"
			};
			string[] array = new string[3];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = axis2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpTrace(IEnumerable<NDArray> outputArray, NDArray data, int offset = 0, int axis1 = 0, int axis2 = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_np_trace");
			string[] names2 = new string[3]
			{
				"offset",
				"axis1",
				"axis2"
			};
			string[] array = new string[3];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = axis2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpTrace_004016171(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016173_002D724(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016174_002D725(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpTrace NpTrace([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> offset, [Optional] [OptionalArgument] FSharpOption<int> axis1, [Optional] [OptionalArgument] FSharpOption<int> axis2)
		{
			return new SymbolOperators.NpTrace(data, offset, axis1, axis2);
		}

		public static NDArray[] NpiTril(NDArray data, int k = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tril");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016211_002D726(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"k"
			};
			string[] array = new string[1];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiTril_004016214();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiTril(IEnumerable<NDArray> outputArray, NDArray data, int k = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_tril");
			string[] names2 = new string[1]
			{
				"k"
			};
			string[] array = new string[1];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiTril_004016222_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016224_002D727(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016225_002D728(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiTril NpiTril([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> k)
		{
			return new SymbolOperators.NpiTril(data, k);
		}

		public static NDArray NpiTrueDivide(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_true_divide");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016240_002D729(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NpiTrueDivide(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_true_divide");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004016249_002D91();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004016250_002D136();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiTrueDivide_004016251(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016253_002D730(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016254_002D731(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiTrueDivide NpiTrueDivide([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NpiTrueDivide(lhs, rhs);
		}

		public static NDArray NpiTrueDivideScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_true_divide_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016268_002D732(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiTrueDivideScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_true_divide_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiTrueDivideScalar_004016279(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016281_002D733(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016282_002D734(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiTrueDivideScalar NpiTrueDivideScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiTrueDivideScalar(data, scalar);
		}

		public static SymbolOperators.NpiTrueDivideScalar NpiTrueDivideScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiTrueDivideScalar(scalar, data);
		}

		public static NDArray NpiRtrueDivideScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rtrue_divide_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016300_002D735(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiRtrueDivideScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_rtrue_divide_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiRtrueDivideScalar_004016311(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016313_002D736(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016314_002D737(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiRtrueDivideScalar NpiRtrueDivideScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NpiRtrueDivideScalar(data, scalar);
		}

		public static SymbolOperators.NpiRtrueDivideScalar NpiRtrueDivideScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NpiRtrueDivideScalar(scalar, data);
		}

		public static NDArray[] NpiUnique(NDArray data, [Optional] [OptionalArgument] FSharpOption<bool> returnIndex, [Optional] [OptionalArgument] FSharpOption<bool> returnInverse, [Optional] [OptionalArgument] FSharpOption<bool> returnCounts, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_unique");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016339_002D738(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"return_index",
				"return_inverse",
				"return_counts",
				"axis"
			};
			string[] array = new string[4];
			object obj;
			if (returnIndex == null)
			{
				obj = "false";
			}
			else
			{
				FSharpOption<bool> val = returnIndex;
				bool returnIndex2 = val.get_Value();
				bool flag = returnIndex2;
				object obj2 = flag;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (returnInverse == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = returnInverse;
				bool returnInverse2 = val2.get_Value();
				bool flag2 = returnInverse2;
				object obj5 = flag2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (returnCounts == null)
			{
				obj7 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = returnCounts;
				bool returnCounts2 = val3.get_Value();
				bool flag3 = returnCounts2;
				object obj8 = flag3;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (axis == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<int> val4 = axis;
				int axis2 = val4.get_Value();
				int num = axis2;
				object obj11 = num;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val5 = new _0024Operators.NpiUnique_004016342();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val5.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiUnique(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<bool> returnIndex, [Optional] [OptionalArgument] FSharpOption<bool> returnInverse, [Optional] [OptionalArgument] FSharpOption<bool> returnCounts, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_unique");
			string[] names2 = new string[4]
			{
				"return_index",
				"return_inverse",
				"return_counts",
				"axis"
			};
			string[] array = new string[4];
			object obj;
			if (returnIndex == null)
			{
				obj = "false";
			}
			else
			{
				FSharpOption<bool> val = returnIndex;
				bool returnIndex2 = val.get_Value();
				bool flag = returnIndex2;
				object obj2 = flag;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (returnInverse == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = returnInverse;
				bool returnInverse2 = val2.get_Value();
				bool flag2 = returnInverse2;
				object obj5 = flag2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (returnCounts == null)
			{
				obj7 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = returnCounts;
				bool returnCounts2 = val3.get_Value();
				bool flag3 = returnCounts2;
				object obj8 = flag3;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (axis == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<int> val4 = axis;
				int axis2 = val4.get_Value();
				int num = axis2;
				object obj11 = num;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiUnique_004016358_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016360_002D739(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016361_002D740(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiUnique NpiUnique([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<bool> returnIndex, [Optional] [OptionalArgument] FSharpOption<bool> returnInverse, [Optional] [OptionalArgument] FSharpOption<bool> returnCounts, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.NpiUnique(data, returnIndex, returnInverse, returnCounts, axis);
		}

		public static NDArray[] NpiWhere(NDArray condition, NDArray x, NDArray y)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_where");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016379_002D741(condition, x, y, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.NpiWhere_004016382();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void NpiWhere(IEnumerable<NDArray> outputArray, NDArray condition, NDArray x, NDArray y)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_where");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004016389_002D92();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004016390_002D137();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiWhere_004016391_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016393_002D742(condition, x, y, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016394_002D743(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiWhere NpiWhere([Optional] [OptionalArgument] FSharpOption<Symbol> condition, [Optional] [OptionalArgument] FSharpOption<Symbol> x, [Optional] [OptionalArgument] FSharpOption<Symbol> y)
		{
			return new SymbolOperators.NpiWhere(condition, x, y);
		}

		public static NDArray NpiHanningNDArray(int M, Context ctx, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hanning");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"M",
				"ctx",
				"dtype"
			};
			string[] array = new string[3];
			object obj = M;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((dtype == null) ? true : false)
			{
				obj6 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = dtype;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiHanning(IEnumerable<NDArray> outputArray, int M, Context ctx, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hanning");
			string[] names2 = new string[3]
			{
				"M",
				"ctx",
				"dtype"
			};
			string[] array = new string[3];
			object obj = M;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((dtype == null) ? true : false)
			{
				obj6 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = dtype;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiHanning_004016425(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016428_002D744(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiHanning NpiHanning(int M, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiHanning(M, dtype);
		}

		public static NDArray NpiHammingNDArray(int M, Context ctx, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hamming");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"M",
				"ctx",
				"dtype"
			};
			string[] array = new string[3];
			object obj = M;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((dtype == null) ? true : false)
			{
				obj6 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = dtype;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiHamming(IEnumerable<NDArray> outputArray, int M, Context ctx, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_hamming");
			string[] names2 = new string[3]
			{
				"M",
				"ctx",
				"dtype"
			};
			string[] array = new string[3];
			object obj = M;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((dtype == null) ? true : false)
			{
				obj6 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = dtype;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiHamming_004016458(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016461_002D745(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiHamming NpiHamming(int M, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiHamming(M, dtype);
		}

		public static NDArray NpiBlackmanNDArray(int M, Context ctx, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_blackman");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"M",
				"ctx",
				"dtype"
			};
			string[] array = new string[3];
			object obj = M;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((dtype == null) ? true : false)
			{
				obj6 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = dtype;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiBlackman(IEnumerable<NDArray> outputArray, int M, Context ctx, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_blackman");
			string[] names2 = new string[3]
			{
				"M",
				"ctx",
				"dtype"
			};
			string[] array = new string[3];
			object obj = M;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((dtype == null) ? true : false)
			{
				obj6 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = dtype;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBlackman_004016491(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016494_002D746(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBlackman NpiBlackman(int M, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiBlackman(M, dtype);
		}

		public static NDArray[] NpiBernoulli(NDArray input1, Context ctx, bool isLogit, [Optional] [OptionalArgument] FSharpOption<double> prob, [Optional] [OptionalArgument] FSharpOption<double> logit, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bernoulli");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016520_002D747(input1, 0, current));
			string[] parameterKeys = new string[6]
			{
				"ctx",
				"is_logit",
				"prob",
				"logit",
				"size",
				"dtype"
			};
			string[] array = new string[6];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			bool flag = isLogit;
			object obj3 = flag;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (prob == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val = prob;
				double prob2 = val.get_Value();
				double num = prob2;
				object obj7 = num;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (logit == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<double> val2 = logit;
				double logit2 = val2.get_Value();
				double num2 = logit2;
				object obj10 = num2;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (size == null)
			{
				obj12 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016522_002D748(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj12 = val4.Invoke(text2);
			}
			array[4] = (string)obj12;
			object obj13;
			if (dtype == null)
			{
				obj13 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj14 = dataType;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[5] = (string)obj13;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val6 = new _0024Operators.NpiBernoulli_004016523();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val6.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiBernoulli(IEnumerable<NDArray> outputArray, NDArray input1, Context ctx, bool isLogit, [Optional] [OptionalArgument] FSharpOption<double> prob, [Optional] [OptionalArgument] FSharpOption<double> logit, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_bernoulli");
			string[] names2 = new string[6]
			{
				"ctx",
				"is_logit",
				"prob",
				"logit",
				"size",
				"dtype"
			};
			string[] array = new string[6];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			bool flag = isLogit;
			object obj3 = flag;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (prob == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val = prob;
				double prob2 = val.get_Value();
				double num = prob2;
				object obj7 = num;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (logit == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<double> val2 = logit;
				double logit2 = val2.get_Value();
				double num2 = logit2;
				object obj10 = num2;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (size == null)
			{
				obj12 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016542_002D138(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj12 = val4.Invoke(text2);
			}
			array[4] = (string)obj12;
			object obj13;
			if (dtype == null)
			{
				obj13 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj14 = dataType;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[5] = (string)obj13;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiBernoulli_004016543_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016545_002D749(input1, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016546_002D750(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiBernoulli NpiBernoulli(Symbol input1, bool isLogit, [Optional] [OptionalArgument] FSharpOption<double> prob, [Optional] [OptionalArgument] FSharpOption<double> logit, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiBernoulli(input1, isLogit, prob, logit, size, dtype);
		}

		public static SymbolOperators.NpiBernoulli NpiBernoulli(bool isLogit, [Optional] [OptionalArgument] FSharpOption<Symbol> input1, [Optional] [OptionalArgument] FSharpOption<double> prob, [Optional] [OptionalArgument] FSharpOption<double> logit, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.NpiBernoulli(isLogit, input1, prob, logit, size, dtype);
		}

		public static NDArray NpiChoice(NDArray input1, NDArray input2, long a, IEnumerable<int> size, Context ctx, bool replace = true, bool weighted = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_choice");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016584_002D751(input1, input2, 0, current));
			string[] parameterKeys = new string[5]
			{
				"a",
				"size",
				"ctx",
				"replace",
				"weighted"
			};
			string[] array = new string[5];
			object obj = a;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016586_002D752(), size));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[1] = val.Invoke(text2);
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			bool flag = replace;
			object obj6 = flag;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			bool flag2 = weighted;
			object obj9 = flag2;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiChoice(IEnumerable<NDArray> outputArray, NDArray input1, NDArray input2, long a, IEnumerable<int> size, Context ctx, bool replace = true, bool weighted = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_choice");
			string[] names2 = new string[5]
			{
				"a",
				"size",
				"ctx",
				"replace",
				"weighted"
			};
			string[] array = new string[5];
			object obj = a;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016607_002D139(), size));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[1] = val.Invoke(text2);
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			bool flag = replace;
			object obj6 = flag;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			bool flag2 = weighted;
			object obj9 = flag2;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiChoice_004016608(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016610_002D753(input1, input2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016611_002D754(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiChoice NpiChoice(Symbol input1, Symbol input2, long a, IEnumerable<int> size, [Optional] [OptionalArgument] FSharpOption<bool> replace, [Optional] [OptionalArgument] FSharpOption<bool> weighted)
		{
			return new SymbolOperators.NpiChoice(input1, input2, a, size, replace, weighted);
		}

		public static SymbolOperators.NpiChoice NpiChoice(long a, IEnumerable<int> size, [Optional] [OptionalArgument] FSharpOption<Symbol> input1, [Optional] [OptionalArgument] FSharpOption<Symbol> input2, [Optional] [OptionalArgument] FSharpOption<bool> replace, [Optional] [OptionalArgument] FSharpOption<bool> weighted)
		{
			return new SymbolOperators.NpiChoice(a, size, input1, input2, replace, weighted);
		}

		public static NDArray NpiMultinomial(NDArray a, int n, IEnumerable<double> pvals, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_multinomial");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016648_002D755(a, 0, current));
			string[] parameterKeys = new string[3]
			{
				"n",
				"pvals",
				"size"
			};
			string[] array = new string[3];
			object obj = n;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (pvals != null)
			{
				IFormattable formattable3 = pvals as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = pvals;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (size == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = size;
				IEnumerable<int> size2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016650_002D756(), size2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj6 = val2.Invoke(text2);
			}
			array[2] = (string)obj6;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiMultinomial(IEnumerable<NDArray> outputArray, NDArray a, int n, IEnumerable<double> pvals, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_multinomial");
			string[] names2 = new string[3]
			{
				"n",
				"pvals",
				"size"
			};
			string[] array = new string[3];
			object obj = n;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (pvals != null)
			{
				IFormattable formattable3 = pvals as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = pvals;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (size == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = size;
				IEnumerable<int> size2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016667_002D140(), size2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj6 = val2.Invoke(text2);
			}
			array[2] = (string)obj6;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiMultinomial_004016668(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016670_002D757(a, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016671_002D758(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiMultinomial NpiMultinomial(Symbol a, int n, IEnumerable<double> pvals, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size)
		{
			return new SymbolOperators.NpiMultinomial(a, n, pvals, size);
		}

		public static SymbolOperators.NpiMultinomial NpiMultinomial(int n, IEnumerable<double> pvals, [Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size)
		{
			return new SymbolOperators.NpiMultinomial(n, pvals, a, size);
		}

		public static NDArray NpiNormal(NDArray input1, NDArray input2, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> loc, [Optional] [OptionalArgument] FSharpOption<double> scale, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_normal");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016719_002D759(input1, input2, 0, current));
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"loc",
				"scale",
				"size",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (loc == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<double> val = loc;
				double loc2 = val.get_Value();
				double num = loc2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (scale == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val2 = scale;
				double scale2 = val2.get_Value();
				double num2 = scale2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (size == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016721_002D760(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val4.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if (dtype == null)
			{
				obj10 = "float32";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val5 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val5.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj11 = floatDType;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiNormal(IEnumerable<NDArray> outputArray, NDArray input1, NDArray input2, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> loc, [Optional] [OptionalArgument] FSharpOption<double> scale, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_normal");
			string[] names2 = new string[5]
			{
				"ctx",
				"loc",
				"scale",
				"size",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (loc == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<double> val = loc;
				double loc2 = val.get_Value();
				double num = loc2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (scale == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val2 = scale;
				double scale2 = val2.get_Value();
				double num2 = scale2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (size == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016742_002D141(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val4.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if (dtype == null)
			{
				obj10 = "float32";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val5 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val5.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj11 = floatDType;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiNormal_004016743(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016745_002D761(input1, input2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016746_002D762(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiNormal NpiNormal([Optional] [OptionalArgument] FSharpOption<Symbol> input1, [Optional] [OptionalArgument] FSharpOption<Symbol> input2, [Optional] [OptionalArgument] FSharpOption<double> loc, [Optional] [OptionalArgument] FSharpOption<double> scale, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.NpiNormal(input1, input2, loc, scale, size, dtype);
		}

		public static NDArray[] NpiNormalN(NDArray input1, NDArray input2, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> loc, [Optional] [OptionalArgument] FSharpOption<double> scale, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_normal_n");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016777_002D763(input1, input2, 0, current));
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"loc",
				"scale",
				"size",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (loc == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<double> val = loc;
				double loc2 = val.get_Value();
				double num = loc2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (scale == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val2 = scale;
				double scale2 = val2.get_Value();
				double num2 = scale2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (size == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016779_002D764(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val4.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if (dtype == null)
			{
				obj10 = "float32";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val5 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val5.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj11 = floatDType;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val6 = new _0024Operators.NpiNormalN_004016780();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val6.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiNormalN(IEnumerable<NDArray> outputArray, NDArray input1, NDArray input2, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> loc, [Optional] [OptionalArgument] FSharpOption<double> scale, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_normal_n");
			string[] names2 = new string[5]
			{
				"ctx",
				"loc",
				"scale",
				"size",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (loc == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<double> val = loc;
				double loc2 = val.get_Value();
				double num = loc2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (scale == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val2 = scale;
				double scale2 = val2.get_Value();
				double num2 = scale2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (size == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016800_002D142(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val4.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if (dtype == null)
			{
				obj10 = "float32";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val5 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val5.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj11 = floatDType;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiNormalN_004016801_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016803_002D765(input1, input2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016804_002D766(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiNormalN NpiNormalN([Optional] [OptionalArgument] FSharpOption<Symbol> input1, [Optional] [OptionalArgument] FSharpOption<Symbol> input2, [Optional] [OptionalArgument] FSharpOption<double> loc, [Optional] [OptionalArgument] FSharpOption<double> scale, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.NpiNormalN(input1, input2, loc, scale, size, dtype);
		}

		public static NDArray NpiUniform(NDArray input1, NDArray input2, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> low, [Optional] [OptionalArgument] FSharpOption<double> high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_uniform");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016836_002D767(input1, input2, 0, current));
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"low",
				"high",
				"size",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (low == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<double> val = low;
				double low2 = val.get_Value();
				double num = low2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (high == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val2 = high;
				double high2 = val2.get_Value();
				double num2 = high2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (size == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016838_002D768(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val4.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if (dtype == null)
			{
				obj10 = "float32";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val5 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val5.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj11 = floatDType;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NpiUniform(IEnumerable<NDArray> outputArray, NDArray input1, NDArray input2, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> low, [Optional] [OptionalArgument] FSharpOption<double> high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_uniform");
			string[] names2 = new string[5]
			{
				"ctx",
				"low",
				"high",
				"size",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (low == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<double> val = low;
				double low2 = val.get_Value();
				double num = low2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (high == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val2 = high;
				double high2 = val2.get_Value();
				double num2 = high2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (size == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016859_002D143(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val4.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if (dtype == null)
			{
				obj10 = "float32";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val5 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val5.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj11 = floatDType;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiUniform_004016860(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016862_002D769(input1, input2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016863_002D770(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiUniform NpiUniform([Optional] [OptionalArgument] FSharpOption<Symbol> input1, [Optional] [OptionalArgument] FSharpOption<Symbol> input2, [Optional] [OptionalArgument] FSharpOption<double> low, [Optional] [OptionalArgument] FSharpOption<double> high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.NpiUniform(input1, input2, low, high, size, dtype);
		}

		public static NDArray[] NpiUniformN(NDArray input1, NDArray input2, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> low, [Optional] [OptionalArgument] FSharpOption<double> high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_uniform_n");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016894_002D771(input1, input2, 0, current));
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"low",
				"high",
				"size",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (low == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<double> val = low;
				double low2 = val.get_Value();
				double num = low2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (high == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val2 = high;
				double high2 = val2.get_Value();
				double num2 = high2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (size == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004016896_002D772(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val4.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if (dtype == null)
			{
				obj10 = "float32";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val5 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val5.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj11 = floatDType;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val6 = new _0024Operators.NpiUniformN_004016897();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val6.Invoke(array3[i]);
			}
			return array4;
		}

		public static void NpiUniformN(IEnumerable<NDArray> outputArray, NDArray input1, NDArray input2, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> low, [Optional] [OptionalArgument] FSharpOption<double> high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_npi_uniform_n");
			string[] names2 = new string[5]
			{
				"ctx",
				"low",
				"high",
				"size",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (low == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<double> val = low;
				double low2 = val.get_Value();
				double num = low2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (high == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val2 = high;
				double high2 = val2.get_Value();
				double num2 = high2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (size == null)
			{
				obj9 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = size;
				IEnumerable<int> size2 = val3.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004016917_002D144(), size2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val4.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if (dtype == null)
			{
				obj10 = "float32";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.FloatDType> val5 = dtype;
				GeneratedArgumentTypes.FloatDType dtype2 = val5.get_Value();
				GeneratedArgumentTypes.FloatDType floatDType = dtype2;
				object obj11 = floatDType;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NpiUniformN_004016918_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016920_002D773(input1, input2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004016921_002D774(), outputArray)), names, vals);
		}

		public static SymbolOperators.NpiUniformN NpiUniformN([Optional] [OptionalArgument] FSharpOption<Symbol> input1, [Optional] [OptionalArgument] FSharpOption<Symbol> input2, [Optional] [OptionalArgument] FSharpOption<double> low, [Optional] [OptionalArgument] FSharpOption<double> high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.NpiUniformN(input1, input2, low, high, size, dtype);
		}

		public static NDArray SignsgdUpdate(NDArray weight, NDArray grad, double lr, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("signsgd_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004016965_002D775(weight, grad, 0, current));
			string[] parameterKeys = new string[4]
			{
				"lr",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[4];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = wd;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = rescaleGrad;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = clipGradient;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SignsgdUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, double lr, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("signsgd_update");
			string[] names2 = new string[4]
			{
				"lr",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[4];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = wd;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = rescaleGrad;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = clipGradient;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SignsgdUpdate_004017002(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004017004_002D776(weight, grad, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004017005_002D777(), outputArray)), names, vals);
		}

		public static SymbolOperators.SignsgdUpdate SignsgdUpdate(Symbol weight, Symbol grad, double lr, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.SignsgdUpdate(weight, grad, lr, wd, rescaleGrad, clipGradient);
		}

		public static SymbolOperators.SignsgdUpdate SignsgdUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.SignsgdUpdate(lr, weight, grad, wd, rescaleGrad, clipGradient);
		}

		public static NDArray SignumUpdate(NDArray weight, NDArray grad, NDArray mom, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, double wdLh = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("signum_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004017097_002D778(weight, grad, mom, 0, current));
			string[] parameterKeys = new string[6]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"wd_lh"
			};
			string[] array = new string[6];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = wdLh;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SignumUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mom, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, double wdLh = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("signum_update");
			string[] names2 = new string[6]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"wd_lh"
			};
			string[] array = new string[6];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = wdLh;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SignumUpdate_004017143(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004017145_002D779(weight, grad, mom, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004017146_002D780(), outputArray)), names, vals);
		}

		public static SymbolOperators.SignumUpdate SignumUpdate(Symbol weight, Symbol grad, Symbol mom, double lr, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<double> wdLh)
		{
			return new SymbolOperators.SignumUpdate(weight, grad, mom, lr, momentum, wd, rescaleGrad, clipGradient, wdLh);
		}

		public static SymbolOperators.SignumUpdate SignumUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mom, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<double> wdLh)
		{
			return new SymbolOperators.SignumUpdate(lr, weight, grad, mom, momentum, wd, rescaleGrad, clipGradient, wdLh);
		}

		public static NDArray[] MultiSgdUpdate(params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_sgd_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004017234_002D781();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[5]
			{
				"lrs",
				"wds",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[5];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array2[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array2[1] = (string)obj3;
			object obj5 = rescaleGrad;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array2[2] = (string)obj6;
			object obj8 = clipGradient;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable7 = obj8 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array2[3] = (string)obj9;
			object obj11 = numWeights;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable9 = obj11 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array2[4] = (string)obj12;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.MultiSgdUpdate_004017237();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void MultiSgdUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_sgd_update");
			string[] names2 = new string[5]
			{
				"lrs",
				"wds",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[5];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5 = rescaleGrad;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			object obj8 = clipGradient;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable7 = obj8 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array[3] = (string)obj9;
			object obj11 = numWeights;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable9 = obj11 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiSgdUpdate_004017264_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004017266_002D782();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004017267_002D783(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiSgdUpdate MultiSgdUpdate(IEnumerable<Symbol> data, IEnumerable<double> lrs, IEnumerable<double> wds, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiSgdUpdate(data, lrs, wds, rescaleGrad, clipGradient, numWeights);
		}

		public static SymbolOperators.MultiSgdUpdate MultiSgdUpdate(IEnumerable<double> lrs, IEnumerable<double> wds, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiSgdUpdate(lrs, wds, data, rescaleGrad, clipGradient, numWeights);
		}

		public static NDArray[] MultiSgdMomUpdate(params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, double momentum = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_sgd_mom_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004017343_002D784();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[6]
			{
				"lrs",
				"wds",
				"momentum",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[6];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array2[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array2[1] = (string)obj3;
			object obj5 = momentum;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array2[2] = (string)obj6;
			object obj8 = rescaleGrad;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable7 = obj8 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array2[3] = (string)obj9;
			object obj11 = clipGradient;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable9 = obj11 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array2[4] = (string)obj12;
			object obj14 = numWeights;
			object obj15;
			if (obj14 != null)
			{
				IFormattable formattable11 = obj14 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = obj14;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array2[5] = (string)obj15;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.MultiSgdMomUpdate_004017346();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void MultiSgdMomUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, double momentum = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_sgd_mom_update");
			string[] names2 = new string[6]
			{
				"lrs",
				"wds",
				"momentum",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[6];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5 = momentum;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			object obj8 = rescaleGrad;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable7 = obj8 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array[3] = (string)obj9;
			object obj11 = clipGradient;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable9 = obj11 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			object obj14 = numWeights;
			object obj15;
			if (obj14 != null)
			{
				IFormattable formattable11 = obj14 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = obj14;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array[5] = (string)obj15;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiSgdMomUpdate_004017387_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004017389_002D785();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004017390_002D786(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiSgdMomUpdate MultiSgdMomUpdate(IEnumerable<Symbol> data, IEnumerable<double> lrs, IEnumerable<double> wds, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiSgdMomUpdate(data, lrs, wds, momentum, rescaleGrad, clipGradient, numWeights);
		}

		public static SymbolOperators.MultiSgdMomUpdate MultiSgdMomUpdate(IEnumerable<double> lrs, IEnumerable<double> wds, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiSgdMomUpdate(lrs, wds, data, momentum, rescaleGrad, clipGradient, numWeights);
		}

		public static NDArray[] MultiMpSgdUpdate(params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_mp_sgd_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004017478_002D787();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[5]
			{
				"lrs",
				"wds",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[5];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array2[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array2[1] = (string)obj3;
			object obj5 = rescaleGrad;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array2[2] = (string)obj6;
			object obj8 = clipGradient;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable7 = obj8 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array2[3] = (string)obj9;
			object obj11 = numWeights;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable9 = obj11 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array2[4] = (string)obj12;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.MultiMpSgdUpdate_004017481();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void MultiMpSgdUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_mp_sgd_update");
			string[] names2 = new string[5]
			{
				"lrs",
				"wds",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[5];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5 = rescaleGrad;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			object obj8 = clipGradient;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable7 = obj8 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array[3] = (string)obj9;
			object obj11 = numWeights;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable9 = obj11 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiMpSgdUpdate_004017508_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004017510_002D788();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004017511_002D789(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiMpSgdUpdate MultiMpSgdUpdate(IEnumerable<Symbol> data, IEnumerable<double> lrs, IEnumerable<double> wds, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiMpSgdUpdate(data, lrs, wds, rescaleGrad, clipGradient, numWeights);
		}

		public static SymbolOperators.MultiMpSgdUpdate MultiMpSgdUpdate(IEnumerable<double> lrs, IEnumerable<double> wds, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiMpSgdUpdate(lrs, wds, data, rescaleGrad, clipGradient, numWeights);
		}

		public static NDArray[] MultiMpSgdMomUpdate(params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, double momentum = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_mp_sgd_mom_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004017587_002D790();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[6]
			{
				"lrs",
				"wds",
				"momentum",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array2 = new string[6];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array2[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array2[1] = (string)obj3;
			object obj5 = momentum;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array2[2] = (string)obj6;
			object obj8 = rescaleGrad;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable7 = obj8 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array2[3] = (string)obj9;
			object obj11 = clipGradient;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable9 = obj11 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array2[4] = (string)obj12;
			object obj14 = numWeights;
			object obj15;
			if (obj14 != null)
			{
				IFormattable formattable11 = obj14 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = obj14;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array2[5] = (string)obj15;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.MultiMpSgdMomUpdate_004017590();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void MultiMpSgdMomUpdate(IEnumerable<NDArray> outputArray, params NDArray[] data, IEnumerable<double> lrs, IEnumerable<double> wds, double momentum = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, int numWeights = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("multi_mp_sgd_mom_update");
			string[] names2 = new string[6]
			{
				"lrs",
				"wds",
				"momentum",
				"rescale_grad",
				"clip_gradient",
				"num_weights"
			};
			string[] array = new string[6];
			object obj;
			if (lrs != null)
			{
				IFormattable formattable = lrs as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = lrs;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (wds != null)
			{
				IFormattable formattable3 = wds as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = wds;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5 = momentum;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			object obj8 = rescaleGrad;
			object obj9;
			if (obj8 != null)
			{
				IFormattable formattable7 = obj8 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj10 = obj8;
					obj9 = obj10.ToString();
				}
			}
			else
			{
				obj9 = "";
			}
			array[3] = (string)obj9;
			object obj11 = clipGradient;
			object obj12;
			if (obj11 != null)
			{
				IFormattable formattable9 = obj11 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = obj11;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			object obj14 = numWeights;
			object obj15;
			if (obj14 != null)
			{
				IFormattable formattable11 = obj14 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = obj14;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array[5] = (string)obj15;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MultiMpSgdMomUpdate_004017631_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004017633_002D791();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004017634_002D792(), outputArray)), names, vals);
		}

		public static SymbolOperators.MultiMpSgdMomUpdate MultiMpSgdMomUpdate(IEnumerable<Symbol> data, IEnumerable<double> lrs, IEnumerable<double> wds, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiMpSgdMomUpdate(data, lrs, wds, momentum, rescaleGrad, clipGradient, numWeights);
		}

		public static SymbolOperators.MultiMpSgdMomUpdate MultiMpSgdMomUpdate(IEnumerable<double> lrs, IEnumerable<double> wds, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<int> numWeights)
		{
			return new SymbolOperators.MultiMpSgdMomUpdate(lrs, wds, data, momentum, rescaleGrad, clipGradient, numWeights);
		}

		public static NDArray SgdUpdate(NDArray weight, NDArray grad, double lr, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sgd_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004017730_002D793(weight, grad, 0, current));
			string[] parameterKeys = new string[5]
			{
				"lr",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = wd;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = rescaleGrad;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = clipGradient;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag = lazyUpdate;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SgdUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, double lr, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sgd_update");
			string[] names2 = new string[5]
			{
				"lr",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = wd;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = rescaleGrad;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = clipGradient;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag = lazyUpdate;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SgdUpdate_004017768(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004017770_002D794(weight, grad, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004017771_002D795(), outputArray)), names, vals);
		}

		public static SymbolOperators.SgdUpdate SgdUpdate(Symbol weight, Symbol grad, double lr, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.SgdUpdate(weight, grad, lr, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static SymbolOperators.SgdUpdate SgdUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.SgdUpdate(lr, weight, grad, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static NDArray SgdMomUpdate(NDArray weight, NDArray grad, NDArray mom, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sgd_mom_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004017873_002D796(weight, grad, mom, 0, current));
			string[] parameterKeys = new string[6]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[6];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			bool flag = lazyUpdate;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SgdMomUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mom, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sgd_mom_update");
			string[] names2 = new string[6]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[6];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			bool flag = lazyUpdate;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SgdMomUpdate_004017929(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004017931_002D797(weight, grad, mom, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004017932_002D798(), outputArray)), names, vals);
		}

		public static SymbolOperators.SgdMomUpdate SgdMomUpdate(Symbol weight, Symbol grad, Symbol mom, double lr, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.SgdMomUpdate(weight, grad, mom, lr, momentum, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static SymbolOperators.SgdMomUpdate SgdMomUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mom, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.SgdMomUpdate(lr, weight, grad, mom, momentum, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static NDArray MpSgdUpdate(NDArray weight, NDArray grad, NDArray weight32, double lr, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("mp_sgd_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018036_002D799(weight, grad, weight32, 0, current));
			string[] parameterKeys = new string[5]
			{
				"lr",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = wd;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = rescaleGrad;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = clipGradient;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag = lazyUpdate;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MpSgdUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray weight32, double lr, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("mp_sgd_update");
			string[] names2 = new string[5]
			{
				"lr",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = wd;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = rescaleGrad;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = clipGradient;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag = lazyUpdate;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MpSgdUpdate_004018062(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018064_002D800(weight, grad, weight32, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004018065_002D801(), outputArray)), names, vals);
		}

		public static SymbolOperators.MpSgdUpdate MpSgdUpdate(Symbol weight, Symbol grad, Symbol weight32, double lr, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.MpSgdUpdate(weight, grad, weight32, lr, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static SymbolOperators.MpSgdUpdate MpSgdUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> weight32, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.MpSgdUpdate(lr, weight, grad, weight32, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static NDArray MpSgdMomUpdate(NDArray weight, NDArray grad, NDArray mom, NDArray weight32, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("mp_sgd_mom_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018115_002D802(weight, grad, mom, weight32, 0, current));
			string[] parameterKeys = new string[6]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[6];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			bool flag = lazyUpdate;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MpSgdMomUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mom, NDArray weight32, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("mp_sgd_mom_update");
			string[] names2 = new string[6]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[6];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			bool flag = lazyUpdate;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MpSgdMomUpdate_004018145(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018147_002D803(weight, grad, mom, weight32, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004018148_002D804(), outputArray)), names, vals);
		}

		public static SymbolOperators.MpSgdMomUpdate MpSgdMomUpdate(Symbol weight, Symbol grad, Symbol mom, Symbol weight32, double lr, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.MpSgdMomUpdate(weight, grad, mom, weight32, lr, momentum, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static SymbolOperators.MpSgdMomUpdate MpSgdMomUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mom, [Optional] [OptionalArgument] FSharpOption<Symbol> weight32, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.MpSgdMomUpdate(lr, weight, grad, mom, weight32, momentum, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static NDArray FtmlUpdate(NDArray weight, NDArray grad, NDArray d, NDArray v, NDArray z, double lr, int t, double beta1 = 0.6, double beta2 = 0.999, double epsilon = 1E-08, double wd = 0.0, double rescaleGrad = 1.0, double clipGrad = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ftml_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018223_002D805(weight, grad, d, v, z, 0, current));
			string[] parameterKeys = new string[8]
			{
				"lr",
				"t",
				"beta1",
				"beta2",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_grad"
			};
			string[] array = new string[8];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = t;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = wd;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = rescaleGrad;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			object obj22 = clipGrad;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void FtmlUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray d, NDArray v, NDArray z, double lr, int t, double beta1 = 0.6, double beta2 = 0.999, double epsilon = 1E-08, double wd = 0.0, double rescaleGrad = 1.0, double clipGrad = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ftml_update");
			string[] names2 = new string[8]
			{
				"lr",
				"t",
				"beta1",
				"beta2",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_grad"
			};
			string[] array = new string[8];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = t;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = wd;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = rescaleGrad;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			object obj22 = clipGrad;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.FtmlUpdate_004018274(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018276_002D806(weight, grad, d, v, z, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004018277_002D807(), outputArray)), names, vals);
		}

		public static SymbolOperators.FtmlUpdate FtmlUpdate(Symbol weight, Symbol grad, Symbol d, Symbol v, Symbol z, double lr, int t, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGrad)
		{
			return new SymbolOperators.FtmlUpdate(weight, grad, d, v, z, lr, t, beta1, beta2, epsilon, wd, rescaleGrad, clipGrad);
		}

		public static SymbolOperators.FtmlUpdate FtmlUpdate(double lr, int t, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> d, [Optional] [OptionalArgument] FSharpOption<Symbol> v, [Optional] [OptionalArgument] FSharpOption<Symbol> z, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGrad)
		{
			return new SymbolOperators.FtmlUpdate(lr, t, weight, grad, d, v, z, beta1, beta2, epsilon, wd, rescaleGrad, clipGrad);
		}

		public static NDArray AdamUpdate(NDArray weight, NDArray grad, NDArray mean, NDArray var, double lr, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("adam_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018401_002D808(weight, grad, mean, var, 0, current));
			string[] parameterKeys = new string[8]
			{
				"lr",
				"beta1",
				"beta2",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[8];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = beta1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = epsilon;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = wd;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = rescaleGrad;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipGradient;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			bool flag = lazyUpdate;
			object obj22 = flag;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void AdamUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mean, NDArray var, double lr, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-08, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, bool lazyUpdate = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("adam_update");
			string[] names2 = new string[8]
			{
				"lr",
				"beta1",
				"beta2",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"lazy_update"
			};
			string[] array = new string[8];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = beta1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = epsilon;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = wd;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = rescaleGrad;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipGradient;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			bool flag = lazyUpdate;
			object obj22 = flag;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.AdamUpdate_004018465(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018467_002D809(weight, grad, mean, var, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004018468_002D810(), outputArray)), names, vals);
		}

		public static SymbolOperators.AdamUpdate AdamUpdate(Symbol weight, Symbol grad, Symbol mean, Symbol var, double lr, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.AdamUpdate(weight, grad, mean, var, lr, beta1, beta2, epsilon, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static SymbolOperators.AdamUpdate AdamUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mean, [Optional] [OptionalArgument] FSharpOption<Symbol> var, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<bool> lazyUpdate)
		{
			return new SymbolOperators.AdamUpdate(lr, weight, grad, mean, var, beta1, beta2, epsilon, wd, rescaleGrad, clipGradient, lazyUpdate);
		}

		public static NDArray NagMomUpdate(NDArray weight, NDArray grad, NDArray mom, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("nag_mom_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018597_002D811(weight, grad, mom, 0, current));
			string[] parameterKeys = new string[5]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NagMomUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mom, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("nag_mom_update");
			string[] names2 = new string[5]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NagMomUpdate_004018638(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018640_002D812(weight, grad, mom, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004018641_002D813(), outputArray)), names, vals);
		}

		public static SymbolOperators.NagMomUpdate NagMomUpdate(Symbol weight, Symbol grad, Symbol mom, double lr, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.NagMomUpdate(weight, grad, mom, lr, momentum, wd, rescaleGrad, clipGradient);
		}

		public static SymbolOperators.NagMomUpdate NagMomUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mom, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.NagMomUpdate(lr, weight, grad, mom, momentum, wd, rescaleGrad, clipGradient);
		}

		public static NDArray MpNagMomUpdate(NDArray weight, NDArray grad, NDArray mom, NDArray weight32, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("mp_nag_mom_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018722_002D814(weight, grad, mom, weight32, 0, current));
			string[] parameterKeys = new string[5]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MpNagMomUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mom, NDArray weight32, double lr, double momentum = 0.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("mp_nag_mom_update");
			string[] names2 = new string[5]
			{
				"lr",
				"momentum",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = momentum;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MpNagMomUpdate_004018753(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018755_002D815(weight, grad, mom, weight32, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004018756_002D816(), outputArray)), names, vals);
		}

		public static SymbolOperators.MpNagMomUpdate MpNagMomUpdate(Symbol weight, Symbol grad, Symbol mom, Symbol weight32, double lr, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.MpNagMomUpdate(weight, grad, mom, weight32, lr, momentum, wd, rescaleGrad, clipGradient);
		}

		public static SymbolOperators.MpNagMomUpdate MpNagMomUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mom, [Optional] [OptionalArgument] FSharpOption<Symbol> weight32, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.MpNagMomUpdate(lr, weight, grad, mom, weight32, momentum, wd, rescaleGrad, clipGradient);
		}

		public static NDArray RmspropUpdate(NDArray weight, NDArray grad, NDArray n, double lr, double gamma1 = 0.95, double epsilon = 1E-08, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, double clipWeights = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rmsprop_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018849_002D817(weight, grad, n, 0, current));
			string[] parameterKeys = new string[7]
			{
				"lr",
				"gamma1",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"clip_weights"
			};
			string[] array = new string[7];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = gamma1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = epsilon;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = wd;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = rescaleGrad;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = clipGradient;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipWeights;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RmspropUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray n, double lr, double gamma1 = 0.95, double epsilon = 1E-08, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, double clipWeights = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rmsprop_update");
			string[] names2 = new string[7]
			{
				"lr",
				"gamma1",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"clip_weights"
			};
			string[] array = new string[7];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = gamma1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = epsilon;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = wd;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = rescaleGrad;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = clipGradient;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipWeights;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RmspropUpdate_004018914(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004018916_002D818(weight, grad, n, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004018917_002D819(), outputArray)), names, vals);
		}

		public static SymbolOperators.RmspropUpdate RmspropUpdate(Symbol weight, Symbol grad, Symbol n, double lr, [Optional] [OptionalArgument] FSharpOption<double> gamma1, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<double> clipWeights)
		{
			return new SymbolOperators.RmspropUpdate(weight, grad, n, lr, gamma1, epsilon, wd, rescaleGrad, clipGradient, clipWeights);
		}

		public static SymbolOperators.RmspropUpdate RmspropUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> n, [Optional] [OptionalArgument] FSharpOption<double> gamma1, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<double> clipWeights)
		{
			return new SymbolOperators.RmspropUpdate(lr, weight, grad, n, gamma1, epsilon, wd, rescaleGrad, clipGradient, clipWeights);
		}

		public static NDArray RmspropalexUpdate(NDArray weight, NDArray grad, NDArray n, NDArray g, NDArray delta, double lr, double gamma1 = 0.95, double gamma2 = 0.9, double epsilon = 1E-08, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, double clipWeights = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rmspropalex_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019071_002D820(weight, grad, n, g, delta, 0, current));
			string[] parameterKeys = new string[8]
			{
				"lr",
				"gamma1",
				"gamma2",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"clip_weights"
			};
			string[] array = new string[8];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = gamma1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = gamma2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = epsilon;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = wd;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = rescaleGrad;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipGradient;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			object obj22 = clipWeights;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RmspropalexUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray n, NDArray g, NDArray delta, double lr, double gamma1 = 0.95, double gamma2 = 0.9, double epsilon = 1E-08, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0, double clipWeights = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rmspropalex_update");
			string[] names2 = new string[8]
			{
				"lr",
				"gamma1",
				"gamma2",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_gradient",
				"clip_weights"
			};
			string[] array = new string[8];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = gamma1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = gamma2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = epsilon;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = wd;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = rescaleGrad;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = clipGradient;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			object obj22 = clipWeights;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RmspropalexUpdate_004019131(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019133_002D821(weight, grad, n, g, delta, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004019134_002D822(), outputArray)), names, vals);
		}

		public static SymbolOperators.RmspropalexUpdate RmspropalexUpdate(Symbol weight, Symbol grad, Symbol n, Symbol g, Symbol delta, double lr, [Optional] [OptionalArgument] FSharpOption<double> gamma1, [Optional] [OptionalArgument] FSharpOption<double> gamma2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<double> clipWeights)
		{
			return new SymbolOperators.RmspropalexUpdate(weight, grad, n, g, delta, lr, gamma1, gamma2, epsilon, wd, rescaleGrad, clipGradient, clipWeights);
		}

		public static SymbolOperators.RmspropalexUpdate RmspropalexUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> n, [Optional] [OptionalArgument] FSharpOption<Symbol> g, [Optional] [OptionalArgument] FSharpOption<Symbol> delta, [Optional] [OptionalArgument] FSharpOption<double> gamma1, [Optional] [OptionalArgument] FSharpOption<double> gamma2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient, [Optional] [OptionalArgument] FSharpOption<double> clipWeights)
		{
			return new SymbolOperators.RmspropalexUpdate(lr, weight, grad, n, g, delta, gamma1, gamma2, epsilon, wd, rescaleGrad, clipGradient, clipWeights);
		}

		public static NDArray FtrlUpdate(NDArray weight, NDArray grad, NDArray z, NDArray n, double lr, double lamda1 = 0.01, double beta = 1.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ftrl_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019264_002D823(weight, grad, z, n, 0, current));
			string[] parameterKeys = new string[6]
			{
				"lr",
				"lamda1",
				"beta",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[6];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = lamda1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = wd;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = rescaleGrad;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = clipGradient;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void FtrlUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray z, NDArray n, double lr, double lamda1 = 0.01, double beta = 1.0, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ftrl_update");
			string[] names2 = new string[6]
			{
				"lr",
				"lamda1",
				"beta",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[6];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = lamda1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = wd;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = rescaleGrad;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = clipGradient;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.FtrlUpdate_004019316(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019318_002D824(weight, grad, z, n, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004019319_002D825(), outputArray)), names, vals);
		}

		public static SymbolOperators.FtrlUpdate FtrlUpdate(Symbol weight, Symbol grad, Symbol z, Symbol n, double lr, [Optional] [OptionalArgument] FSharpOption<double> lamda1, [Optional] [OptionalArgument] FSharpOption<double> beta, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.FtrlUpdate(weight, grad, z, n, lr, lamda1, beta, wd, rescaleGrad, clipGradient);
		}

		public static SymbolOperators.FtrlUpdate FtrlUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> z, [Optional] [OptionalArgument] FSharpOption<Symbol> n, [Optional] [OptionalArgument] FSharpOption<double> lamda1, [Optional] [OptionalArgument] FSharpOption<double> beta, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.FtrlUpdate(lr, weight, grad, z, n, lamda1, beta, wd, rescaleGrad, clipGradient);
		}

		public static NDArray SparseAdagradUpdate(NDArray weight, NDArray grad, NDArray history, double lr, double epsilon = 1E-07, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sparse_adagrad_update");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019428_002D826(weight, grad, history, 0, current));
			string[] parameterKeys = new string[5]
			{
				"lr",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = epsilon;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SparseAdagradUpdate(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray history, double lr, double epsilon = 1E-07, double wd = 0.0, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sparse_adagrad_update");
			string[] names2 = new string[5]
			{
				"lr",
				"epsilon",
				"wd",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[5];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = epsilon;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = wd;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rescaleGrad;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = clipGradient;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SparseAdagradUpdate_004019469(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019471_002D827(weight, grad, history, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004019472_002D828(), outputArray)), names, vals);
		}

		public static SymbolOperators.SparseAdagradUpdate SparseAdagradUpdate(Symbol weight, Symbol grad, Symbol history, double lr, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.SparseAdagradUpdate(weight, grad, history, lr, epsilon, wd, rescaleGrad, clipGradient);
		}

		public static SymbolOperators.SparseAdagradUpdate SparseAdagradUpdate(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> history, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<double> wd, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.SparseAdagradUpdate(lr, weight, grad, history, epsilon, wd, rescaleGrad, clipGradient);
		}

		public static NDArray[] LambUpdatePhase1(NDArray weight, NDArray grad, NDArray mean, NDArray var, double t, double wd, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-06, bool biasCorrection = true, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("lamb_update_phase1");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019584_002D829(weight, grad, mean, var, 0, current));
			string[] parameterKeys = new string[8]
			{
				"t",
				"wd",
				"beta1",
				"beta2",
				"epsilon",
				"bias_correction",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[8];
			object obj = t;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = wd;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			bool flag = biasCorrection;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = rescaleGrad;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			object obj22 = clipGradient;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.LambUpdatePhase1_004019587();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void LambUpdatePhase1(IEnumerable<NDArray> outputArray, NDArray weight, NDArray grad, NDArray mean, NDArray var, double t, double wd, double beta1 = 0.9, double beta2 = 0.999, double epsilon = 1E-06, bool biasCorrection = true, double rescaleGrad = 1.0, double clipGradient = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("lamb_update_phase1");
			string[] names2 = new string[8]
			{
				"t",
				"wd",
				"beta1",
				"beta2",
				"epsilon",
				"bias_correction",
				"rescale_grad",
				"clip_gradient"
			};
			string[] array = new string[8];
			object obj = t;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = wd;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = beta1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = epsilon;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			bool flag = biasCorrection;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = rescaleGrad;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			object obj22 = clipGradient;
			object obj23;
			if (obj22 != null)
			{
				IFormattable formattable15 = obj22 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj23 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj24 = obj22;
					obj23 = obj24.ToString();
				}
			}
			else
			{
				obj23 = "";
			}
			array[7] = (string)obj23;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LambUpdatePhase1_004019646_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019648_002D830(weight, grad, mean, var, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004019649_002D831(), outputArray)), names, vals);
		}

		public static SymbolOperators.LambUpdatePhase1 LambUpdatePhase1(Symbol weight, Symbol grad, Symbol mean, Symbol var, double t, double wd, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<bool> biasCorrection, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.LambUpdatePhase1(weight, grad, mean, var, t, wd, beta1, beta2, epsilon, biasCorrection, rescaleGrad, clipGradient);
		}

		public static SymbolOperators.LambUpdatePhase1 LambUpdatePhase1(double t, double wd, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> grad, [Optional] [OptionalArgument] FSharpOption<Symbol> mean, [Optional] [OptionalArgument] FSharpOption<Symbol> var, [Optional] [OptionalArgument] FSharpOption<double> beta1, [Optional] [OptionalArgument] FSharpOption<double> beta2, [Optional] [OptionalArgument] FSharpOption<double> epsilon, [Optional] [OptionalArgument] FSharpOption<bool> biasCorrection, [Optional] [OptionalArgument] FSharpOption<double> rescaleGrad, [Optional] [OptionalArgument] FSharpOption<double> clipGradient)
		{
			return new SymbolOperators.LambUpdatePhase1(t, wd, weight, grad, mean, var, beta1, beta2, epsilon, biasCorrection, rescaleGrad, clipGradient);
		}

		public static NDArray[] LambUpdatePhase2(NDArray weight, NDArray g, NDArray r1, NDArray r2, double lr, double lowerBound = -1.0, double upperBound = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("lamb_update_phase2");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019780_002D832(weight, g, r1, r2, 0, current));
			string[] parameterKeys = new string[3]
			{
				"lr",
				"lower_bound",
				"upper_bound"
			};
			string[] array = new string[3];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = lowerBound;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = upperBound;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.LambUpdatePhase2_004019783();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void LambUpdatePhase2(IEnumerable<NDArray> outputArray, NDArray weight, NDArray g, NDArray r1, NDArray r2, double lr, double lowerBound = -1.0, double upperBound = -1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("lamb_update_phase2");
			string[] names2 = new string[3]
			{
				"lr",
				"lower_bound",
				"upper_bound"
			};
			string[] array = new string[3];
			object obj = lr;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = lowerBound;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = upperBound;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LambUpdatePhase2_004019827_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019829_002D833(weight, g, r1, r2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004019830_002D834(), outputArray)), names, vals);
		}

		public static SymbolOperators.LambUpdatePhase2 LambUpdatePhase2(Symbol weight, Symbol g, Symbol r1, Symbol r2, double lr, [Optional] [OptionalArgument] FSharpOption<double> lowerBound, [Optional] [OptionalArgument] FSharpOption<double> upperBound)
		{
			return new SymbolOperators.LambUpdatePhase2(weight, g, r1, r2, lr, lowerBound, upperBound);
		}

		public static SymbolOperators.LambUpdatePhase2 LambUpdatePhase2(double lr, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> g, [Optional] [OptionalArgument] FSharpOption<Symbol> r1, [Optional] [OptionalArgument] FSharpOption<Symbol> r2, [Optional] [OptionalArgument] FSharpOption<double> lowerBound, [Optional] [OptionalArgument] FSharpOption<double> upperBound)
		{
			return new SymbolOperators.LambUpdatePhase2(lr, weight, g, r1, r2, lowerBound, upperBound);
		}

		public static NDArray[] Pad(NDArray data, GeneratedArgumentTypes.PadMode mode, IEnumerable<int> padWidth, double constantValue = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Pad");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004019992_002D835(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"mode",
				"pad_width",
				"constant_value"
			};
			string[] array = new string[3];
			object obj;
			if (mode != null)
			{
				IFormattable formattable = mode as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = mode;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004019994_002D836(), padWidth));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[1] = val.Invoke(text2);
			object obj3 = constantValue;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.Pad_004019995();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void Pad(IEnumerable<NDArray> outputArray, NDArray data, GeneratedArgumentTypes.PadMode mode, IEnumerable<int> padWidth, double constantValue = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Pad");
			string[] names2 = new string[3]
			{
				"mode",
				"pad_width",
				"constant_value"
			};
			string[] array = new string[3];
			object obj;
			if (mode != null)
			{
				IFormattable formattable = mode as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = mode;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004020088_002D145(), padWidth));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[1] = val.Invoke(text2);
			object obj3 = constantValue;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Pad_004020089_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020091_002D837(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020092_002D838(), outputArray)), names, vals);
		}

		public static SymbolOperators.Pad Pad(Symbol data, GeneratedArgumentTypes.PadMode mode, IEnumerable<int> padWidth, [Optional] [OptionalArgument] FSharpOption<double> constantValue)
		{
			return new SymbolOperators.Pad(data, mode, padWidth, constantValue);
		}

		public static SymbolOperators.Pad Pad(GeneratedArgumentTypes.PadMode mode, IEnumerable<int> padWidth, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> constantValue)
		{
			return new SymbolOperators.Pad(mode, padWidth, data, constantValue);
		}

		public static Tuple<NDArray, NDArray> ContribCalibrateEntropy(NDArray hist, NDArray histEdges, int numQuantizedBins = 255)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_calibrate_entropy");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020289_002D839(hist, histEdges, 0, current));
			string[] parameterKeys = new string[1]
			{
				"num_quantized_bins"
			};
			string[] array = new string[1];
			object obj = numQuantizedBins;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void ContribCalibrateEntropy(IEnumerable<NDArray> outputArray, NDArray hist, NDArray histEdges, int numQuantizedBins = 255)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_calibrate_entropy");
			string[] names2 = new string[1]
			{
				"num_quantized_bins"
			};
			string[] array = new string[1];
			object obj = numQuantizedBins;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribCalibrateEntropy_004020307(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020309_002D840(hist, histEdges, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020310_002D841(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribCalibrateEntropy ContribCalibrateEntropy([Optional] [OptionalArgument] FSharpOption<Symbol> hist, [Optional] [OptionalArgument] FSharpOption<Symbol> histEdges, [Optional] [OptionalArgument] FSharpOption<int> numQuantizedBins)
		{
			return new SymbolOperators.ContribCalibrateEntropy(hist, histEdges, numQuantizedBins);
		}

		public static NDArray ContribDequantize(NDArray data, NDArray minRange, NDArray maxRange, [Optional] GeneratedArgumentTypes.ContribDequantizeOutType outType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dequantize");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020351_002D842(data, minRange, maxRange, 0, current));
			string[] parameterKeys = new string[1]
			{
				"out_type"
			};
			string[] array = new string[1];
			object obj;
			if ((outType == null) ? true : false)
			{
				obj = "float32";
			}
			else if (outType != null)
			{
				IFormattable formattable = outType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = outType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribDequantize(IEnumerable<NDArray> outputArray, NDArray data, NDArray minRange, NDArray maxRange, [Optional] GeneratedArgumentTypes.ContribDequantizeOutType outType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_dequantize");
			string[] names2 = new string[1]
			{
				"out_type"
			};
			string[] array = new string[1];
			object obj;
			if ((outType == null) ? true : false)
			{
				obj = "float32";
			}
			else if (outType != null)
			{
				IFormattable formattable = outType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = outType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribDequantize_004020382(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020384_002D843(data, minRange, maxRange, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020385_002D844(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribDequantize ContribDequantize([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> minRange, [Optional] [OptionalArgument] FSharpOption<Symbol> maxRange, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribDequantizeOutType> outType)
		{
			return new SymbolOperators.ContribDequantize(data, minRange, maxRange, outType);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantizedAct(NDArray data, NDArray minData, NDArray maxData, GeneratedArgumentTypes.ActType actType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_act");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020430_002D845(data, minData, maxData, 0, current));
			string[] parameterKeys = new string[1]
			{
				"act_type"
			};
			string[] array = new string[1];
			object obj;
			if (actType != null)
			{
				IFormattable formattable = actType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = actType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantizedAct(IEnumerable<NDArray> outputArray, NDArray data, NDArray minData, NDArray maxData, GeneratedArgumentTypes.ActType actType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_act");
			string[] names2 = new string[1]
			{
				"act_type"
			};
			string[] array = new string[1];
			object obj;
			if (actType != null)
			{
				IFormattable formattable = actType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = actType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizedAct_004020452(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020454_002D846(data, minData, maxData, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020455_002D847(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizedAct ContribQuantizedAct(Symbol data, Symbol minData, Symbol maxData, GeneratedArgumentTypes.ActType actType)
		{
			return new SymbolOperators.ContribQuantizedAct(data, minData, maxData, actType);
		}

		public static SymbolOperators.ContribQuantizedAct ContribQuantizedAct(GeneratedArgumentTypes.ActType actType, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> minData, [Optional] [OptionalArgument] FSharpOption<Symbol> maxData)
		{
			return new SymbolOperators.ContribQuantizedAct(actType, data, minData, maxData);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantizedBatchNorm(NDArray data, NDArray gamma, NDArray beta, NDArray movingMean, NDArray movingVar, NDArray minData, NDArray maxData, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_batch_norm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020533_002D848(data, gamma, beta, movingMean, movingVar, minData, maxData, 0, current));
			string[] parameterKeys = new string[9]
			{
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var",
				"axis",
				"cudnn_off",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[9];
			object obj;
			if (eps == null)
			{
				obj = "0.001";
			}
			else
			{
				FSharpOption<double> val = eps;
				double eps2 = val.get_Value();
				double num = eps2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (momentum == null)
			{
				obj4 = "0.9";
			}
			else
			{
				FSharpOption<double> val2 = momentum;
				double momentum2 = val2.get_Value();
				double num2 = momentum2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (fixGamma == null)
			{
				obj7 = "true";
			}
			else
			{
				FSharpOption<bool> val3 = fixGamma;
				bool fixGamma2 = val3.get_Value();
				bool flag = fixGamma2;
				object obj8 = flag;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useGlobalStats == null)
			{
				obj10 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = useGlobalStats;
				bool useGlobalStats2 = val4.get_Value();
				bool flag2 = useGlobalStats2;
				object obj11 = flag2;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (outputMeanVar == null)
			{
				obj13 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = outputMeanVar;
				bool outputMeanVar2 = val5.get_Value();
				bool flag3 = outputMeanVar2;
				object obj14 = flag3;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			object obj16;
			if (axis == null)
			{
				obj16 = "1";
			}
			else
			{
				FSharpOption<int> val6 = axis;
				int axis2 = val6.get_Value();
				int num3 = axis2;
				object obj17 = num3;
				if (obj17 != null)
				{
					IFormattable formattable11 = obj17 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[5] = (string)obj16;
			object obj19;
			if (cudnnOff == null)
			{
				obj19 = "false";
			}
			else
			{
				FSharpOption<bool> val7 = cudnnOff;
				bool cudnnOff2 = val7.get_Value();
				bool flag4 = cudnnOff2;
				object obj20 = flag4;
				if (obj20 != null)
				{
					IFormattable formattable13 = obj20 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[6] = (string)obj19;
			object obj22;
			if (minCalibRange == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<double> val8 = minCalibRange;
				double minCalibRange2 = val8.get_Value();
				double num4 = minCalibRange2;
				object obj23 = num4;
				if (obj23 != null)
				{
					IFormattable formattable15 = obj23 as IFormattable;
					if (formattable15 != null)
					{
						IFormattable formattable16 = formattable15;
						obj22 = formattable16.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[7] = (string)obj22;
			object obj25;
			if (maxCalibRange == null)
			{
				obj25 = "None";
			}
			else
			{
				FSharpOption<double> val9 = maxCalibRange;
				double maxCalibRange2 = val9.get_Value();
				double num5 = maxCalibRange2;
				object obj26 = num5;
				if (obj26 != null)
				{
					IFormattable formattable17 = obj26 as IFormattable;
					if (formattable17 != null)
					{
						IFormattable formattable18 = formattable17;
						obj25 = formattable18.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj27 = obj26;
						obj25 = obj27.ToString();
					}
				}
				else
				{
					obj25 = "";
				}
			}
			array[8] = (string)obj25;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantizedBatchNorm(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, NDArray beta, NDArray movingMean, NDArray movingVar, NDArray minData, NDArray maxData, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_batch_norm");
			string[] names2 = new string[9]
			{
				"eps",
				"momentum",
				"fix_gamma",
				"use_global_stats",
				"output_mean_var",
				"axis",
				"cudnn_off",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[9];
			object obj;
			if (eps == null)
			{
				obj = "0.001";
			}
			else
			{
				FSharpOption<double> val = eps;
				double eps2 = val.get_Value();
				double num = eps2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (momentum == null)
			{
				obj4 = "0.9";
			}
			else
			{
				FSharpOption<double> val2 = momentum;
				double momentum2 = val2.get_Value();
				double num2 = momentum2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (fixGamma == null)
			{
				obj7 = "true";
			}
			else
			{
				FSharpOption<bool> val3 = fixGamma;
				bool fixGamma2 = val3.get_Value();
				bool flag = fixGamma2;
				object obj8 = flag;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (useGlobalStats == null)
			{
				obj10 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = useGlobalStats;
				bool useGlobalStats2 = val4.get_Value();
				bool flag2 = useGlobalStats2;
				object obj11 = flag2;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (outputMeanVar == null)
			{
				obj13 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = outputMeanVar;
				bool outputMeanVar2 = val5.get_Value();
				bool flag3 = outputMeanVar2;
				object obj14 = flag3;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			object obj16;
			if (axis == null)
			{
				obj16 = "1";
			}
			else
			{
				FSharpOption<int> val6 = axis;
				int axis2 = val6.get_Value();
				int num3 = axis2;
				object obj17 = num3;
				if (obj17 != null)
				{
					IFormattable formattable11 = obj17 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[5] = (string)obj16;
			object obj19;
			if (cudnnOff == null)
			{
				obj19 = "false";
			}
			else
			{
				FSharpOption<bool> val7 = cudnnOff;
				bool cudnnOff2 = val7.get_Value();
				bool flag4 = cudnnOff2;
				object obj20 = flag4;
				if (obj20 != null)
				{
					IFormattable formattable13 = obj20 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[6] = (string)obj19;
			object obj22;
			if (minCalibRange == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<double> val8 = minCalibRange;
				double minCalibRange2 = val8.get_Value();
				double num4 = minCalibRange2;
				object obj23 = num4;
				if (obj23 != null)
				{
					IFormattable formattable15 = obj23 as IFormattable;
					if (formattable15 != null)
					{
						IFormattable formattable16 = formattable15;
						obj22 = formattable16.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[7] = (string)obj22;
			object obj25;
			if (maxCalibRange == null)
			{
				obj25 = "None";
			}
			else
			{
				FSharpOption<double> val9 = maxCalibRange;
				double maxCalibRange2 = val9.get_Value();
				double num5 = maxCalibRange2;
				object obj26 = num5;
				if (obj26 != null)
				{
					IFormattable formattable17 = obj26 as IFormattable;
					if (formattable17 != null)
					{
						IFormattable formattable18 = formattable17;
						obj25 = formattable18.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj27 = obj26;
						obj25 = obj27.ToString();
					}
				}
				else
				{
					obj25 = "";
				}
			}
			array[8] = (string)obj25;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizedBatchNorm_004020583(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020585_002D849(data, gamma, beta, movingMean, movingVar, minData, maxData, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020586_002D850(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizedBatchNorm ContribQuantizedBatchNorm([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<Symbol> movingMean, [Optional] [OptionalArgument] FSharpOption<Symbol> movingVar, [Optional] [OptionalArgument] FSharpOption<Symbol> minData, [Optional] [OptionalArgument] FSharpOption<Symbol> maxData, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<double> momentum, [Optional] [OptionalArgument] FSharpOption<bool> fixGamma, [Optional] [OptionalArgument] FSharpOption<bool> useGlobalStats, [Optional] [OptionalArgument] FSharpOption<bool> outputMeanVar, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			return new SymbolOperators.ContribQuantizedBatchNorm(data, gamma, beta, movingMean, movingVar, minData, maxData, eps, momentum, fixGamma, useGlobalStats, outputMeanVar, axis, cudnnOff, minCalibRange, maxCalibRange);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantizedConcat(params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_concat");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004020636_002D851();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array2 = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantizedConcat(IEnumerable<NDArray> outputArray, params NDArray[] data, int dim = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_concat");
			string[] names2 = new string[2]
			{
				"num_args",
				"dim"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = dim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizedConcat_004020660(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004020662_002D852();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020663_002D853(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizedConcat ContribQuantizedConcat([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> dim)
		{
			return new SymbolOperators.ContribQuantizedConcat(data, dim);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantizedConv(NDArray data, NDArray weight, NDArray bias, NDArray minData, NDArray maxData, NDArray minWeight, NDArray maxWeight, NDArray minBias, NDArray maxBias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, long workspace = 1024L, bool noBias = false, [Optional] GeneratedArgumentTypes.CudnnTune cudnnTune, bool cudnnOff = false, [Optional] GeneratedArgumentTypes.ContribQuantizedConvLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_conv");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020737_002D854(data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, 0, current));
			string[] parameterKeys = new string[11]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"workspace",
				"no_bias",
				"cudnn_tune",
				"cudnn_off",
				"layout"
			};
			string[] array = new string[11];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004020739_002D855(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004020739_002D856(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004020739_002D857(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004020739_002D858(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = workspace;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			bool flag = noBias;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			object obj16;
			if ((cudnnTune == null) ? true : false)
			{
				obj16 = "None";
			}
			else if (cudnnTune != null)
			{
				IFormattable formattable9 = cudnnTune as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = cudnnTune;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[8] = (string)obj16;
			bool flag2 = cudnnOff;
			object obj18 = flag2;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable11 = obj18 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[9] = (string)obj19;
			object obj21;
			if ((layout == null) ? true : false)
			{
				obj21 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj21 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = layout;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[10] = (string)obj21;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantizedConv(IEnumerable<NDArray> outputArray, NDArray data, NDArray weight, NDArray bias, NDArray minData, NDArray maxData, NDArray minWeight, NDArray maxWeight, NDArray minBias, NDArray maxBias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, long workspace = 1024L, bool noBias = false, [Optional] GeneratedArgumentTypes.CudnnTune cudnnTune, bool cudnnOff = false, [Optional] GeneratedArgumentTypes.ContribQuantizedConvLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_conv");
			string[] names2 = new string[11]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"workspace",
				"no_bias",
				"cudnn_tune",
				"cudnn_off",
				"layout"
			};
			string[] array = new string[11];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004020796_002D146(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004020796_002D147(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004020796_002D148(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004020796_002D149(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = workspace;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			bool flag = noBias;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			object obj16;
			if ((cudnnTune == null) ? true : false)
			{
				obj16 = "None";
			}
			else if (cudnnTune != null)
			{
				IFormattable formattable9 = cudnnTune as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = cudnnTune;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[8] = (string)obj16;
			bool flag2 = cudnnOff;
			object obj18 = flag2;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable11 = obj18 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[9] = (string)obj19;
			object obj21;
			if ((layout == null) ? true : false)
			{
				obj21 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj21 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = layout;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[10] = (string)obj21;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizedConv_004020797(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020799_002D859(data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020800_002D860(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizedConv ContribQuantizedConv(Symbol data, Symbol weight, Symbol bias, Symbol minData, Symbol maxData, Symbol minWeight, Symbol maxWeight, Symbol minBias, Symbol maxBias, IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.CudnnTune> cudnnTune, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizedConvLayout> layout)
		{
			return new SymbolOperators.ContribQuantizedConv(data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, kernel, numFilter, stride, dilate, pad, numGroup, workspace, noBias, cudnnTune, cudnnOff, layout);
		}

		public static SymbolOperators.ContribQuantizedConv ContribQuantizedConv(IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> bias, [Optional] [OptionalArgument] FSharpOption<Symbol> minData, [Optional] [OptionalArgument] FSharpOption<Symbol> maxData, [Optional] [OptionalArgument] FSharpOption<Symbol> minWeight, [Optional] [OptionalArgument] FSharpOption<Symbol> maxWeight, [Optional] [OptionalArgument] FSharpOption<Symbol> minBias, [Optional] [OptionalArgument] FSharpOption<Symbol> maxBias, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.CudnnTune> cudnnTune, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizedConvLayout> layout)
		{
			return new SymbolOperators.ContribQuantizedConv(kernel, numFilter, data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, stride, dilate, pad, numGroup, workspace, noBias, cudnnTune, cudnnOff, layout);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantizedElemwiseAdd(NDArray lhs, NDArray rhs, NDArray lhsMin, NDArray lhsMax, NDArray rhsMin, NDArray rhsMax, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_elemwise_add");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020899_002D861(lhs, rhs, lhsMin, lhsMax, rhsMin, rhsMax, 0, current));
			string[] parameterKeys = new string[2]
			{
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[2];
			object obj;
			if (minCalibRange == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<double> val = minCalibRange;
				double minCalibRange2 = val.get_Value();
				double num = minCalibRange2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (maxCalibRange == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = maxCalibRange;
				double maxCalibRange2 = val2.get_Value();
				double num2 = maxCalibRange2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantizedElemwiseAdd(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs, NDArray lhsMin, NDArray lhsMax, NDArray rhsMin, NDArray rhsMax, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_elemwise_add");
			string[] names2 = new string[2]
			{
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[2];
			object obj;
			if (minCalibRange == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<double> val = minCalibRange;
				double minCalibRange2 = val.get_Value();
				double num = minCalibRange2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (maxCalibRange == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = maxCalibRange;
				double maxCalibRange2 = val2.get_Value();
				double num2 = maxCalibRange2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizedElemwiseAdd_004020934(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020936_002D862(lhs, rhs, lhsMin, lhsMax, rhsMin, rhsMax, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020937_002D863(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizedElemwiseAdd ContribQuantizedElemwiseAdd([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs, [Optional] [OptionalArgument] FSharpOption<Symbol> lhsMin, [Optional] [OptionalArgument] FSharpOption<Symbol> lhsMax, [Optional] [OptionalArgument] FSharpOption<Symbol> rhsMin, [Optional] [OptionalArgument] FSharpOption<Symbol> rhsMax, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			return new SymbolOperators.ContribQuantizedElemwiseAdd(lhs, rhs, lhsMin, lhsMax, rhsMin, rhsMax, minCalibRange, maxCalibRange);
		}

		public static NDArray[] ContribQuantizedFlatten(NDArray data, NDArray minData, NDArray maxData)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_flatten");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020968_002D864(data, minData, maxData, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribQuantizedFlatten_004020971();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void ContribQuantizedFlatten(IEnumerable<NDArray> outputArray, NDArray data, NDArray minData, NDArray maxData)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_flatten");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004020978_002D93();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004020979_002D150();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizedFlatten_004020980_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004020982_002D865(data, minData, maxData, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004020983_002D866(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizedFlatten ContribQuantizedFlatten([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> minData, [Optional] [OptionalArgument] FSharpOption<Symbol> maxData)
		{
			return new SymbolOperators.ContribQuantizedFlatten(data, minData, maxData);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantizedPooling(NDArray data, NDArray minData, NDArray maxData, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> kernel, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolType> poolType, [Optional] [OptionalArgument] FSharpOption<bool> globalPool, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingConvention> poolingConvention, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> pValue, [Optional] [OptionalArgument] FSharpOption<bool> countIncludePad, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizedPoolingLayout> layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_pooling");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021031_002D867(data, minData, maxData, 0, current));
			string[] parameterKeys = new string[10]
			{
				"kernel",
				"pool_type",
				"global_pool",
				"cudnn_off",
				"pooling_convention",
				"stride",
				"pad",
				"p_value",
				"count_include_pad",
				"layout"
			};
			string[] array = new string[10];
			object obj;
			if (kernel == null)
			{
				obj = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = kernel;
				IEnumerable<int> kernel2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004021033_002D868(), kernel2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (poolType == null)
			{
				obj2 = "max";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolType> val3 = poolType;
				GeneratedArgumentTypes.PoolType poolType2 = val3.get_Value();
				GeneratedArgumentTypes.PoolType poolType3 = poolType2;
				object obj3 = poolType3;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (globalPool == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = globalPool;
				bool globalPool2 = val4.get_Value();
				bool flag = globalPool2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (cudnnOff == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = cudnnOff;
				bool cudnnOff2 = val5.get_Value();
				bool flag2 = cudnnOff2;
				object obj9 = flag2;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			object obj11;
			if (poolingConvention == null)
			{
				obj11 = "valid";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolingConvention> val6 = poolingConvention;
				GeneratedArgumentTypes.PoolingConvention poolingConvention2 = val6.get_Value();
				GeneratedArgumentTypes.PoolingConvention poolingConvention3 = poolingConvention2;
				object obj12 = poolingConvention3;
				if (obj12 != null)
				{
					IFormattable formattable7 = obj12 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj13 = obj12;
						obj11 = obj13.ToString();
					}
				}
				else
				{
					obj11 = "";
				}
			}
			array[4] = (string)obj11;
			object obj14;
			if (stride == null)
			{
				obj14 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val7 = stride;
				IEnumerable<int> stride2 = val7.get_Value();
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004021033_002D869(), stride2));
				FSharpFunc<string, string> val8 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj14 = val8.Invoke(text4);
			}
			array[5] = (string)obj14;
			object obj15;
			if (pad == null)
			{
				obj15 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val9 = pad;
				IEnumerable<int> pad2 = val9.get_Value();
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004021033_002D870(), pad2));
				FSharpFunc<string, string> val10 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj15 = val10.Invoke(text6);
			}
			array[6] = (string)obj15;
			object obj16;
			if (pValue == null)
			{
				obj16 = "None";
			}
			else
			{
				FSharpOption<int> val11 = pValue;
				int pValue2 = val11.get_Value();
				int num = pValue2;
				object obj17 = num;
				if (obj17 != null)
				{
					IFormattable formattable9 = obj17 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[7] = (string)obj16;
			object obj19;
			if (countIncludePad == null)
			{
				obj19 = "None";
			}
			else
			{
				FSharpOption<bool> val12 = countIncludePad;
				bool countIncludePad2 = val12.get_Value();
				bool flag3 = countIncludePad2;
				object obj20 = flag3;
				if (obj20 != null)
				{
					IFormattable formattable11 = obj20 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[8] = (string)obj19;
			object obj22;
			if (layout == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.ContribQuantizedPoolingLayout> val13 = layout;
				GeneratedArgumentTypes.ContribQuantizedPoolingLayout layout2 = val13.get_Value();
				GeneratedArgumentTypes.ContribQuantizedPoolingLayout contribQuantizedPoolingLayout = layout2;
				object obj23 = contribQuantizedPoolingLayout;
				if (obj23 != null)
				{
					IFormattable formattable13 = obj23 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj22 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[9] = (string)obj22;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantizedPooling(IEnumerable<NDArray> outputArray, NDArray data, NDArray minData, NDArray maxData, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> kernel, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolType> poolType, [Optional] [OptionalArgument] FSharpOption<bool> globalPool, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingConvention> poolingConvention, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> pValue, [Optional] [OptionalArgument] FSharpOption<bool> countIncludePad, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizedPoolingLayout> layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_pooling");
			string[] names2 = new string[10]
			{
				"kernel",
				"pool_type",
				"global_pool",
				"cudnn_off",
				"pooling_convention",
				"stride",
				"pad",
				"p_value",
				"count_include_pad",
				"layout"
			};
			string[] array = new string[10];
			object obj;
			if (kernel == null)
			{
				obj = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = kernel;
				IEnumerable<int> kernel2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004021075_002D151(), kernel2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (poolType == null)
			{
				obj2 = "max";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolType> val3 = poolType;
				GeneratedArgumentTypes.PoolType poolType2 = val3.get_Value();
				GeneratedArgumentTypes.PoolType poolType3 = poolType2;
				object obj3 = poolType3;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (globalPool == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = globalPool;
				bool globalPool2 = val4.get_Value();
				bool flag = globalPool2;
				object obj6 = flag;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (cudnnOff == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = cudnnOff;
				bool cudnnOff2 = val5.get_Value();
				bool flag2 = cudnnOff2;
				object obj9 = flag2;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			object obj11;
			if (poolingConvention == null)
			{
				obj11 = "valid";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PoolingConvention> val6 = poolingConvention;
				GeneratedArgumentTypes.PoolingConvention poolingConvention2 = val6.get_Value();
				GeneratedArgumentTypes.PoolingConvention poolingConvention3 = poolingConvention2;
				object obj12 = poolingConvention3;
				if (obj12 != null)
				{
					IFormattable formattable7 = obj12 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj13 = obj12;
						obj11 = obj13.ToString();
					}
				}
				else
				{
					obj11 = "";
				}
			}
			array[4] = (string)obj11;
			object obj14;
			if (stride == null)
			{
				obj14 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val7 = stride;
				IEnumerable<int> stride2 = val7.get_Value();
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004021075_002D152(), stride2));
				FSharpFunc<string, string> val8 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj14 = val8.Invoke(text4);
			}
			array[5] = (string)obj14;
			object obj15;
			if (pad == null)
			{
				obj15 = "[]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val9 = pad;
				IEnumerable<int> pad2 = val9.get_Value();
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004021075_002D153(), pad2));
				FSharpFunc<string, string> val10 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj15 = val10.Invoke(text6);
			}
			array[6] = (string)obj15;
			object obj16;
			if (pValue == null)
			{
				obj16 = "None";
			}
			else
			{
				FSharpOption<int> val11 = pValue;
				int pValue2 = val11.get_Value();
				int num = pValue2;
				object obj17 = num;
				if (obj17 != null)
				{
					IFormattable formattable9 = obj17 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj18 = obj17;
						obj16 = obj18.ToString();
					}
				}
				else
				{
					obj16 = "";
				}
			}
			array[7] = (string)obj16;
			object obj19;
			if (countIncludePad == null)
			{
				obj19 = "None";
			}
			else
			{
				FSharpOption<bool> val12 = countIncludePad;
				bool countIncludePad2 = val12.get_Value();
				bool flag3 = countIncludePad2;
				object obj20 = flag3;
				if (obj20 != null)
				{
					IFormattable formattable11 = obj20 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj21 = obj20;
						obj19 = obj21.ToString();
					}
				}
				else
				{
					obj19 = "";
				}
			}
			array[8] = (string)obj19;
			object obj22;
			if (layout == null)
			{
				obj22 = "None";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.ContribQuantizedPoolingLayout> val13 = layout;
				GeneratedArgumentTypes.ContribQuantizedPoolingLayout layout2 = val13.get_Value();
				GeneratedArgumentTypes.ContribQuantizedPoolingLayout contribQuantizedPoolingLayout = layout2;
				object obj23 = contribQuantizedPoolingLayout;
				if (obj23 != null)
				{
					IFormattable formattable13 = obj23 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj22 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj24 = obj23;
						obj22 = obj24.ToString();
					}
				}
				else
				{
					obj22 = "";
				}
			}
			array[9] = (string)obj22;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizedPooling_004021076(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021078_002D871(data, minData, maxData, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021079_002D872(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizedPooling ContribQuantizedPooling([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> minData, [Optional] [OptionalArgument] FSharpOption<Symbol> maxData, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> kernel, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolType> poolType, [Optional] [OptionalArgument] FSharpOption<bool> globalPool, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PoolingConvention> poolingConvention, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> pValue, [Optional] [OptionalArgument] FSharpOption<bool> countIncludePad, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizedPoolingLayout> layout)
		{
			return new SymbolOperators.ContribQuantizedPooling(data, minData, maxData, kernel, poolType, globalPool, cudnnOff, poolingConvention, stride, pad, pValue, countIncludePad, layout);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantize(NDArray data, NDArray minRange, NDArray maxRange, [Optional] GeneratedArgumentTypes.ContribQuantizeOutType outType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantize");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021141_002D873(data, minRange, maxRange, 0, current));
			string[] parameterKeys = new string[1]
			{
				"out_type"
			};
			string[] array = new string[1];
			object obj;
			if ((outType == null) ? true : false)
			{
				obj = "uint8";
			}
			else if (outType != null)
			{
				IFormattable formattable = outType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = outType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantize(IEnumerable<NDArray> outputArray, NDArray data, NDArray minRange, NDArray maxRange, [Optional] GeneratedArgumentTypes.ContribQuantizeOutType outType)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantize");
			string[] names2 = new string[1]
			{
				"out_type"
			};
			string[] array = new string[1];
			object obj;
			if ((outType == null) ? true : false)
			{
				obj = "uint8";
			}
			else if (outType != null)
			{
				IFormattable formattable = outType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = outType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantize_004021179(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021181_002D874(data, minRange, maxRange, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021182_002D875(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantize ContribQuantize([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> minRange, [Optional] [OptionalArgument] FSharpOption<Symbol> maxRange, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizeOutType> outType)
		{
			return new SymbolOperators.ContribQuantize(data, minRange, maxRange, outType);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantizeV2(NDArray data, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizeV2OutType> outType, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantize_v2");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021253_002D876(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"out_type",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[3];
			object obj;
			if (outType == null)
			{
				obj = "int8";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.ContribQuantizeV2OutType> val = outType;
				GeneratedArgumentTypes.ContribQuantizeV2OutType outType2 = val.get_Value();
				GeneratedArgumentTypes.ContribQuantizeV2OutType contribQuantizeV2OutType = outType2;
				object obj2 = contribQuantizeV2OutType;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (minCalibRange == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = minCalibRange;
				double minCalibRange2 = val2.get_Value();
				double num = minCalibRange2;
				object obj5 = num;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (maxCalibRange == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<double> val3 = maxCalibRange;
				double maxCalibRange2 = val3.get_Value();
				double num2 = maxCalibRange2;
				object obj8 = num2;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantizeV2(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizeV2OutType> outType, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantize_v2");
			string[] names2 = new string[3]
			{
				"out_type",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[3];
			object obj;
			if (outType == null)
			{
				obj = "int8";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.ContribQuantizeV2OutType> val = outType;
				GeneratedArgumentTypes.ContribQuantizeV2OutType outType2 = val.get_Value();
				GeneratedArgumentTypes.ContribQuantizeV2OutType contribQuantizeV2OutType = outType2;
				object obj2 = contribQuantizeV2OutType;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (minCalibRange == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = minCalibRange;
				double minCalibRange2 = val2.get_Value();
				double num = minCalibRange2;
				object obj5 = num;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (maxCalibRange == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<double> val3 = maxCalibRange;
				double maxCalibRange2 = val3.get_Value();
				double num2 = maxCalibRange2;
				object obj8 = num2;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizeV2_004021294(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021296_002D877(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021297_002D878(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizeV2 ContribQuantizeV2([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribQuantizeV2OutType> outType, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			return new SymbolOperators.ContribQuantizeV2(data, outType, minCalibRange, maxCalibRange);
		}

		public static NDArray Flatten(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Flatten");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021361_002D879(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Flatten(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Flatten");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004021390_002D94();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004021391_002D154();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Flatten_004021392(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021394_002D880(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021395_002D881(), outputArray)), names, vals);
		}

		public static SymbolOperators.Flatten Flatten([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Flatten(data);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribQuantizedFullyConnected(NDArray data, NDArray weight, NDArray bias, NDArray minData, NDArray maxData, NDArray minWeight, NDArray maxWeight, NDArray minBias, NDArray maxBias, int numHidden, bool noBias = false, bool flatten = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_fully_connected");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021460_002D882(data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, 0, current));
			string[] parameterKeys = new string[3]
			{
				"num_hidden",
				"no_bias",
				"flatten"
			};
			string[] array = new string[3];
			object obj = numHidden;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = noBias;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag2 = flatten;
			object obj7 = flag2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribQuantizedFullyConnected(IEnumerable<NDArray> outputArray, NDArray data, NDArray weight, NDArray bias, NDArray minData, NDArray maxData, NDArray minWeight, NDArray maxWeight, NDArray minBias, NDArray maxBias, int numHidden, bool noBias = false, bool flatten = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_quantized_fully_connected");
			string[] names2 = new string[3]
			{
				"num_hidden",
				"no_bias",
				"flatten"
			};
			string[] array = new string[3];
			object obj = numHidden;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = noBias;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag2 = flatten;
			object obj7 = flag2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribQuantizedFullyConnected_004021503(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021505_002D883(data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021506_002D884(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribQuantizedFullyConnected ContribQuantizedFullyConnected(Symbol data, Symbol weight, Symbol bias, Symbol minData, Symbol maxData, Symbol minWeight, Symbol maxWeight, Symbol minBias, Symbol maxBias, int numHidden, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<bool> flatten)
		{
			return new SymbolOperators.ContribQuantizedFullyConnected(data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, numHidden, noBias, flatten);
		}

		public static SymbolOperators.ContribQuantizedFullyConnected ContribQuantizedFullyConnected(int numHidden, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> bias, [Optional] [OptionalArgument] FSharpOption<Symbol> minData, [Optional] [OptionalArgument] FSharpOption<Symbol> maxData, [Optional] [OptionalArgument] FSharpOption<Symbol> minWeight, [Optional] [OptionalArgument] FSharpOption<Symbol> maxWeight, [Optional] [OptionalArgument] FSharpOption<Symbol> minBias, [Optional] [OptionalArgument] FSharpOption<Symbol> maxBias, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<bool> flatten)
		{
			return new SymbolOperators.ContribQuantizedFullyConnected(numHidden, data, weight, bias, minData, maxData, minWeight, maxWeight, minBias, maxBias, noBias, flatten);
		}

		public static Tuple<NDArray, NDArray, NDArray> ContribRequantize(NDArray data, NDArray minRange, NDArray maxRange, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribRequantizeOutType> outType, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_requantize");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021583_002D885(data, minRange, maxRange, 0, current));
			string[] parameterKeys = new string[3]
			{
				"out_type",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[3];
			object obj;
			if (outType == null)
			{
				obj = "int8";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.ContribRequantizeOutType> val = outType;
				GeneratedArgumentTypes.ContribRequantizeOutType outType2 = val.get_Value();
				GeneratedArgumentTypes.ContribRequantizeOutType contribRequantizeOutType = outType2;
				object obj2 = contribRequantizeOutType;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (minCalibRange == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = minCalibRange;
				double minCalibRange2 = val2.get_Value();
				double num = minCalibRange2;
				object obj5 = num;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (maxCalibRange == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<double> val3 = maxCalibRange;
				double maxCalibRange2 = val3.get_Value();
				double num2 = maxCalibRange2;
				object obj8 = num2;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]), new NDArray(outputs[2]));
		}

		public static void ContribRequantize(IEnumerable<NDArray> outputArray, NDArray data, NDArray minRange, NDArray maxRange, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribRequantizeOutType> outType, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_requantize");
			string[] names2 = new string[3]
			{
				"out_type",
				"min_calib_range",
				"max_calib_range"
			};
			string[] array = new string[3];
			object obj;
			if (outType == null)
			{
				obj = "int8";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.ContribRequantizeOutType> val = outType;
				GeneratedArgumentTypes.ContribRequantizeOutType outType2 = val.get_Value();
				GeneratedArgumentTypes.ContribRequantizeOutType contribRequantizeOutType = outType2;
				object obj2 = contribRequantizeOutType;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (minCalibRange == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<double> val2 = minCalibRange;
				double minCalibRange2 = val2.get_Value();
				double num = minCalibRange2;
				object obj5 = num;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (maxCalibRange == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<double> val3 = maxCalibRange;
				double maxCalibRange2 = val3.get_Value();
				double num2 = maxCalibRange2;
				object obj8 = num2;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribRequantize_004021614(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021616_002D886(data, minRange, maxRange, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021617_002D887(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribRequantize ContribRequantize([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> minRange, [Optional] [OptionalArgument] FSharpOption<Symbol> maxRange, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribRequantizeOutType> outType, [Optional] [OptionalArgument] FSharpOption<double> minCalibRange, [Optional] [OptionalArgument] FSharpOption<double> maxCalibRange)
		{
			return new SymbolOperators.ContribRequantize(data, minRange, maxRange, outType, minCalibRange, maxCalibRange);
		}

		public static NDArray[] SampleUniform(NDArray low, NDArray high, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_uniform");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021675_002D888(low, high, 0, current));
			string[] parameterKeys = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004021677_002D889(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SampleUniform_004021678();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SampleUniform(IEnumerable<NDArray> outputArray, NDArray low, NDArray high, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_uniform");
			string[] names2 = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004021715_002D155(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SampleUniform_004021716_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021718_002D890(low, high, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021719_002D891(), outputArray)), names, vals);
		}

		public static SymbolOperators.SampleUniform SampleUniform([Optional] [OptionalArgument] FSharpOption<Symbol> low, [Optional] [OptionalArgument] FSharpOption<Symbol> high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.SampleUniform(low, high, shape, dtype);
		}

		public static NDArray[] SampleNormal(NDArray mu, NDArray sigma, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_normal");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021793_002D892(mu, sigma, 0, current));
			string[] parameterKeys = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004021795_002D893(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SampleNormal_004021796();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SampleNormal(IEnumerable<NDArray> outputArray, NDArray mu, NDArray sigma, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_normal");
			string[] names2 = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004021833_002D156(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SampleNormal_004021834_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021836_002D894(mu, sigma, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021837_002D895(), outputArray)), names, vals);
		}

		public static SymbolOperators.SampleNormal SampleNormal([Optional] [OptionalArgument] FSharpOption<Symbol> mu, [Optional] [OptionalArgument] FSharpOption<Symbol> sigma, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.SampleNormal(mu, sigma, shape, dtype);
		}

		public static NDArray[] SampleGamma(NDArray alpha, NDArray beta, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_gamma");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021911_002D896(alpha, beta, 0, current));
			string[] parameterKeys = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004021913_002D897(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SampleGamma_004021914();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SampleGamma(IEnumerable<NDArray> outputArray, NDArray alpha, NDArray beta, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_gamma");
			string[] names2 = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004021951_002D157(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SampleGamma_004021952_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004021954_002D898(alpha, beta, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004021955_002D899(), outputArray)), names, vals);
		}

		public static SymbolOperators.SampleGamma SampleGamma([Optional] [OptionalArgument] FSharpOption<Symbol> alpha, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.SampleGamma(alpha, beta, shape, dtype);
		}

		public static NDArray[] SampleExponential(NDArray lam, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_exponential");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022027_002D900(lam, 0, current));
			string[] parameterKeys = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004022029_002D901(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SampleExponential_004022030();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SampleExponential(IEnumerable<NDArray> outputArray, NDArray lam, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_exponential");
			string[] names2 = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004022065_002D158(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SampleExponential_004022066_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022068_002D902(lam, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022069_002D903(), outputArray)), names, vals);
		}

		public static SymbolOperators.SampleExponential SampleExponential([Optional] [OptionalArgument] FSharpOption<Symbol> lam, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.SampleExponential(lam, shape, dtype);
		}

		public static NDArray[] SamplePoisson(NDArray lam, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_poisson");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022141_002D904(lam, 0, current));
			string[] parameterKeys = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004022143_002D905(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SamplePoisson_004022144();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SamplePoisson(IEnumerable<NDArray> outputArray, NDArray lam, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_poisson");
			string[] names2 = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004022181_002D159(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SamplePoisson_004022182_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022184_002D906(lam, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022185_002D907(), outputArray)), names, vals);
		}

		public static SymbolOperators.SamplePoisson SamplePoisson([Optional] [OptionalArgument] FSharpOption<Symbol> lam, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.SamplePoisson(lam, shape, dtype);
		}

		public static NDArray[] SampleNegativeBinomial(NDArray k, NDArray p, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_negative_binomial");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022261_002D908(k, p, 0, current));
			string[] parameterKeys = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004022263_002D909(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SampleNegativeBinomial_004022264();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SampleNegativeBinomial(IEnumerable<NDArray> outputArray, NDArray k, NDArray p, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_negative_binomial");
			string[] names2 = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004022303_002D160(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SampleNegativeBinomial_004022304_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022306_002D910(k, p, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022307_002D911(), outputArray)), names, vals);
		}

		public static SymbolOperators.SampleNegativeBinomial SampleNegativeBinomial([Optional] [OptionalArgument] FSharpOption<Symbol> k, [Optional] [OptionalArgument] FSharpOption<Symbol> p, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.SampleNegativeBinomial(k, p, shape, dtype);
		}

		public static NDArray[] SampleGeneralizedNegativeBinomial(NDArray mu, NDArray alpha, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_generalized_negative_binomial");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022385_002D912(mu, alpha, 0, current));
			string[] parameterKeys = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004022387_002D913(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SampleGeneralizedNegativeBinomial_004022388();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SampleGeneralizedNegativeBinomial(IEnumerable<NDArray> outputArray, NDArray mu, NDArray alpha, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_generalized_negative_binomial");
			string[] names2 = new string[2]
			{
				"shape",
				"dtype"
			};
			string[] array = new string[2];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004022427_002D161(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((dtype == null) ? true : false)
			{
				obj2 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = dtype;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SampleGeneralizedNegativeBinomial_004022428_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022430_002D914(mu, alpha, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022431_002D915(), outputArray)), names, vals);
		}

		public static SymbolOperators.SampleGeneralizedNegativeBinomial SampleGeneralizedNegativeBinomial([Optional] [OptionalArgument] FSharpOption<Symbol> mu, [Optional] [OptionalArgument] FSharpOption<Symbol> alpha, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.SampleGeneralizedNegativeBinomial(mu, alpha, shape, dtype);
		}

		public static NDArray[] RandomPdfUniform(NDArray sample, NDArray low, NDArray high, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_uniform");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022510_002D916(sample, low, high, 0, current));
			string[] parameterKeys = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.RandomPdfUniform_004022513();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RandomPdfUniform(IEnumerable<NDArray> outputArray, NDArray sample, NDArray low, NDArray high, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_uniform");
			string[] names2 = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPdfUniform_004022554_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022556_002D917(sample, low, high, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022557_002D918(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPdfUniform RandomPdfUniform([Optional] [OptionalArgument] FSharpOption<Symbol> sample, [Optional] [OptionalArgument] FSharpOption<Symbol> low, [Optional] [OptionalArgument] FSharpOption<Symbol> high, [Optional] [OptionalArgument] FSharpOption<bool> isLog)
		{
			return new SymbolOperators.RandomPdfUniform(sample, low, high, isLog);
		}

		public static NDArray[] RandomPdfNormal(NDArray sample, NDArray mu, NDArray sigma, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_normal");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022629_002D919(sample, mu, sigma, 0, current));
			string[] parameterKeys = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.RandomPdfNormal_004022632();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RandomPdfNormal(IEnumerable<NDArray> outputArray, NDArray sample, NDArray mu, NDArray sigma, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_normal");
			string[] names2 = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPdfNormal_004022664_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022666_002D920(sample, mu, sigma, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022667_002D921(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPdfNormal RandomPdfNormal([Optional] [OptionalArgument] FSharpOption<Symbol> sample, [Optional] [OptionalArgument] FSharpOption<Symbol> mu, [Optional] [OptionalArgument] FSharpOption<Symbol> sigma, [Optional] [OptionalArgument] FSharpOption<bool> isLog)
		{
			return new SymbolOperators.RandomPdfNormal(sample, mu, sigma, isLog);
		}

		public static NDArray[] RandomPdfGamma(NDArray sample, NDArray alpha, NDArray beta, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_gamma");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022734_002D922(sample, alpha, beta, 0, current));
			string[] parameterKeys = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.RandomPdfGamma_004022737();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RandomPdfGamma(IEnumerable<NDArray> outputArray, NDArray sample, NDArray alpha, NDArray beta, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_gamma");
			string[] names2 = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPdfGamma_004022773_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022775_002D923(sample, alpha, beta, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022776_002D924(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPdfGamma RandomPdfGamma([Optional] [OptionalArgument] FSharpOption<Symbol> sample, [Optional] [OptionalArgument] FSharpOption<Symbol> alpha, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<bool> isLog)
		{
			return new SymbolOperators.RandomPdfGamma(sample, alpha, beta, isLog);
		}

		public static NDArray[] RandomPdfExponential(NDArray sample, NDArray lam, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_exponential");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022846_002D925(sample, lam, 0, current));
			string[] parameterKeys = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.RandomPdfExponential_004022849();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RandomPdfExponential(IEnumerable<NDArray> outputArray, NDArray sample, NDArray lam, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_exponential");
			string[] names2 = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPdfExponential_004022884_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022886_002D926(sample, lam, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022887_002D927(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPdfExponential RandomPdfExponential([Optional] [OptionalArgument] FSharpOption<Symbol> sample, [Optional] [OptionalArgument] FSharpOption<Symbol> lam, [Optional] [OptionalArgument] FSharpOption<bool> isLog)
		{
			return new SymbolOperators.RandomPdfExponential(sample, lam, isLog);
		}

		public static NDArray[] RandomPdfPoisson(NDArray sample, NDArray lam, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_poisson");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022956_002D928(sample, lam, 0, current));
			string[] parameterKeys = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.RandomPdfPoisson_004022959();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RandomPdfPoisson(IEnumerable<NDArray> outputArray, NDArray sample, NDArray lam, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_poisson");
			string[] names2 = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPdfPoisson_004022994_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004022996_002D929(sample, lam, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004022997_002D930(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPdfPoisson RandomPdfPoisson([Optional] [OptionalArgument] FSharpOption<Symbol> sample, [Optional] [OptionalArgument] FSharpOption<Symbol> lam, [Optional] [OptionalArgument] FSharpOption<bool> isLog)
		{
			return new SymbolOperators.RandomPdfPoisson(sample, lam, isLog);
		}

		public static NDArray[] RandomPdfNegativeBinomial(NDArray sample, NDArray k, NDArray p, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_negative_binomial");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004023065_002D931(sample, k, p, 0, current));
			string[] parameterKeys = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.RandomPdfNegativeBinomial_004023068();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RandomPdfNegativeBinomial(IEnumerable<NDArray> outputArray, NDArray sample, NDArray k, NDArray p, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_negative_binomial");
			string[] names2 = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPdfNegativeBinomial_004023102_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004023104_002D932(sample, k, p, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023105_002D933(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPdfNegativeBinomial RandomPdfNegativeBinomial([Optional] [OptionalArgument] FSharpOption<Symbol> sample, [Optional] [OptionalArgument] FSharpOption<Symbol> k, [Optional] [OptionalArgument] FSharpOption<Symbol> p, [Optional] [OptionalArgument] FSharpOption<bool> isLog)
		{
			return new SymbolOperators.RandomPdfNegativeBinomial(sample, k, p, isLog);
		}

		public static NDArray[] RandomPdfGeneralizedNegativeBinomial(NDArray sample, NDArray mu, NDArray alpha, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_generalized_negative_binomial");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004023173_002D934(sample, mu, alpha, 0, current));
			string[] parameterKeys = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.RandomPdfGeneralizedNegativeBinomial_004023176();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RandomPdfGeneralizedNegativeBinomial(IEnumerable<NDArray> outputArray, NDArray sample, NDArray mu, NDArray alpha, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_generalized_negative_binomial");
			string[] names2 = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPdfGeneralizedNegativeBinomial_004023211_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004023213_002D935(sample, mu, alpha, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023214_002D936(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPdfGeneralizedNegativeBinomial RandomPdfGeneralizedNegativeBinomial([Optional] [OptionalArgument] FSharpOption<Symbol> sample, [Optional] [OptionalArgument] FSharpOption<Symbol> mu, [Optional] [OptionalArgument] FSharpOption<Symbol> alpha, [Optional] [OptionalArgument] FSharpOption<bool> isLog)
		{
			return new SymbolOperators.RandomPdfGeneralizedNegativeBinomial(sample, mu, alpha, isLog);
		}

		public static NDArray[] RandomPdfDirichlet(NDArray sample, NDArray alpha, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_dirichlet");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004023281_002D937(sample, alpha, 0, current));
			string[] parameterKeys = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.RandomPdfDirichlet_004023284();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RandomPdfDirichlet(IEnumerable<NDArray> outputArray, NDArray sample, NDArray alpha, bool isLog = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_pdf_dirichlet");
			string[] names2 = new string[1]
			{
				"is_log"
			};
			string[] array = new string[1];
			bool flag = isLog;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPdfDirichlet_004023317_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004023319_002D938(sample, alpha, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023320_002D939(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPdfDirichlet RandomPdfDirichlet([Optional] [OptionalArgument] FSharpOption<Symbol> sample, [Optional] [OptionalArgument] FSharpOption<Symbol> alpha, [Optional] [OptionalArgument] FSharpOption<bool> isLog)
		{
			return new SymbolOperators.RandomPdfDirichlet(sample, alpha, isLog);
		}

		public static NDArray[] SampleMultinomial(NDArray data, [Optional] IEnumerable<int> shape, bool getProb = false, [Optional] GeneratedArgumentTypes.SampleMultinomialDtype dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_multinomial");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004023391_002D940(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"shape",
				"get_prob",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004023393_002D941(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			bool flag = getProb;
			object obj2 = flag;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if ((dtype == null) ? true : false)
			{
				obj5 = "int32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = dtype;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SampleMultinomial_004023394();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SampleMultinomial(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> shape, bool getProb = false, [Optional] GeneratedArgumentTypes.SampleMultinomialDtype dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_multinomial");
			string[] names2 = new string[3]
			{
				"shape",
				"get_prob",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004023432_002D162(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			bool flag = getProb;
			object obj2 = flag;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if ((dtype == null) ? true : false)
			{
				obj5 = "int32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = dtype;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SampleMultinomial_004023433_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004023435_002D942(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023436_002D943(), outputArray)), names, vals);
		}

		public static SymbolOperators.SampleMultinomial SampleMultinomial([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<bool> getProb, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.SampleMultinomialDtype> dtype)
		{
			return new SymbolOperators.SampleMultinomial(data, shape, getProb, dtype);
		}

		public static NDArray RandomUniformNDArray(Context ctx, double low = 0.0, double high = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_uniform");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"low",
				"high",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = low;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = high;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004023506_002D944(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomUniform(IEnumerable<NDArray> outputArray, Context ctx, double low = 0.0, double high = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_uniform");
			string[] names2 = new string[5]
			{
				"ctx",
				"low",
				"high",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = low;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = high;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004023537_002D163(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomUniform_004023538(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023541_002D945(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomUniform RandomUniform([Optional] [OptionalArgument] FSharpOption<double> low, [Optional] [OptionalArgument] FSharpOption<double> high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.RandomUniform(low, high, shape, dtype);
		}

		public static NDArray RandomNormalNDArray(Context ctx, double loc = 0.0, double scale = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_normal");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"loc",
				"scale",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = loc;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = scale;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004023595_002D946(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomNormal(IEnumerable<NDArray> outputArray, Context ctx, double loc = 0.0, double scale = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_normal");
			string[] names2 = new string[5]
			{
				"ctx",
				"loc",
				"scale",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = loc;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = scale;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004023625_002D164(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomNormal_004023626(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023629_002D947(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomNormal RandomNormal([Optional] [OptionalArgument] FSharpOption<double> loc, [Optional] [OptionalArgument] FSharpOption<double> scale, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.RandomNormal(loc, scale, shape, dtype);
		}

		public static NDArray RandomGammaNDArray(Context ctx, double alpha = 1.0, double beta = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_gamma");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"alpha",
				"beta",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = alpha;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = beta;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004023679_002D948(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomGamma(IEnumerable<NDArray> outputArray, Context ctx, double alpha = 1.0, double beta = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_gamma");
			string[] names2 = new string[5]
			{
				"ctx",
				"alpha",
				"beta",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = alpha;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = beta;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004023706_002D165(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomGamma_004023707(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023710_002D949(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomGamma RandomGamma([Optional] [OptionalArgument] FSharpOption<double> alpha, [Optional] [OptionalArgument] FSharpOption<double> beta, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.RandomGamma(alpha, beta, shape, dtype);
		}

		public static NDArray RandomExponentialNDArray(Context ctx, double lam = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_exponential");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[4]
			{
				"ctx",
				"lam",
				"shape",
				"dtype"
			};
			string[] array = new string[4];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = lam;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((shape == null) ? true : false)
			{
				obj6 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004023752_002D950(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj6 = val.Invoke(text2);
			}
			array[2] = (string)obj6;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomExponential(IEnumerable<NDArray> outputArray, Context ctx, double lam = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_exponential");
			string[] names2 = new string[4]
			{
				"ctx",
				"lam",
				"shape",
				"dtype"
			};
			string[] array = new string[4];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = lam;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((shape == null) ? true : false)
			{
				obj6 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004023773_002D166(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj6 = val.Invoke(text2);
			}
			array[2] = (string)obj6;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomExponential_004023774(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023777_002D951(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomExponential RandomExponential([Optional] [OptionalArgument] FSharpOption<double> lam, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.RandomExponential(lam, shape, dtype);
		}

		public static NDArray RandomPoissonNDArray(Context ctx, double lam = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_poisson");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[4]
			{
				"ctx",
				"lam",
				"shape",
				"dtype"
			};
			string[] array = new string[4];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = lam;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((shape == null) ? true : false)
			{
				obj6 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004023819_002D952(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj6 = val.Invoke(text2);
			}
			array[2] = (string)obj6;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomPoisson(IEnumerable<NDArray> outputArray, Context ctx, double lam = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_poisson");
			string[] names2 = new string[4]
			{
				"ctx",
				"lam",
				"shape",
				"dtype"
			};
			string[] array = new string[4];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = lam;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((shape == null) ? true : false)
			{
				obj6 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004023841_002D167(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj6 = val.Invoke(text2);
			}
			array[2] = (string)obj6;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPoisson_004023842(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023845_002D953(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPoisson RandomPoisson([Optional] [OptionalArgument] FSharpOption<double> lam, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.RandomPoisson(lam, shape, dtype);
		}

		public static NDArray RandomNegativeBinomialNDArray(Context ctx, int k = 1, double p = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_negative_binomial");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"k",
				"p",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = k;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = p;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004023894_002D954(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomNegativeBinomial(IEnumerable<NDArray> outputArray, Context ctx, int k = 1, double p = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_negative_binomial");
			string[] names2 = new string[5]
			{
				"ctx",
				"k",
				"p",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = k;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = p;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004023923_002D168(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomNegativeBinomial_004023924(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004023927_002D955(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomNegativeBinomial RandomNegativeBinomial([Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<double> p, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.RandomNegativeBinomial(k, p, shape, dtype);
		}

		public static NDArray RandomGeneralizedNegativeBinomialNDArray(Context ctx, double mu = 1.0, double alpha = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_generalized_negative_binomial");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"mu",
				"alpha",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = mu;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = alpha;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004023979_002D956(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomGeneralizedNegativeBinomial(IEnumerable<NDArray> outputArray, Context ctx, double mu = 1.0, double alpha = 1.0, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.FloatDType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_generalized_negative_binomial");
			string[] names2 = new string[5]
			{
				"ctx",
				"mu",
				"alpha",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = mu;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = alpha;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004024009_002D169(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomGeneralizedNegativeBinomial_004024010(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024013_002D957(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomGeneralizedNegativeBinomial RandomGeneralizedNegativeBinomial([Optional] [OptionalArgument] FSharpOption<double> mu, [Optional] [OptionalArgument] FSharpOption<double> alpha, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.FloatDType> dtype)
		{
			return new SymbolOperators.RandomGeneralizedNegativeBinomial(mu, alpha, shape, dtype);
		}

		public static NDArray RandomRandintNDArray(long low, long high, Context ctx, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.RandomRandintDtype dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_randint");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[5]
			{
				"low",
				"high",
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj = low;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = high;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (ctx != null)
			{
				IFormattable formattable5 = ctx as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = ctx;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004024065_002D958(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomRandint(IEnumerable<NDArray> outputArray, long low, long high, Context ctx, [Optional] IEnumerable<int> shape, [Optional] GeneratedArgumentTypes.RandomRandintDtype dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_randint");
			string[] names2 = new string[5]
			{
				"low",
				"high",
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[5];
			object obj = low;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = high;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (ctx != null)
			{
				IFormattable formattable5 = ctx as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = ctx;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if ((shape == null) ? true : false)
			{
				obj9 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004024094_002D170(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj9 = val.Invoke(text2);
			}
			array[3] = (string)obj9;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "None";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[4] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomRandint_004024095(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024098_002D959(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomRandint RandomRandint(long low, long high, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.RandomRandintDtype> dtype)
		{
			return new SymbolOperators.RandomRandint(low, high, shape, dtype);
		}

		public static NDArray RandomUniformLike(NDArray data, double low = 0.0, double high = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_uniform_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024141_002D960(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"low",
				"high"
			};
			string[] array = new string[2];
			object obj = low;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = high;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomUniformLike(IEnumerable<NDArray> outputArray, NDArray data, double low = 0.0, double high = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_uniform_like");
			string[] names2 = new string[2]
			{
				"low",
				"high"
			};
			string[] array = new string[2];
			object obj = low;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = high;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomUniformLike_004024166(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024168_002D961(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024169_002D962(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomUniformLike RandomUniformLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> low, [Optional] [OptionalArgument] FSharpOption<double> high)
		{
			return new SymbolOperators.RandomUniformLike(data, low, high);
		}

		public static NDArray RandomNormalLike(NDArray data, double loc = 0.0, double scale = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_normal_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024210_002D963(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"loc",
				"scale"
			};
			string[] array = new string[2];
			object obj = loc;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = scale;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomNormalLike(IEnumerable<NDArray> outputArray, NDArray data, double loc = 0.0, double scale = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_normal_like");
			string[] names2 = new string[2]
			{
				"loc",
				"scale"
			};
			string[] array = new string[2];
			object obj = loc;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = scale;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomNormalLike_004024234(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024236_002D964(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024237_002D965(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomNormalLike RandomNormalLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> loc, [Optional] [OptionalArgument] FSharpOption<double> scale)
		{
			return new SymbolOperators.RandomNormalLike(data, loc, scale);
		}

		public static NDArray RandomGammaLike(NDArray data, double alpha = 1.0, double beta = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_gamma_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024276_002D966(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"alpha",
				"beta"
			};
			string[] array = new string[2];
			object obj = alpha;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = beta;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomGammaLike(IEnumerable<NDArray> outputArray, NDArray data, double alpha = 1.0, double beta = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_gamma_like");
			string[] names2 = new string[2]
			{
				"alpha",
				"beta"
			};
			string[] array = new string[2];
			object obj = alpha;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = beta;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomGammaLike_004024299(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024301_002D967(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024302_002D968(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomGammaLike RandomGammaLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> alpha, [Optional] [OptionalArgument] FSharpOption<double> beta)
		{
			return new SymbolOperators.RandomGammaLike(data, alpha, beta);
		}

		public static NDArray RandomExponentialLike(NDArray data, double lam = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_exponential_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024339_002D969(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"lam"
			};
			string[] array = new string[1];
			object obj = lam;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomExponentialLike(IEnumerable<NDArray> outputArray, NDArray data, double lam = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_exponential_like");
			string[] names2 = new string[1]
			{
				"lam"
			};
			string[] array = new string[1];
			object obj = lam;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomExponentialLike_004024361(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024363_002D970(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024364_002D971(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomExponentialLike RandomExponentialLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> lam)
		{
			return new SymbolOperators.RandomExponentialLike(data, lam);
		}

		public static NDArray RandomPoissonLike(NDArray data, double lam = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_poisson_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024401_002D972(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"lam"
			};
			string[] array = new string[1];
			object obj = lam;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomPoissonLike(IEnumerable<NDArray> outputArray, NDArray data, double lam = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_poisson_like");
			string[] names2 = new string[1]
			{
				"lam"
			};
			string[] array = new string[1];
			object obj = lam;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomPoissonLike_004024424(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024426_002D973(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024427_002D974(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomPoissonLike RandomPoissonLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> lam)
		{
			return new SymbolOperators.RandomPoissonLike(data, lam);
		}

		public static NDArray RandomNegativeBinomialLike(NDArray data, int k = 1, double p = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_negative_binomial_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024467_002D975(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"k",
				"p"
			};
			string[] array = new string[2];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = p;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomNegativeBinomialLike(IEnumerable<NDArray> outputArray, NDArray data, int k = 1, double p = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_negative_binomial_like");
			string[] names2 = new string[2]
			{
				"k",
				"p"
			};
			string[] array = new string[2];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = p;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomNegativeBinomialLike_004024492(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024494_002D976(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024495_002D977(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomNegativeBinomialLike RandomNegativeBinomialLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<double> p)
		{
			return new SymbolOperators.RandomNegativeBinomialLike(data, k, p);
		}

		public static NDArray RandomGeneralizedNegativeBinomialLike(NDArray data, double mu = 1.0, double alpha = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_generalized_negative_binomial_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024539_002D978(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"mu",
				"alpha"
			};
			string[] array = new string[2];
			object obj = mu;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = alpha;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RandomGeneralizedNegativeBinomialLike(IEnumerable<NDArray> outputArray, NDArray data, double mu = 1.0, double alpha = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_random_generalized_negative_binomial_like");
			string[] names2 = new string[2]
			{
				"mu",
				"alpha"
			};
			string[] array = new string[2];
			object obj = mu;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = alpha;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RandomGeneralizedNegativeBinomialLike_004024566(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024568_002D979(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024569_002D980(), outputArray)), names, vals);
		}

		public static SymbolOperators.RandomGeneralizedNegativeBinomialLike RandomGeneralizedNegativeBinomialLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> mu, [Optional] [OptionalArgument] FSharpOption<double> alpha)
		{
			return new SymbolOperators.RandomGeneralizedNegativeBinomialLike(data, mu, alpha);
		}

		public static NDArray Shuffle(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_shuffle");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024605_002D981(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Shuffle(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_shuffle");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004024620_002D95();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004024621_002D171();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Shuffle_004024622(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024624_002D982(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024625_002D983(), outputArray)), names, vals);
		}

		public static SymbolOperators.Shuffle Shuffle([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Shuffle(data);
		}

		public static NDArray SampleUniqueZipfianNDArray(int rangeMax, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_unique_zipfian");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[2]
			{
				"range_max",
				"shape"
			};
			string[] array = new string[2];
			object obj = rangeMax;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if ((shape == null) ? true : false)
			{
				obj4 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004024672_002D984(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj4 = val.Invoke(text2);
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SampleUniqueZipfian(IEnumerable<NDArray> outputArray, int rangeMax, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sample_unique_zipfian");
			string[] names2 = new string[2]
			{
				"range_max",
				"shape"
			};
			string[] array = new string[2];
			object obj = rangeMax;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if ((shape == null) ? true : false)
			{
				obj4 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004024705_002D172(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj4 = val.Invoke(text2);
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SampleUniqueZipfian_004024706(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024709_002D985(), outputArray)), names, vals);
		}

		public static SymbolOperators.SampleUniqueZipfian SampleUniqueZipfian(int rangeMax, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape)
		{
			return new SymbolOperators.SampleUniqueZipfian(rangeMax, shape);
		}

		public static NDArray LinearRegressionOutput(NDArray data, NDArray label, double gradScale = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LinearRegressionOutput");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024771_002D986(data, label, 0, current));
			string[] parameterKeys = new string[1]
			{
				"grad_scale"
			};
			string[] array = new string[1];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinearRegressionOutput(IEnumerable<NDArray> outputArray, NDArray data, NDArray label, double gradScale = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LinearRegressionOutput");
			string[] names2 = new string[1]
			{
				"grad_scale"
			};
			string[] array = new string[1];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinearRegressionOutput_004024805(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024807_002D987(data, label, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024808_002D988(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinearRegressionOutput LinearRegressionOutput([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> label, [Optional] [OptionalArgument] FSharpOption<double> gradScale)
		{
			return new SymbolOperators.LinearRegressionOutput(data, label, gradScale);
		}

		public static NDArray MAERegressionOutput(NDArray data, NDArray label, double gradScale = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("MAERegressionOutput");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024870_002D989(data, label, 0, current));
			string[] parameterKeys = new string[1]
			{
				"grad_scale"
			};
			string[] array = new string[1];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MAERegressionOutput(IEnumerable<NDArray> outputArray, NDArray data, NDArray label, double gradScale = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("MAERegressionOutput");
			string[] names2 = new string[1]
			{
				"grad_scale"
			};
			string[] array = new string[1];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MAERegressionOutput_004024905(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024907_002D990(data, label, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004024908_002D991(), outputArray)), names, vals);
		}

		public static SymbolOperators.MAERegressionOutput MAERegressionOutput([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> label, [Optional] [OptionalArgument] FSharpOption<double> gradScale)
		{
			return new SymbolOperators.MAERegressionOutput(data, label, gradScale);
		}

		public static NDArray LogisticRegressionOutput(NDArray data, NDArray label, double gradScale = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LogisticRegressionOutput");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004024975_002D992(data, label, 0, current));
			string[] parameterKeys = new string[1]
			{
				"grad_scale"
			};
			string[] array = new string[1];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LogisticRegressionOutput(IEnumerable<NDArray> outputArray, NDArray data, NDArray label, double gradScale = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("LogisticRegressionOutput");
			string[] names2 = new string[1]
			{
				"grad_scale"
			};
			string[] array = new string[1];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogisticRegressionOutput_004025014(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004025016_002D993(data, label, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004025017_002D994(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogisticRegressionOutput LogisticRegressionOutput([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> label, [Optional] [OptionalArgument] FSharpOption<double> gradScale)
		{
			return new SymbolOperators.LogisticRegressionOutput(data, label, gradScale);
		}

		public static NDArray[] RNN(NDArray data, NDArray parameters, NDArray state, NDArray stateCell, NDArray sequenceLength, int stateSize, int numLayers, GeneratedArgumentTypes.RNNMode mode, [Optional] [OptionalArgument] FSharpOption<bool> bidirectional, [Optional] [OptionalArgument] FSharpOption<double> p, [Optional] [OptionalArgument] FSharpOption<bool> stateOutputs, [Optional] [OptionalArgument] FSharpOption<int> projectionSize, [Optional] [OptionalArgument] FSharpOption<double> lstmStateClipMin, [Optional] [OptionalArgument] FSharpOption<double> lstmStateClipMax, [Optional] [OptionalArgument] FSharpOption<bool> lstmStateClipNan, [Optional] [OptionalArgument] FSharpOption<bool> useSequenceLength)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("RNN");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004025145_002D995(data, parameters, state, stateCell, sequenceLength, 0, current));
			string[] parameterKeys = new string[11]
			{
				"state_size",
				"num_layers",
				"mode",
				"bidirectional",
				"p",
				"state_outputs",
				"projection_size",
				"lstm_state_clip_min",
				"lstm_state_clip_max",
				"lstm_state_clip_nan",
				"use_sequence_length"
			};
			string[] array = new string[11];
			object obj = stateSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numLayers;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (mode != null)
			{
				IFormattable formattable5 = mode as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = mode;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if (bidirectional == null)
			{
				obj9 = "false";
			}
			else
			{
				FSharpOption<bool> val = bidirectional;
				bool bidirectional2 = val.get_Value();
				bool flag = bidirectional2;
				object obj10 = flag;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (p == null)
			{
				obj12 = "0.0";
			}
			else
			{
				FSharpOption<double> val2 = p;
				double p2 = val2.get_Value();
				double num = p2;
				object obj13 = num;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			object obj15;
			if (stateOutputs == null)
			{
				obj15 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = stateOutputs;
				bool stateOutputs2 = val3.get_Value();
				bool flag2 = stateOutputs2;
				object obj16 = flag2;
				if (obj16 != null)
				{
					IFormattable formattable11 = obj16 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj17 = obj16;
						obj15 = obj17.ToString();
					}
				}
				else
				{
					obj15 = "";
				}
			}
			array[5] = (string)obj15;
			object obj18;
			if (projectionSize == null)
			{
				obj18 = "None";
			}
			else
			{
				FSharpOption<int> val4 = projectionSize;
				int projectionSize2 = val4.get_Value();
				int num2 = projectionSize2;
				object obj19 = num2;
				if (obj19 != null)
				{
					IFormattable formattable13 = obj19 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj20 = obj19;
						obj18 = obj20.ToString();
					}
				}
				else
				{
					obj18 = "";
				}
			}
			array[6] = (string)obj18;
			object obj21;
			if (lstmStateClipMin == null)
			{
				obj21 = "None";
			}
			else
			{
				FSharpOption<double> val5 = lstmStateClipMin;
				double lstmStateClipMin2 = val5.get_Value();
				double num3 = lstmStateClipMin2;
				object obj22 = num3;
				if (obj22 != null)
				{
					IFormattable formattable15 = obj22 as IFormattable;
					if (formattable15 != null)
					{
						IFormattable formattable16 = formattable15;
						obj21 = formattable16.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj23 = obj22;
						obj21 = obj23.ToString();
					}
				}
				else
				{
					obj21 = "";
				}
			}
			array[7] = (string)obj21;
			object obj24;
			if (lstmStateClipMax == null)
			{
				obj24 = "None";
			}
			else
			{
				FSharpOption<double> val6 = lstmStateClipMax;
				double lstmStateClipMax2 = val6.get_Value();
				double num4 = lstmStateClipMax2;
				object obj25 = num4;
				if (obj25 != null)
				{
					IFormattable formattable17 = obj25 as IFormattable;
					if (formattable17 != null)
					{
						IFormattable formattable18 = formattable17;
						obj24 = formattable18.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj26 = obj25;
						obj24 = obj26.ToString();
					}
				}
				else
				{
					obj24 = "";
				}
			}
			array[8] = (string)obj24;
			object obj27;
			if (lstmStateClipNan == null)
			{
				obj27 = "false";
			}
			else
			{
				FSharpOption<bool> val7 = lstmStateClipNan;
				bool lstmStateClipNan2 = val7.get_Value();
				bool flag3 = lstmStateClipNan2;
				object obj28 = flag3;
				if (obj28 != null)
				{
					IFormattable formattable19 = obj28 as IFormattable;
					if (formattable19 != null)
					{
						IFormattable formattable20 = formattable19;
						obj27 = formattable20.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj29 = obj28;
						obj27 = obj29.ToString();
					}
				}
				else
				{
					obj27 = "";
				}
			}
			array[9] = (string)obj27;
			object obj30;
			if (useSequenceLength == null)
			{
				obj30 = "false";
			}
			else
			{
				FSharpOption<bool> val8 = useSequenceLength;
				bool useSequenceLength2 = val8.get_Value();
				bool flag4 = useSequenceLength2;
				object obj31 = flag4;
				if (obj31 != null)
				{
					IFormattable formattable21 = obj31 as IFormattable;
					if (formattable21 != null)
					{
						IFormattable formattable22 = formattable21;
						obj30 = formattable22.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj32 = obj31;
						obj30 = obj32.ToString();
					}
				}
				else
				{
					obj30 = "";
				}
			}
			array[10] = (string)obj30;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val9 = new _0024Operators.RNN_004025148();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val9.Invoke(array3[i]);
			}
			return array4;
		}

		public static void RNN(IEnumerable<NDArray> outputArray, NDArray data, NDArray parameters, NDArray state, NDArray stateCell, NDArray sequenceLength, int stateSize, int numLayers, GeneratedArgumentTypes.RNNMode mode, [Optional] [OptionalArgument] FSharpOption<bool> bidirectional, [Optional] [OptionalArgument] FSharpOption<double> p, [Optional] [OptionalArgument] FSharpOption<bool> stateOutputs, [Optional] [OptionalArgument] FSharpOption<int> projectionSize, [Optional] [OptionalArgument] FSharpOption<double> lstmStateClipMin, [Optional] [OptionalArgument] FSharpOption<double> lstmStateClipMax, [Optional] [OptionalArgument] FSharpOption<bool> lstmStateClipNan, [Optional] [OptionalArgument] FSharpOption<bool> useSequenceLength)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("RNN");
			string[] names2 = new string[11]
			{
				"state_size",
				"num_layers",
				"mode",
				"bidirectional",
				"p",
				"state_outputs",
				"projection_size",
				"lstm_state_clip_min",
				"lstm_state_clip_max",
				"lstm_state_clip_nan",
				"use_sequence_length"
			};
			string[] array = new string[11];
			object obj = stateSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numLayers;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (mode != null)
			{
				IFormattable formattable5 = mode as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = mode;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9;
			if (bidirectional == null)
			{
				obj9 = "false";
			}
			else
			{
				FSharpOption<bool> val = bidirectional;
				bool bidirectional2 = val.get_Value();
				bool flag = bidirectional2;
				object obj10 = flag;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (p == null)
			{
				obj12 = "0.0";
			}
			else
			{
				FSharpOption<double> val2 = p;
				double p2 = val2.get_Value();
				double num = p2;
				object obj13 = num;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			object obj15;
			if (stateOutputs == null)
			{
				obj15 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = stateOutputs;
				bool stateOutputs2 = val3.get_Value();
				bool flag2 = stateOutputs2;
				object obj16 = flag2;
				if (obj16 != null)
				{
					IFormattable formattable11 = obj16 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj17 = obj16;
						obj15 = obj17.ToString();
					}
				}
				else
				{
					obj15 = "";
				}
			}
			array[5] = (string)obj15;
			object obj18;
			if (projectionSize == null)
			{
				obj18 = "None";
			}
			else
			{
				FSharpOption<int> val4 = projectionSize;
				int projectionSize2 = val4.get_Value();
				int num2 = projectionSize2;
				object obj19 = num2;
				if (obj19 != null)
				{
					IFormattable formattable13 = obj19 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj20 = obj19;
						obj18 = obj20.ToString();
					}
				}
				else
				{
					obj18 = "";
				}
			}
			array[6] = (string)obj18;
			object obj21;
			if (lstmStateClipMin == null)
			{
				obj21 = "None";
			}
			else
			{
				FSharpOption<double> val5 = lstmStateClipMin;
				double lstmStateClipMin2 = val5.get_Value();
				double num3 = lstmStateClipMin2;
				object obj22 = num3;
				if (obj22 != null)
				{
					IFormattable formattable15 = obj22 as IFormattable;
					if (formattable15 != null)
					{
						IFormattable formattable16 = formattable15;
						obj21 = formattable16.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj23 = obj22;
						obj21 = obj23.ToString();
					}
				}
				else
				{
					obj21 = "";
				}
			}
			array[7] = (string)obj21;
			object obj24;
			if (lstmStateClipMax == null)
			{
				obj24 = "None";
			}
			else
			{
				FSharpOption<double> val6 = lstmStateClipMax;
				double lstmStateClipMax2 = val6.get_Value();
				double num4 = lstmStateClipMax2;
				object obj25 = num4;
				if (obj25 != null)
				{
					IFormattable formattable17 = obj25 as IFormattable;
					if (formattable17 != null)
					{
						IFormattable formattable18 = formattable17;
						obj24 = formattable18.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj26 = obj25;
						obj24 = obj26.ToString();
					}
				}
				else
				{
					obj24 = "";
				}
			}
			array[8] = (string)obj24;
			object obj27;
			if (lstmStateClipNan == null)
			{
				obj27 = "false";
			}
			else
			{
				FSharpOption<bool> val7 = lstmStateClipNan;
				bool lstmStateClipNan2 = val7.get_Value();
				bool flag3 = lstmStateClipNan2;
				object obj28 = flag3;
				if (obj28 != null)
				{
					IFormattable formattable19 = obj28 as IFormattable;
					if (formattable19 != null)
					{
						IFormattable formattable20 = formattable19;
						obj27 = formattable20.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj29 = obj28;
						obj27 = obj29.ToString();
					}
				}
				else
				{
					obj27 = "";
				}
			}
			array[9] = (string)obj27;
			object obj30;
			if (useSequenceLength == null)
			{
				obj30 = "false";
			}
			else
			{
				FSharpOption<bool> val8 = useSequenceLength;
				bool useSequenceLength2 = val8.get_Value();
				bool flag4 = useSequenceLength2;
				object obj31 = flag4;
				if (obj31 != null)
				{
					IFormattable formattable21 = obj31 as IFormattable;
					if (formattable21 != null)
					{
						IFormattable formattable22 = formattable21;
						obj30 = formattable22.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj32 = obj31;
						obj30 = obj32.ToString();
					}
				}
				else
				{
					obj30 = "";
				}
			}
			array[10] = (string)obj30;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RNN_004025242_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004025244_002D996(data, parameters, state, stateCell, sequenceLength, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004025245_002D997(), outputArray)), names, vals);
		}

		public static SymbolOperators.RNN RNN(Symbol data, Symbol parameters, Symbol state, Symbol stateCell, Symbol sequenceLength, int stateSize, int numLayers, GeneratedArgumentTypes.RNNMode mode, [Optional] [OptionalArgument] FSharpOption<bool> bidirectional, [Optional] [OptionalArgument] FSharpOption<double> p, [Optional] [OptionalArgument] FSharpOption<bool> stateOutputs, [Optional] [OptionalArgument] FSharpOption<int> projectionSize, [Optional] [OptionalArgument] FSharpOption<double> lstmStateClipMin, [Optional] [OptionalArgument] FSharpOption<double> lstmStateClipMax, [Optional] [OptionalArgument] FSharpOption<bool> lstmStateClipNan, [Optional] [OptionalArgument] FSharpOption<bool> useSequenceLength)
		{
			return new SymbolOperators.RNN(data, parameters, state, stateCell, sequenceLength, stateSize, numLayers, mode, bidirectional, p, stateOutputs, projectionSize, lstmStateClipMin, lstmStateClipMax, lstmStateClipNan, useSequenceLength);
		}

		public static SymbolOperators.RNN RNN(int stateSize, int numLayers, GeneratedArgumentTypes.RNNMode mode, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> parameters, [Optional] [OptionalArgument] FSharpOption<Symbol> state, [Optional] [OptionalArgument] FSharpOption<Symbol> stateCell, [Optional] [OptionalArgument] FSharpOption<Symbol> sequenceLength, [Optional] [OptionalArgument] FSharpOption<bool> bidirectional, [Optional] [OptionalArgument] FSharpOption<double> p, [Optional] [OptionalArgument] FSharpOption<bool> stateOutputs, [Optional] [OptionalArgument] FSharpOption<int> projectionSize, [Optional] [OptionalArgument] FSharpOption<double> lstmStateClipMin, [Optional] [OptionalArgument] FSharpOption<double> lstmStateClipMax, [Optional] [OptionalArgument] FSharpOption<bool> lstmStateClipNan, [Optional] [OptionalArgument] FSharpOption<bool> useSequenceLength)
		{
			return new SymbolOperators.RNN(stateSize, numLayers, mode, data, parameters, state, stateCell, sequenceLength, bidirectional, p, stateOutputs, projectionSize, lstmStateClipMin, lstmStateClipMax, lstmStateClipNan, useSequenceLength);
		}

		public static NDArray[] ROIPooling(NDArray data, NDArray rois, IEnumerable<int> pooledSize, double spatialScale)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ROIPooling");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004025452_002D998(data, rois, 0, current));
			string[] parameterKeys = new string[2]
			{
				"pooled_size",
				"spatial_scale"
			};
			string[] array = new string[2];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004025454_002D999(), pooledSize));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = spatialScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.ROIPooling_004025455();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ROIPooling(IEnumerable<NDArray> outputArray, NDArray data, NDArray rois, IEnumerable<int> pooledSize, double spatialScale)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ROIPooling");
			string[] names2 = new string[2]
			{
				"pooled_size",
				"spatial_scale"
			};
			string[] array = new string[2];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004025510_002D173(), pooledSize));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = spatialScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ROIPooling_004025511_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004025513_002D1000(data, rois, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004025514_002D1001(), outputArray)), names, vals);
		}

		public static SymbolOperators.ROIPooling ROIPooling(Symbol data, Symbol rois, IEnumerable<int> pooledSize, double spatialScale)
		{
			return new SymbolOperators.ROIPooling(data, rois, pooledSize, spatialScale);
		}

		public static SymbolOperators.ROIPooling ROIPooling(IEnumerable<int> pooledSize, double spatialScale, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> rois)
		{
			return new SymbolOperators.ROIPooling(pooledSize, spatialScale, data, rois);
		}

		public static NDArray SequenceMask(NDArray data, NDArray sequenceLength, bool useSequenceLength = false, double value = 0.0, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SequenceMask");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004025704_002D1002(data, sequenceLength, 0, current));
			string[] parameterKeys = new string[3]
			{
				"use_sequence_length",
				"value",
				"axis"
			};
			string[] array = new string[3];
			bool flag = useSequenceLength;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = value;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = axis;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SequenceMask(IEnumerable<NDArray> outputArray, NDArray data, NDArray sequenceLength, bool useSequenceLength = false, double value = 0.0, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SequenceMask");
			string[] names2 = new string[3]
			{
				"use_sequence_length",
				"value",
				"axis"
			};
			string[] array = new string[3];
			bool flag = useSequenceLength;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = value;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = axis;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SequenceMask_004025792(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004025794_002D1003(data, sequenceLength, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004025795_002D1004(), outputArray)), names, vals);
		}

		public static SymbolOperators.SequenceMask SequenceMask([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> sequenceLength, [Optional] [OptionalArgument] FSharpOption<bool> useSequenceLength, [Optional] [OptionalArgument] FSharpOption<double> value, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.SequenceMask(data, sequenceLength, useSequenceLength, value, axis);
		}

		public static NDArray SliceChannel(NDArray data, int numOutputs, int axis = 1, bool squeezeAxis = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SliceChannel");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004025944_002D1005(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"num_outputs",
				"axis",
				"squeeze_axis"
			};
			string[] array = new string[3];
			object obj = numOutputs;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = squeezeAxis;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SliceChannel(IEnumerable<NDArray> outputArray, NDArray data, int numOutputs, int axis = 1, bool squeezeAxis = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SliceChannel");
			string[] names2 = new string[3]
			{
				"num_outputs",
				"axis",
				"squeeze_axis"
			};
			string[] array = new string[3];
			object obj = numOutputs;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = squeezeAxis;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SliceChannel_004026018(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026020_002D1006(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026021_002D1007(), outputArray)), names, vals);
		}

		public static SymbolOperators.SliceChannel SliceChannel(Symbol data, int numOutputs, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> squeezeAxis)
		{
			return new SymbolOperators.SliceChannel(data, numOutputs, axis, squeezeAxis);
		}

		public static SymbolOperators.SliceChannel SliceChannel(int numOutputs, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> squeezeAxis)
		{
			return new SymbolOperators.SliceChannel(numOutputs, data, axis, squeezeAxis);
		}

		public static NDArray SoftmaxOutput(NDArray data, NDArray label, double gradScale = 1.0, double ignoreLabel = -1.0, bool multiOutput = false, bool useIgnore = false, bool preserveShape = false, [Optional] GeneratedArgumentTypes.Normalization normalization, bool outGrad = false, double smoothAlpha = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SoftmaxOutput");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026260_002D1008(data, label, 0, current));
			string[] parameterKeys = new string[8]
			{
				"grad_scale",
				"ignore_label",
				"multi_output",
				"use_ignore",
				"preserve_shape",
				"normalization",
				"out_grad",
				"smooth_alpha"
			};
			string[] array = new string[8];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = ignoreLabel;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = multiOutput;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			bool flag2 = useIgnore;
			object obj10 = flag2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag3 = preserveShape;
			object obj13 = flag3;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16;
			if ((normalization == null) ? true : false)
			{
				obj16 = "null";
			}
			else if (normalization != null)
			{
				IFormattable formattable11 = normalization as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = normalization;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			bool flag4 = outGrad;
			object obj18 = flag4;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable13 = obj18 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[6] = (string)obj19;
			object obj21 = smoothAlpha;
			object obj22;
			if (obj21 != null)
			{
				IFormattable formattable15 = obj21 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj22 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj23 = obj21;
					obj22 = obj23.ToString();
				}
			}
			else
			{
				obj22 = "";
			}
			array[7] = (string)obj22;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SoftmaxOutput(IEnumerable<NDArray> outputArray, NDArray data, NDArray label, double gradScale = 1.0, double ignoreLabel = -1.0, bool multiOutput = false, bool useIgnore = false, bool preserveShape = false, [Optional] GeneratedArgumentTypes.Normalization normalization, bool outGrad = false, double smoothAlpha = 0.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SoftmaxOutput");
			string[] names2 = new string[8]
			{
				"grad_scale",
				"ignore_label",
				"multi_output",
				"use_ignore",
				"preserve_shape",
				"normalization",
				"out_grad",
				"smooth_alpha"
			};
			string[] array = new string[8];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = ignoreLabel;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = multiOutput;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			bool flag2 = useIgnore;
			object obj10 = flag2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			bool flag3 = preserveShape;
			object obj13 = flag3;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16;
			if ((normalization == null) ? true : false)
			{
				obj16 = "null";
			}
			else if (normalization != null)
			{
				IFormattable formattable11 = normalization as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj16 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = normalization;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[5] = (string)obj16;
			bool flag4 = outGrad;
			object obj18 = flag4;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable13 = obj18 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj19 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[6] = (string)obj19;
			object obj21 = smoothAlpha;
			object obj22;
			if (obj21 != null)
			{
				IFormattable formattable15 = obj21 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj22 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj23 = obj21;
					obj22 = obj23.ToString();
				}
			}
			else
			{
				obj22 = "";
			}
			array[7] = (string)obj22;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SoftmaxOutput_004026367(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026369_002D1009(data, label, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026370_002D1010(), outputArray)), names, vals);
		}

		public static SymbolOperators.SoftmaxOutput SoftmaxOutput([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> label, [Optional] [OptionalArgument] FSharpOption<double> gradScale, [Optional] [OptionalArgument] FSharpOption<double> ignoreLabel, [Optional] [OptionalArgument] FSharpOption<bool> multiOutput, [Optional] [OptionalArgument] FSharpOption<bool> useIgnore, [Optional] [OptionalArgument] FSharpOption<bool> preserveShape, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.Normalization> normalization, [Optional] [OptionalArgument] FSharpOption<bool> outGrad, [Optional] [OptionalArgument] FSharpOption<double> smoothAlpha)
		{
			return new SymbolOperators.SoftmaxOutput(data, label, gradScale, ignoreLabel, multiOutput, useIgnore, preserveShape, normalization, outGrad, smoothAlpha);
		}

		public static NDArray[] SgMkldnnConvNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sg_mkldnn_conv");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.SgMkldnnConvNDArray_004026475();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void SgMkldnnConv(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sg_mkldnn_conv");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004026482_002D96();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004026483_002D174();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SgMkldnnConv_004026484(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026487_002D1011(), outputArray)), names, vals);
		}

		public static SymbolOperators.SgMkldnnConv SgMkldnnConv()
		{
			return new SymbolOperators.SgMkldnnConv();
		}

		public static NDArray[] SgMkldnnFullyConnectedNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sg_mkldnn_fully_connected");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.SgMkldnnFullyConnectedNDArray_004026506();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void SgMkldnnFullyConnected(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sg_mkldnn_fully_connected");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004026513_002D97();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004026514_002D175();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SgMkldnnFullyConnected_004026515(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026518_002D1012(), outputArray)), names, vals);
		}

		public static SymbolOperators.SgMkldnnFullyConnected SgMkldnnFullyConnected()
		{
			return new SymbolOperators.SgMkldnnFullyConnected();
		}

		public static NDArray SwapAxis(NDArray data, int dim1 = 0, int dim2 = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SwapAxis");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026555_002D1013(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"dim1",
				"dim2"
			};
			string[] array = new string[2];
			object obj = dim1;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = dim2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SwapAxis(IEnumerable<NDArray> outputArray, NDArray data, int dim1 = 0, int dim2 = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SwapAxis");
			string[] names2 = new string[2]
			{
				"dim1",
				"dim2"
			};
			string[] array = new string[2];
			object obj = dim1;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = dim2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SwapAxis_004026588(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026590_002D1014(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026591_002D1015(), outputArray)), names, vals);
		}

		public static SymbolOperators.SwapAxis SwapAxis([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> dim1, [Optional] [OptionalArgument] FSharpOption<int> dim2)
		{
			return new SymbolOperators.SwapAxis(data, dim1, dim2);
		}

		public static NDArray[] AmpCast(NDArray data, DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("amp_cast");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026633_002D1016(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"dtype"
			};
			string[] array = new string[1];
			object obj;
			if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = dtype;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.AmpCast_004026636();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void AmpCast(IEnumerable<NDArray> outputArray, NDArray data, DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("amp_cast");
			string[] names2 = new string[1]
			{
				"dtype"
			};
			string[] array = new string[1];
			object obj;
			if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = dtype;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.AmpCast_004026650_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026652_002D1017(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026653_002D1018(), outputArray)), names, vals);
		}

		public static SymbolOperators.AmpCast AmpCast(Symbol data, DataType dtype)
		{
			return new SymbolOperators.AmpCast(data, dtype);
		}

		public static SymbolOperators.AmpCast AmpCast(DataType dtype, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.AmpCast(dtype, data);
		}

		public static NDArray[] AmpMulticast(params NDArray[] data, int numOutputs, bool castNarrow = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("amp_multicast");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004026692_002D1019();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_outputs",
				"cast_narrow"
			};
			string[] array2 = new string[2];
			object obj = numOutputs;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			bool flag = castNarrow;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			IntPtr[] array3 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.AmpMulticast_004026695();
			IntPtr[] array4 = array3;
			if (array4 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array5 = new NDArray[array4.Length];
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j] = val2.Invoke(array4[j]);
			}
			return array5;
		}

		public static void AmpMulticast(IEnumerable<NDArray> outputArray, params NDArray[] data, int numOutputs, bool castNarrow = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("amp_multicast");
			string[] names2 = new string[2]
			{
				"num_outputs",
				"cast_narrow"
			};
			string[] array = new string[2];
			object obj = numOutputs;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = castNarrow;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.AmpMulticast_004026711_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004026713_002D1020();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026714_002D1021(), outputArray)), names, vals);
		}

		public static SymbolOperators.AmpMulticast AmpMulticast(IEnumerable<Symbol> data, int numOutputs, [Optional] [OptionalArgument] FSharpOption<bool> castNarrow)
		{
			return new SymbolOperators.AmpMulticast(data, numOutputs, castNarrow);
		}

		public static SymbolOperators.AmpMulticast AmpMulticast(int numOutputs, [Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<bool> castNarrow)
		{
			return new SymbolOperators.AmpMulticast(numOutputs, data, castNarrow);
		}

		public static NDArray Max(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("max");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026767_002D1022(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004026769_002D1023(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Max(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("max");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004026795_002D176(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Max_004026796(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026798_002D1024(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026799_002D1025(), outputArray)), names, vals);
		}

		public static SymbolOperators.Max Max([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			return new SymbolOperators.Max(data, axis, keepdims, exclude);
		}

		public static NDArray Min(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("min");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026850_002D1026(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004026852_002D1027(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Min(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("min");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004026878_002D177(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Min_004026879(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026881_002D1028(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004026882_002D1029(), outputArray)), names, vals);
		}

		public static SymbolOperators.Min Min([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			return new SymbolOperators.Min(data, axis, keepdims, exclude);
		}

		public static NDArray Norm(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> ord, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> outDtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("norm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004026957_002D1030(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"ord",
				"axis",
				"out_dtype",
				"keepdims"
			};
			string[] array = new string[4];
			object obj;
			if (ord == null)
			{
				obj = "2";
			}
			else
			{
				FSharpOption<int> val = ord;
				int ord2 = val.get_Value();
				int num = ord2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (axis == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val2 = axis;
				IEnumerable<int> axis2 = val2.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004026959_002D1031(), axis2));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj4 = val3.Invoke(text2);
			}
			array[1] = (string)obj4;
			object obj5;
			if (outDtype == null)
			{
				obj5 = "None";
			}
			else
			{
				FSharpOption<DataType> val4 = outDtype;
				DataType outDtype2 = val4.get_Value();
				DataType dataType = outDtype2;
				object obj6 = dataType;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (keepdims == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = keepdims;
				bool keepdims2 = val5.get_Value();
				bool flag = keepdims2;
				object obj9 = flag;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Norm(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> ord, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> outDtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("norm");
			string[] names2 = new string[4]
			{
				"ord",
				"axis",
				"out_dtype",
				"keepdims"
			};
			string[] array = new string[4];
			object obj;
			if (ord == null)
			{
				obj = "2";
			}
			else
			{
				FSharpOption<int> val = ord;
				int ord2 = val.get_Value();
				int num = ord2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (axis == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val2 = axis;
				IEnumerable<int> axis2 = val2.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004027010_002D178(), axis2));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj4 = val3.Invoke(text2);
			}
			array[1] = (string)obj4;
			object obj5;
			if (outDtype == null)
			{
				obj5 = "None";
			}
			else
			{
				FSharpOption<DataType> val4 = outDtype;
				DataType outDtype2 = val4.get_Value();
				DataType dataType = outDtype2;
				object obj6 = dataType;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			object obj8;
			if (keepdims == null)
			{
				obj8 = "false";
			}
			else
			{
				FSharpOption<bool> val5 = keepdims;
				bool keepdims2 = val5.get_Value();
				bool flag = keepdims2;
				object obj9 = flag;
				if (obj9 != null)
				{
					IFormattable formattable5 = obj9 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj10 = obj9;
						obj8 = obj10.ToString();
					}
				}
				else
				{
					obj8 = "";
				}
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Norm_004027011(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027013_002D1032(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027014_002D1033(), outputArray)), names, vals);
		}

		public static SymbolOperators.Norm Norm([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> ord, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<DataType> outDtype, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			return new SymbolOperators.Norm(data, ord, axis, outDtype, keepdims);
		}

		public static NDArray Argmax(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("argmax");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027091_002D1034(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axis",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Argmax(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("argmax");
			string[] names2 = new string[2]
			{
				"axis",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Argmax_004027126(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027128_002D1035(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027129_002D1036(), outputArray)), names, vals);
		}

		public static SymbolOperators.Argmax Argmax([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			return new SymbolOperators.Argmax(data, axis, keepdims);
		}

		public static NDArray Argmin(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("argmin");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027191_002D1037(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axis",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Argmin(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("argmin");
			string[] names2 = new string[2]
			{
				"axis",
				"keepdims"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Argmin_004027226(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027228_002D1038(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027229_002D1039(), outputArray)), names, vals);
		}

		public static SymbolOperators.Argmin Argmin([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims)
		{
			return new SymbolOperators.Argmin(data, axis, keepdims);
		}

		public static NDArray ArgmaxChannel(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("argmax_channel");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027283_002D1040(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ArgmaxChannel(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("argmax_channel");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004027308_002D98();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004027309_002D179();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ArgmaxChannel_004027310(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027312_002D1041(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027313_002D1042(), outputArray)), names, vals);
		}

		public static SymbolOperators.ArgmaxChannel ArgmaxChannel([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ArgmaxChannel(data);
		}

		public static NDArray Pick(NDArray data, NDArray index, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PickMode> mode)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("pick");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027394_002D1043(data, index, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"mode"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (mode == null)
			{
				obj7 = "clip";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PickMode> val3 = mode;
				GeneratedArgumentTypes.PickMode mode2 = val3.get_Value();
				GeneratedArgumentTypes.PickMode pickMode = mode2;
				object obj8 = pickMode;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Pick(IEnumerable<NDArray> outputArray, NDArray data, NDArray index, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PickMode> mode)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("pick");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"mode"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (keepdims == null)
			{
				obj4 = "false";
			}
			else
			{
				FSharpOption<bool> val2 = keepdims;
				bool keepdims2 = val2.get_Value();
				bool flag = keepdims2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (mode == null)
			{
				obj7 = "clip";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.PickMode> val3 = mode;
				GeneratedArgumentTypes.PickMode mode2 = val3.get_Value();
				GeneratedArgumentTypes.PickMode pickMode = mode2;
				object obj8 = pickMode;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Pick_004027457(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027459_002D1044(data, index, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027460_002D1045(), outputArray)), names, vals);
		}

		public static SymbolOperators.Pick Pick([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> index, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.PickMode> mode)
		{
			return new SymbolOperators.Pick(data, index, axis, keepdims, mode);
		}

		public static NDArray BroadcastAxis(NDArray data, [Optional] IEnumerable<int> axis, [Optional] IEnumerable<int> size)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_axis");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027547_002D1046(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axis",
				"size"
			};
			string[] array = new string[2];
			object obj;
			if ((axis == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004027549_002D1047(), axis));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((size == null) ? true : false)
			{
				obj2 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004027549_002D1048(), size));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj2 = val2.Invoke(text4);
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void BroadcastAxis(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> axis, [Optional] IEnumerable<int> size)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_axis");
			string[] names2 = new string[2]
			{
				"axis",
				"size"
			};
			string[] array = new string[2];
			object obj;
			if ((axis == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004027582_002D180(), axis));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if ((size == null) ? true : false)
			{
				obj2 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004027582_002D181(), size));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj2 = val2.Invoke(text4);
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastAxis_004027583(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027585_002D1049(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027586_002D1050(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastAxis BroadcastAxis([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> size)
		{
			return new SymbolOperators.BroadcastAxis(data, axis, size);
		}

		public static NDArray BroadcastTo(NDArray data, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_to");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027645_002D1051(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004027647_002D1052(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void BroadcastTo(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_to");
			string[] names2 = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004027675_002D182(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastTo_004027676(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027678_002D1053(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027679_002D1054(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastTo BroadcastTo([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape)
		{
			return new SymbolOperators.BroadcastTo(data, shape);
		}

		public static NDArray[] BroadcastBackwardNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_broadcast_backward");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.BroadcastBackwardNDArray_004027714();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void BroadcastBackward(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_broadcast_backward");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004027718_002D99();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004027719_002D183();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastBackward_004027720(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027723_002D1055(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastBackward BroadcastBackward()
		{
			return new SymbolOperators.BroadcastBackward();
		}

		public static NDArray BroadcastLike(NDArray lhs, NDArray rhs, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> lhsAxes, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> rhsAxes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027756_002D1056(lhs, rhs, 0, current));
			string[] parameterKeys = new string[2]
			{
				"lhs_axes",
				"rhs_axes"
			};
			string[] array = new string[2];
			object obj;
			if (lhsAxes == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = lhsAxes;
				IEnumerable<int> lhsAxes2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004027758_002D1057(), lhsAxes2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (rhsAxes == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = rhsAxes;
				IEnumerable<int> rhsAxes2 = val3.get_Value();
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004027758_002D1058(), rhsAxes2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj2 = val4.Invoke(text4);
			}
			array[1] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void BroadcastLike(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> lhsAxes, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> rhsAxes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_like");
			string[] names2 = new string[2]
			{
				"lhs_axes",
				"rhs_axes"
			};
			string[] array = new string[2];
			object obj;
			if (lhsAxes == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = lhsAxes;
				IEnumerable<int> lhsAxes2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004027787_002D184(), lhsAxes2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (rhsAxes == null)
			{
				obj2 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val3 = rhsAxes;
				IEnumerable<int> rhsAxes2 = val3.get_Value();
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004027787_002D185(), rhsAxes2));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj2 = val4.Invoke(text4);
			}
			array[1] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastLike_004027788(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027790_002D1059(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027791_002D1060(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastLike BroadcastLike([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> lhsAxes, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> rhsAxes)
		{
			return new SymbolOperators.BroadcastLike(lhs, rhs, lhsAxes, rhsAxes);
		}

		public static NDArray Prod(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("prod");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027844_002D1061(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004027846_002D1062(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Prod(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("prod");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004027872_002D186(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Prod_004027873(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027875_002D1063(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027876_002D1064(), outputArray)), names, vals);
		}

		public static SymbolOperators.Prod Prod([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			return new SymbolOperators.Prod(data, axis, keepdims, exclude);
		}

		public static NDArray Nanprod(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("nanprod");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027929_002D1065(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004027931_002D1066(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Nanprod(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("nanprod");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004027959_002D187(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Nanprod_004027960(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004027962_002D1067(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004027963_002D1068(), outputArray)), names, vals);
		}

		public static SymbolOperators.Nanprod Nanprod([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			return new SymbolOperators.Nanprod(data, axis, keepdims, exclude);
		}

		public static NDArray Sum(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sum");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028050_002D1069(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004028052_002D1070(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Sum(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sum");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004028112_002D188(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Sum_004028113(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028115_002D1071(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004028116_002D1072(), outputArray)), names, vals);
		}

		public static SymbolOperators.Sum Sum([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			return new SymbolOperators.Sum(data, axis, keepdims, exclude);
		}

		public static NDArray Mean(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("mean");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028201_002D1073(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004028203_002D1074(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Mean(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("mean");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004028229_002D189(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Mean_004028230(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028232_002D1075(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004028233_002D1076(), outputArray)), names, vals);
		}

		public static SymbolOperators.Mean Mean([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			return new SymbolOperators.Mean(data, axis, keepdims, exclude);
		}

		public static NDArray Nansum(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("nansum");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028286_002D1077(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004028288_002D1078(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Nansum(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("nansum");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004028316_002D190(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Nansum_004028317(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028319_002D1079(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004028320_002D1080(), outputArray)), names, vals);
		}

		public static SymbolOperators.Nansum Nansum([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			return new SymbolOperators.Nansum(data, axis, keepdims, exclude);
		}

		public static NDArray CastStorage(NDArray data, StorageType stype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("cast_storage");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028394_002D1081(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"stype"
			};
			string[] array = new string[1];
			object obj;
			if (stype != null)
			{
				IFormattable formattable = stype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = stype;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void CastStorage(IEnumerable<NDArray> outputArray, NDArray data, StorageType stype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("cast_storage");
			string[] names2 = new string[1]
			{
				"stype"
			};
			string[] array = new string[1];
			object obj;
			if (stype != null)
			{
				IFormattable formattable = stype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = stype;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.CastStorage_004028444(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028446_002D1082(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004028447_002D1083(), outputArray)), names, vals);
		}

		public static SymbolOperators.CastStorage CastStorage(Symbol data, StorageType stype)
		{
			return new SymbolOperators.CastStorage(data, stype);
		}

		public static SymbolOperators.CastStorage CastStorage(StorageType stype, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.CastStorage(stype, data);
		}

		public static NDArray Where(NDArray condition, NDArray x, NDArray y)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("where");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028572_002D1084(condition, x, y, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Where(IEnumerable<NDArray> outputArray, NDArray condition, NDArray x, NDArray y)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("where");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004028610_002D100();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004028611_002D191();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Where_004028612(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028614_002D1085(condition, x, y, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004028615_002D1086(), outputArray)), names, vals);
		}

		public static SymbolOperators.Where Where([Optional] [OptionalArgument] FSharpOption<Symbol> condition, [Optional] [OptionalArgument] FSharpOption<Symbol> x, [Optional] [OptionalArgument] FSharpOption<Symbol> y)
		{
			return new SymbolOperators.Where(condition, x, y);
		}

		public static NDArray Diag(NDArray data, int k = 0, int axis1 = 0, int axis2 = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("diag");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028716_002D1087(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"k",
				"axis1",
				"axis2"
			};
			string[] array = new string[3];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = axis2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Diag(IEnumerable<NDArray> outputArray, NDArray data, int k = 0, int axis1 = 0, int axis2 = 1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("diag");
			string[] names2 = new string[3]
			{
				"k",
				"axis1",
				"axis2"
			};
			string[] array = new string[3];
			object obj = k;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis1;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = axis2;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Diag_004028784(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028786_002D1088(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004028787_002D1089(), outputArray)), names, vals);
		}

		public static SymbolOperators.Diag Diag([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<int> axis1, [Optional] [OptionalArgument] FSharpOption<int> axis2)
		{
			return new SymbolOperators.Diag(data, k, axis1, axis2);
		}

		public static NDArray Dot(NDArray lhs, NDArray rhs, bool transposeA = false, bool transposeB = false, [Optional] StorageType forwardStype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("dot");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028913_002D1090(lhs, rhs, 0, current));
			string[] parameterKeys = new string[3]
			{
				"transpose_a",
				"transpose_b",
				"forward_stype"
			};
			string[] array = new string[3];
			bool flag = transposeA;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = transposeB;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((forwardStype == null) ? true : false)
			{
				obj7 = "None";
			}
			else if (forwardStype != null)
			{
				IFormattable formattable5 = forwardStype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = forwardStype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Dot(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs, bool transposeA = false, bool transposeB = false, [Optional] StorageType forwardStype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("dot");
			string[] names2 = new string[3]
			{
				"transpose_a",
				"transpose_b",
				"forward_stype"
			};
			string[] array = new string[3];
			bool flag = transposeA;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = transposeB;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((forwardStype == null) ? true : false)
			{
				obj7 = "None";
			}
			else if (forwardStype != null)
			{
				IFormattable formattable5 = forwardStype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = forwardStype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Dot_004028979(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004028981_002D1091(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004028982_002D1092(), outputArray)), names, vals);
		}

		public static SymbolOperators.Dot Dot([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs, [Optional] [OptionalArgument] FSharpOption<bool> transposeA, [Optional] [OptionalArgument] FSharpOption<bool> transposeB, [Optional] [OptionalArgument] FSharpOption<StorageType> forwardStype)
		{
			return new SymbolOperators.Dot(lhs, rhs, transposeA, transposeB, forwardStype);
		}

		public static NDArray BatchDot(NDArray lhs, NDArray rhs, bool transposeA = false, bool transposeB = false, [Optional] StorageType forwardStype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("batch_dot");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029068_002D1093(lhs, rhs, 0, current));
			string[] parameterKeys = new string[3]
			{
				"transpose_a",
				"transpose_b",
				"forward_stype"
			};
			string[] array = new string[3];
			bool flag = transposeA;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = transposeB;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((forwardStype == null) ? true : false)
			{
				obj7 = "None";
			}
			else if (forwardStype != null)
			{
				IFormattable formattable5 = forwardStype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = forwardStype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void BatchDot(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs, bool transposeA = false, bool transposeB = false, [Optional] StorageType forwardStype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("batch_dot");
			string[] names2 = new string[3]
			{
				"transpose_a",
				"transpose_b",
				"forward_stype"
			};
			string[] array = new string[3];
			bool flag = transposeA;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = transposeB;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((forwardStype == null) ? true : false)
			{
				obj7 = "None";
			}
			else if (forwardStype != null)
			{
				IFormattable formattable5 = forwardStype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = forwardStype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BatchDot_004029101(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029103_002D1094(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029104_002D1095(), outputArray)), names, vals);
		}

		public static SymbolOperators.BatchDot BatchDot([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs, [Optional] [OptionalArgument] FSharpOption<bool> transposeA, [Optional] [OptionalArgument] FSharpOption<bool> transposeB, [Optional] [OptionalArgument] FSharpOption<StorageType> forwardStype)
		{
			return new SymbolOperators.BatchDot(lhs, rhs, transposeA, transposeB, forwardStype);
		}

		public static NDArray BroadcastAdd(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_add");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029161_002D1096(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastAdd(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_add");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029196_002D101();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029197_002D192();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastAdd_004029198(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029200_002D1097(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029201_002D1098(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastAdd BroadcastAdd([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastAdd(lhs, rhs);
		}

		public static NDArray BroadcastSub(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_sub");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029268_002D1099(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastSub(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_sub");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029303_002D102();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029304_002D193();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastSub_004029305(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029307_002D1100(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029308_002D1101(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastSub BroadcastSub([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastSub(lhs, rhs);
		}

		public static NDArray BroadcastMul(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_mul");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029369_002D1102(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastMul(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_mul");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029398_002D103();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029399_002D194();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastMul_004029400(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029402_002D1103(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029403_002D1104(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastMul BroadcastMul([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastMul(lhs, rhs);
		}

		public static NDArray BroadcastDiv(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_div");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029458_002D1105(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastDiv(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_div");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029487_002D104();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029488_002D195();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastDiv_004029489(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029491_002D1106(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029492_002D1107(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastDiv BroadcastDiv([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastDiv(lhs, rhs);
		}

		public static NDArray BroadcastMod(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_mod");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029543_002D1108(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastMod(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_mod");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029568_002D105();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029569_002D196();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastMod_004029570(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029572_002D1109(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029573_002D1110(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastMod BroadcastMod([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastMod(lhs, rhs);
		}

		public static NDArray BroadcastPower(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_power");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029620_002D1111(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastPower(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_power");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029645_002D106();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029646_002D197();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastPower_004029647(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029649_002D1112(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029650_002D1113(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastPower BroadcastPower([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastPower(lhs, rhs);
		}

		public static NDArray BroadcastMaximum(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_maximum");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029699_002D1114(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastMaximum(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_maximum");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029726_002D107();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029727_002D198();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastMaximum_004029728(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029730_002D1115(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029731_002D1116(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastMaximum BroadcastMaximum([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastMaximum(lhs, rhs);
		}

		public static NDArray BroadcastMinimum(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_minimum");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029782_002D1117(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastMinimum(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_minimum");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029809_002D108();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029810_002D199();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastMinimum_004029811(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029813_002D1118(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029814_002D1119(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastMinimum BroadcastMinimum([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastMinimum(lhs, rhs);
		}

		public static NDArray BroadcastHypot(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_hypot");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029871_002D1120(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastHypot(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_hypot");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029904_002D109();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029905_002D200();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastHypot_004029906(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029908_002D1121(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029909_002D1122(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastHypot BroadcastHypot([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastHypot(lhs, rhs);
		}

		public static NDArray BroadcastEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029964_002D1123(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004029989_002D110();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004029990_002D201();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastEqual_004029991(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004029993_002D1124(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004029994_002D1125(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastEqual BroadcastEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastEqual(lhs, rhs);
		}

		public static NDArray BroadcastNotEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_not_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030040_002D1126(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastNotEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_not_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030065_002D111();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030066_002D202();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastNotEqual_004030067(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030069_002D1127(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030070_002D1128(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastNotEqual BroadcastNotEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastNotEqual(lhs, rhs);
		}

		public static NDArray BroadcastGreater(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_greater");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030116_002D1129(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastGreater(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_greater");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030141_002D112();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030142_002D203();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastGreater_004030143(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030145_002D1130(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030146_002D1131(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastGreater BroadcastGreater([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastGreater(lhs, rhs);
		}

		public static NDArray BroadcastGreaterEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_greater_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030192_002D1132(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastGreaterEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_greater_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030217_002D113();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030218_002D204();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastGreaterEqual_004030219(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030221_002D1133(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030222_002D1134(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastGreaterEqual BroadcastGreaterEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastGreaterEqual(lhs, rhs);
		}

		public static NDArray BroadcastLesser(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_lesser");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030268_002D1135(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastLesser(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_lesser");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030293_002D114();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030294_002D205();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastLesser_004030295(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030297_002D1136(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030298_002D1137(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastLesser BroadcastLesser([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastLesser(lhs, rhs);
		}

		public static NDArray BroadcastLesserEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_lesser_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030344_002D1138(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastLesserEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_lesser_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030369_002D115();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030370_002D206();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastLesserEqual_004030371(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030373_002D1139(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030374_002D1140(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastLesserEqual BroadcastLesserEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastLesserEqual(lhs, rhs);
		}

		public static NDArray BroadcastLogicalAnd(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_logical_and");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030420_002D1141(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastLogicalAnd(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_logical_and");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030445_002D116();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030446_002D207();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastLogicalAnd_004030447(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030449_002D1142(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030450_002D1143(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastLogicalAnd BroadcastLogicalAnd([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastLogicalAnd(lhs, rhs);
		}

		public static NDArray BroadcastLogicalOr(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_logical_or");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030496_002D1144(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastLogicalOr(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_logical_or");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030521_002D117();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030522_002D208();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastLogicalOr_004030523(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030525_002D1145(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030526_002D1146(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastLogicalOr BroadcastLogicalOr([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastLogicalOr(lhs, rhs);
		}

		public static NDArray BroadcastLogicalXor(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_logical_xor");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030572_002D1147(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BroadcastLogicalXor(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("broadcast_logical_xor");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030597_002D118();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030598_002D209();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BroadcastLogicalXor_004030599(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030601_002D1148(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030602_002D1149(), outputArray)), names, vals);
		}

		public static SymbolOperators.BroadcastLogicalXor BroadcastLogicalXor([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.BroadcastLogicalXor(lhs, rhs);
		}

		public static NDArray ElemwiseAdd(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("elemwise_add");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030645_002D1150(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ElemwiseAdd(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("elemwise_add");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030667_002D119();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030668_002D210();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ElemwiseAdd_004030669(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030671_002D1151(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030672_002D1152(), outputArray)), names, vals);
		}

		public static SymbolOperators.ElemwiseAdd ElemwiseAdd([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.ElemwiseAdd(lhs, rhs);
		}

		public static NDArray GradAdd(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_grad_add");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030699_002D1153(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void GradAdd(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_grad_add");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030708_002D120();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030709_002D211();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.GradAdd_004030710(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030712_002D1154(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030713_002D1155(), outputArray)), names, vals);
		}

		public static SymbolOperators.GradAdd GradAdd([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.GradAdd(lhs, rhs);
		}

		public static NDArray ElemwiseSub(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("elemwise_sub");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030741_002D1156(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ElemwiseSub(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("elemwise_sub");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030763_002D121();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030764_002D212();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ElemwiseSub_004030765(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030767_002D1157(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030768_002D1158(), outputArray)), names, vals);
		}

		public static SymbolOperators.ElemwiseSub ElemwiseSub([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.ElemwiseSub(lhs, rhs);
		}

		public static NDArray ElemwiseMul(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("elemwise_mul");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030808_002D1159(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ElemwiseMul(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("elemwise_mul");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030829_002D122();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030830_002D213();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ElemwiseMul_004030831(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030833_002D1160(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030834_002D1161(), outputArray)), names, vals);
		}

		public static SymbolOperators.ElemwiseMul ElemwiseMul([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.ElemwiseMul(lhs, rhs);
		}

		public static NDArray ElemwiseDiv(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("elemwise_div");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030866_002D1162(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ElemwiseDiv(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("elemwise_div");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030880_002D123();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030881_002D214();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ElemwiseDiv_004030882(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030884_002D1163(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030885_002D1164(), outputArray)), names, vals);
		}

		public static SymbolOperators.ElemwiseDiv ElemwiseDiv([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.ElemwiseDiv(lhs, rhs);
		}

		public static NDArray Mod(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_mod");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030905_002D1165(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Mod(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_mod");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030914_002D124();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030915_002D215();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Mod_004030916(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030918_002D1166(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030919_002D1167(), outputArray)), names, vals);
		}

		public static SymbolOperators.Mod Mod([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.Mod(lhs, rhs);
		}

		public static NDArray Power(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_power");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030934_002D1168(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Power(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_power");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030943_002D125();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030944_002D216();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Power_004030945(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030947_002D1169(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030948_002D1170(), outputArray)), names, vals);
		}

		public static SymbolOperators.Power Power([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.Power(lhs, rhs);
		}

		public static NDArray Maximum(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_maximum");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030963_002D1171(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Maximum(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_maximum");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004030972_002D126();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004030973_002D217();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Maximum_004030974(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030976_002D1172(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004030977_002D1173(), outputArray)), names, vals);
		}

		public static SymbolOperators.Maximum Maximum([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.Maximum(lhs, rhs);
		}

		public static NDArray Minimum(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_minimum");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004030992_002D1174(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Minimum(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_minimum");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031001_002D127();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031002_002D218();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Minimum_004031003(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031005_002D1175(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031006_002D1176(), outputArray)), names, vals);
		}

		public static SymbolOperators.Minimum Minimum([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.Minimum(lhs, rhs);
		}

		public static NDArray Hypot(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_hypot");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031026_002D1177(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Hypot(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_hypot");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031040_002D128();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031041_002D219();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Hypot_004031042(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031044_002D1178(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031045_002D1179(), outputArray)), names, vals);
		}

		public static SymbolOperators.Hypot Hypot([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.Hypot(lhs, rhs);
		}

		public static NDArray Equal(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031065_002D1180(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Equal(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031074_002D129();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031075_002D220();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Equal_004031076(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031078_002D1181(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031079_002D1182(), outputArray)), names, vals);
		}

		public static SymbolOperators.Equal Equal([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.Equal(lhs, rhs);
		}

		public static NDArray NotEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_not_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031093_002D1183(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void NotEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_not_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031102_002D130();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031103_002D221();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NotEqual_004031104(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031106_002D1184(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031107_002D1185(), outputArray)), names, vals);
		}

		public static SymbolOperators.NotEqual NotEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.NotEqual(lhs, rhs);
		}

		public static NDArray Greater(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_greater");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031121_002D1186(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Greater(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_greater");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031130_002D131();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031131_002D222();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Greater_004031132(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031134_002D1187(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031135_002D1188(), outputArray)), names, vals);
		}

		public static SymbolOperators.Greater Greater([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.Greater(lhs, rhs);
		}

		public static NDArray GreaterEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_greater_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031149_002D1189(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void GreaterEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_greater_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031158_002D132();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031159_002D223();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.GreaterEqual_004031160(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031162_002D1190(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031163_002D1191(), outputArray)), names, vals);
		}

		public static SymbolOperators.GreaterEqual GreaterEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.GreaterEqual(lhs, rhs);
		}

		public static NDArray Lesser(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_lesser");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031177_002D1192(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Lesser(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_lesser");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031186_002D133();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031187_002D224();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Lesser_004031188(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031190_002D1193(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031191_002D1194(), outputArray)), names, vals);
		}

		public static SymbolOperators.Lesser Lesser([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.Lesser(lhs, rhs);
		}

		public static NDArray LesserEqual(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_lesser_equal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031205_002D1195(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LesserEqual(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_lesser_equal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031214_002D134();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031215_002D225();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LesserEqual_004031216(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031218_002D1196(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031219_002D1197(), outputArray)), names, vals);
		}

		public static SymbolOperators.LesserEqual LesserEqual([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.LesserEqual(lhs, rhs);
		}

		public static NDArray LogicalAnd(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_and");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031233_002D1198(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LogicalAnd(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_and");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031242_002D135();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031243_002D226();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogicalAnd_004031244(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031246_002D1199(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031247_002D1200(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogicalAnd LogicalAnd([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.LogicalAnd(lhs, rhs);
		}

		public static NDArray LogicalOr(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_or");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031261_002D1201(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LogicalOr(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_or");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031270_002D136();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031271_002D227();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogicalOr_004031272(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031274_002D1202(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031275_002D1203(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogicalOr LogicalOr([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.LogicalOr(lhs, rhs);
		}

		public static NDArray LogicalXor(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_xor");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031289_002D1204(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LogicalXor(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_xor");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004031298_002D137();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004031299_002D228();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogicalXor_004031300(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031302_002D1205(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031303_002D1206(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogicalXor LogicalXor([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.LogicalXor(lhs, rhs);
		}

		public static NDArray PlusScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_plus_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031317_002D1207(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void PlusScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_plus_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.PlusScalar_004031328(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031330_002D1208(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031331_002D1209(), outputArray)), names, vals);
		}

		public static SymbolOperators.PlusScalar PlusScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.PlusScalar(data, scalar);
		}

		public static SymbolOperators.PlusScalar PlusScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.PlusScalar(scalar, data);
		}

		public static NDArray MinusScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_minus_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031349_002D1210(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MinusScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_minus_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MinusScalar_004031360(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031362_002D1211(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031363_002D1212(), outputArray)), names, vals);
		}

		public static SymbolOperators.MinusScalar MinusScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.MinusScalar(data, scalar);
		}

		public static SymbolOperators.MinusScalar MinusScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.MinusScalar(scalar, data);
		}

		public static NDArray RminusScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rminus_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031381_002D1213(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RminusScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rminus_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RminusScalar_004031392(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031394_002D1214(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031395_002D1215(), outputArray)), names, vals);
		}

		public static SymbolOperators.RminusScalar RminusScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.RminusScalar(data, scalar);
		}

		public static SymbolOperators.RminusScalar RminusScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.RminusScalar(scalar, data);
		}

		public static NDArray MulScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_mul_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031424_002D1216(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MulScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_mul_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MulScalar_004031446(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031448_002D1217(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031449_002D1218(), outputArray)), names, vals);
		}

		public static SymbolOperators.MulScalar MulScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.MulScalar(data, scalar);
		}

		public static SymbolOperators.MulScalar MulScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.MulScalar(scalar, data);
		}

		public static NDArray DivScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_div_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031501_002D1219(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void DivScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_div_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.DivScalar_004031523(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031525_002D1220(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031526_002D1221(), outputArray)), names, vals);
		}

		public static SymbolOperators.DivScalar DivScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.DivScalar(data, scalar);
		}

		public static SymbolOperators.DivScalar DivScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.DivScalar(scalar, data);
		}

		public static NDArray RdivScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rdiv_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031567_002D1222(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RdivScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rdiv_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RdivScalar_004031578(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031580_002D1223(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031581_002D1224(), outputArray)), names, vals);
		}

		public static SymbolOperators.RdivScalar RdivScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.RdivScalar(data, scalar);
		}

		public static SymbolOperators.RdivScalar RdivScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.RdivScalar(scalar, data);
		}

		public static NDArray ModScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_mod_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031600_002D1225(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ModScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_mod_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ModScalar_004031611(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031613_002D1226(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031614_002D1227(), outputArray)), names, vals);
		}

		public static SymbolOperators.ModScalar ModScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.ModScalar(data, scalar);
		}

		public static SymbolOperators.ModScalar ModScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ModScalar(scalar, data);
		}

		public static NDArray RmodScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rmod_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031633_002D1228(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RmodScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rmod_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RmodScalar_004031644(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031646_002D1229(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031647_002D1230(), outputArray)), names, vals);
		}

		public static SymbolOperators.RmodScalar RmodScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.RmodScalar(data, scalar);
		}

		public static SymbolOperators.RmodScalar RmodScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.RmodScalar(scalar, data);
		}

		public static NDArray MaximumScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_maximum_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031666_002D1231(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MaximumScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_maximum_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MaximumScalar_004031677(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031679_002D1232(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031680_002D1233(), outputArray)), names, vals);
		}

		public static SymbolOperators.MaximumScalar MaximumScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.MaximumScalar(data, scalar);
		}

		public static SymbolOperators.MaximumScalar MaximumScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.MaximumScalar(scalar, data);
		}

		public static NDArray MinimumScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_minimum_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031699_002D1234(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MinimumScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_minimum_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MinimumScalar_004031710(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031712_002D1235(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031713_002D1236(), outputArray)), names, vals);
		}

		public static SymbolOperators.MinimumScalar MinimumScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.MinimumScalar(data, scalar);
		}

		public static SymbolOperators.MinimumScalar MinimumScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.MinimumScalar(scalar, data);
		}

		public static NDArray PowerScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_power_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031732_002D1237(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void PowerScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_power_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.PowerScalar_004031743(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031745_002D1238(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031746_002D1239(), outputArray)), names, vals);
		}

		public static SymbolOperators.PowerScalar PowerScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.PowerScalar(data, scalar);
		}

		public static SymbolOperators.PowerScalar PowerScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.PowerScalar(scalar, data);
		}

		public static NDArray RpowerScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rpower_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031765_002D1240(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RpowerScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_rpower_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RpowerScalar_004031776(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031778_002D1241(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031779_002D1242(), outputArray)), names, vals);
		}

		public static SymbolOperators.RpowerScalar RpowerScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.RpowerScalar(data, scalar);
		}

		public static SymbolOperators.RpowerScalar RpowerScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.RpowerScalar(scalar, data);
		}

		public static NDArray HypotScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_hypot_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031798_002D1243(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void HypotScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_hypot_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.HypotScalar_004031809(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031811_002D1244(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031812_002D1245(), outputArray)), names, vals);
		}

		public static SymbolOperators.HypotScalar HypotScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.HypotScalar(data, scalar);
		}

		public static SymbolOperators.HypotScalar HypotScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.HypotScalar(scalar, data);
		}

		public static NDArray SmoothL1(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("smooth_l1");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031851_002D1246(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SmoothL1(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("smooth_l1");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SmoothL1_004031882(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031884_002D1247(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031885_002D1248(), outputArray)), names, vals);
		}

		public static SymbolOperators.SmoothL1 SmoothL1(Symbol data, double scalar)
		{
			return new SymbolOperators.SmoothL1(data, scalar);
		}

		public static SymbolOperators.SmoothL1 SmoothL1(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.SmoothL1(scalar, data);
		}

		public static NDArray EqualScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_equal_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031944_002D1249(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void EqualScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_equal_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.EqualScalar_004031955(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031957_002D1250(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031958_002D1251(), outputArray)), names, vals);
		}

		public static SymbolOperators.EqualScalar EqualScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.EqualScalar(data, scalar);
		}

		public static SymbolOperators.EqualScalar EqualScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.EqualScalar(scalar, data);
		}

		public static NDArray NotEqualScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_not_equal_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031976_002D1252(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void NotEqualScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_not_equal_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.NotEqualScalar_004031987(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004031989_002D1253(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004031990_002D1254(), outputArray)), names, vals);
		}

		public static SymbolOperators.NotEqualScalar NotEqualScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.NotEqualScalar(data, scalar);
		}

		public static SymbolOperators.NotEqualScalar NotEqualScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.NotEqualScalar(scalar, data);
		}

		public static NDArray GreaterScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_greater_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032008_002D1255(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void GreaterScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_greater_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.GreaterScalar_004032019(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032021_002D1256(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032022_002D1257(), outputArray)), names, vals);
		}

		public static SymbolOperators.GreaterScalar GreaterScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.GreaterScalar(data, scalar);
		}

		public static SymbolOperators.GreaterScalar GreaterScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.GreaterScalar(scalar, data);
		}

		public static NDArray GreaterEqualScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_greater_equal_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032040_002D1258(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void GreaterEqualScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_greater_equal_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.GreaterEqualScalar_004032051(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032053_002D1259(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032054_002D1260(), outputArray)), names, vals);
		}

		public static SymbolOperators.GreaterEqualScalar GreaterEqualScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.GreaterEqualScalar(data, scalar);
		}

		public static SymbolOperators.GreaterEqualScalar GreaterEqualScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.GreaterEqualScalar(scalar, data);
		}

		public static NDArray LesserScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_lesser_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032072_002D1261(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LesserScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_lesser_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LesserScalar_004032083(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032085_002D1262(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032086_002D1263(), outputArray)), names, vals);
		}

		public static SymbolOperators.LesserScalar LesserScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.LesserScalar(data, scalar);
		}

		public static SymbolOperators.LesserScalar LesserScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.LesserScalar(scalar, data);
		}

		public static NDArray LesserEqualScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_lesser_equal_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032104_002D1264(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LesserEqualScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_lesser_equal_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LesserEqualScalar_004032115(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032117_002D1265(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032118_002D1266(), outputArray)), names, vals);
		}

		public static SymbolOperators.LesserEqualScalar LesserEqualScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.LesserEqualScalar(data, scalar);
		}

		public static SymbolOperators.LesserEqualScalar LesserEqualScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.LesserEqualScalar(scalar, data);
		}

		public static NDArray LogicalAndScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_and_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032136_002D1267(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LogicalAndScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_and_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogicalAndScalar_004032147(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032149_002D1268(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032150_002D1269(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogicalAndScalar LogicalAndScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.LogicalAndScalar(data, scalar);
		}

		public static SymbolOperators.LogicalAndScalar LogicalAndScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.LogicalAndScalar(scalar, data);
		}

		public static NDArray LogicalOrScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_or_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032168_002D1270(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LogicalOrScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_or_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogicalOrScalar_004032179(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032181_002D1271(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032182_002D1272(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogicalOrScalar LogicalOrScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.LogicalOrScalar(data, scalar);
		}

		public static SymbolOperators.LogicalOrScalar LogicalOrScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.LogicalOrScalar(scalar, data);
		}

		public static NDArray LogicalXorScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_xor_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032200_002D1273(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LogicalXorScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_logical_xor_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogicalXorScalar_004032211(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032213_002D1274(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032214_002D1275(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogicalXorScalar LogicalXorScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.LogicalXorScalar(data, scalar);
		}

		public static SymbolOperators.LogicalXorScalar LogicalXorScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.LogicalXorScalar(scalar, data);
		}

		public static NDArray ScatterElemwiseDiv(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_scatter_elemwise_div");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032245_002D1276(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ScatterElemwiseDiv(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_scatter_elemwise_div");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004032267_002D138();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004032268_002D229();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ScatterElemwiseDiv_004032269(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032271_002D1277(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032272_002D1278(), outputArray)), names, vals);
		}

		public static SymbolOperators.ScatterElemwiseDiv ScatterElemwiseDiv([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.ScatterElemwiseDiv(lhs, rhs);
		}

		public static NDArray ScatterPlusScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_scatter_plus_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032311_002D1279(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ScatterPlusScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_scatter_plus_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ScatterPlusScalar_004032334(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032336_002D1280(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032337_002D1281(), outputArray)), names, vals);
		}

		public static SymbolOperators.ScatterPlusScalar ScatterPlusScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.ScatterPlusScalar(data, scalar);
		}

		public static SymbolOperators.ScatterPlusScalar ScatterPlusScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ScatterPlusScalar(scalar, data);
		}

		public static NDArray ScatterMinusScalar(NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_scatter_minus_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032391_002D1282(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ScatterMinusScalar(IEnumerable<NDArray> outputArray, NDArray data, double scalar)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_scatter_minus_scalar");
			string[] names2 = new string[1]
			{
				"scalar"
			};
			string[] array = new string[1];
			object obj = scalar;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ScatterMinusScalar_004032414(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032416_002D1283(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032417_002D1284(), outputArray)), names, vals);
		}

		public static SymbolOperators.ScatterMinusScalar ScatterMinusScalar(Symbol data, double scalar)
		{
			return new SymbolOperators.ScatterMinusScalar(data, scalar);
		}

		public static SymbolOperators.ScatterMinusScalar ScatterMinusScalar(double scalar, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ScatterMinusScalar(scalar, data);
		}

		public static NDArray AddN(params NDArray[] args)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("add_n");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004032475_002D1285();
			if (args == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[args.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(args[i]);
			}
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void AddN(IEnumerable<NDArray> outputArray, params NDArray[] args)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("add_n");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004032500_002D139();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004032501_002D230();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.AddN_004032502(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004032504_002D1286();
			if (args == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[args.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(args[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032505_002D1287(), outputArray)), names, vals);
		}

		public static SymbolOperators.AddN AddN(params Symbol[] args)
		{
			return new SymbolOperators.AddN(args);
		}

		public static NDArray Relu(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("relu");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032548_002D1288(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Relu(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("relu");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004032570_002D140();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004032571_002D231();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Relu_004032572(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032574_002D1289(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032575_002D1290(), outputArray)), names, vals);
		}

		public static SymbolOperators.Relu Relu([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Relu(data);
		}

		public static NDArray Sigmoid(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sigmoid");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032612_002D1291(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Sigmoid(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sigmoid");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004032630_002D141();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004032631_002D232();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Sigmoid_004032632(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032634_002D1292(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032635_002D1293(), outputArray)), names, vals);
		}

		public static SymbolOperators.Sigmoid Sigmoid([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Sigmoid(data);
		}

		public static NDArray HardSigmoid(NDArray data, double alpha = 0.2, double beta = 0.5)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("hard_sigmoid");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032668_002D1294(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"alpha",
				"beta"
			};
			string[] array = new string[2];
			object obj = alpha;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = beta;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void HardSigmoid(IEnumerable<NDArray> outputArray, NDArray data, double alpha = 0.2, double beta = 0.5)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("hard_sigmoid");
			string[] names2 = new string[2]
			{
				"alpha",
				"beta"
			};
			string[] array = new string[2];
			object obj = alpha;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = beta;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.HardSigmoid_004032688(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032690_002D1295(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032691_002D1296(), outputArray)), names, vals);
		}

		public static SymbolOperators.HardSigmoid HardSigmoid([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> alpha, [Optional] [OptionalArgument] FSharpOption<double> beta)
		{
			return new SymbolOperators.HardSigmoid(data, alpha, beta);
		}

		public static NDArray Softsign(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("softsign");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032724_002D1297(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Softsign(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("softsign");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004032742_002D142();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004032743_002D233();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Softsign_004032744(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032746_002D1298(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032747_002D1299(), outputArray)), names, vals);
		}

		public static SymbolOperators.Softsign Softsign([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Softsign(data);
		}

		public static NDArray Copy(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_copy");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032773_002D1300(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Copy(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_copy");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004032784_002D143();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004032785_002D234();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Copy_004032786_002D2(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032788_002D1301(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032789_002D1302(), outputArray)), names, vals);
		}

		public static SymbolOperators.Copy Copy([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Copy(data);
		}

		public static NDArray BlockGrad(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("BlockGrad");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032834_002D1303(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BlockGrad(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("BlockGrad");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004032870_002D144();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004032871_002D235();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BlockGrad_004032872(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032874_002D1304(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032875_002D1305(), outputArray)), names, vals);
		}

		public static SymbolOperators.BlockGrad BlockGrad([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.BlockGrad(data);
		}

		public static NDArray MakeLoss(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("make_loss");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032939_002D1306(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void MakeLoss(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("make_loss");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004032971_002D145();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004032972_002D236();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MakeLoss_004032973(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004032975_002D1307(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004032976_002D1308(), outputArray)), names, vals);
		}

		public static SymbolOperators.MakeLoss MakeLoss([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.MakeLoss(data);
		}

		public static NDArray[] IdentityWithAttrLikeRhs(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_identity_with_attr_like_rhs");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033013_002D1309(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.IdentityWithAttrLikeRhs_004033016();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void IdentityWithAttrLikeRhs(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_identity_with_attr_like_rhs");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033022_002D146();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033023_002D237();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.IdentityWithAttrLikeRhs_004033024_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033026_002D1310(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033027_002D1311(), outputArray)), names, vals);
		}

		public static SymbolOperators.IdentityWithAttrLikeRhs IdentityWithAttrLikeRhs([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs)
		{
			return new SymbolOperators.IdentityWithAttrLikeRhs(lhs, rhs);
		}

		public static NDArray ReshapeLike(NDArray lhs, NDArray rhs, [Optional] [OptionalArgument] FSharpOption<int> lhsBegin, [Optional] [OptionalArgument] FSharpOption<int> lhsEnd, [Optional] [OptionalArgument] FSharpOption<int> rhsBegin, [Optional] [OptionalArgument] FSharpOption<int> rhsEnd)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("reshape_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033078_002D1312(lhs, rhs, 0, current));
			string[] parameterKeys = new string[4]
			{
				"lhs_begin",
				"lhs_end",
				"rhs_begin",
				"rhs_end"
			};
			string[] array = new string[4];
			object obj;
			if (lhsBegin == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = lhsBegin;
				int lhsBegin2 = val.get_Value();
				int num = lhsBegin2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (lhsEnd == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<int> val2 = lhsEnd;
				int lhsEnd2 = val2.get_Value();
				int num2 = lhsEnd2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (rhsBegin == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<int> val3 = rhsBegin;
				int rhsBegin2 = val3.get_Value();
				int num3 = rhsBegin2;
				object obj8 = num3;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (rhsEnd == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<int> val4 = rhsEnd;
				int rhsEnd2 = val4.get_Value();
				int num4 = rhsEnd2;
				object obj11 = num4;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ReshapeLike(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs, [Optional] [OptionalArgument] FSharpOption<int> lhsBegin, [Optional] [OptionalArgument] FSharpOption<int> lhsEnd, [Optional] [OptionalArgument] FSharpOption<int> rhsBegin, [Optional] [OptionalArgument] FSharpOption<int> rhsEnd)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("reshape_like");
			string[] names2 = new string[4]
			{
				"lhs_begin",
				"lhs_end",
				"rhs_begin",
				"rhs_end"
			};
			string[] array = new string[4];
			object obj;
			if (lhsBegin == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = lhsBegin;
				int lhsBegin2 = val.get_Value();
				int num = lhsBegin2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (lhsEnd == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<int> val2 = lhsEnd;
				int lhsEnd2 = val2.get_Value();
				int num2 = lhsEnd2;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (rhsBegin == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<int> val3 = rhsBegin;
				int rhsBegin2 = val3.get_Value();
				int num3 = rhsBegin2;
				object obj8 = num3;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (rhsEnd == null)
			{
				obj10 = "None";
			}
			else
			{
				FSharpOption<int> val4 = rhsEnd;
				int rhsEnd2 = val4.get_Value();
				int num4 = rhsEnd2;
				object obj11 = num4;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ReshapeLike_004033127(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033129_002D1313(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033130_002D1314(), outputArray)), names, vals);
		}

		public static SymbolOperators.ReshapeLike ReshapeLike([Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs, [Optional] [OptionalArgument] FSharpOption<int> lhsBegin, [Optional] [OptionalArgument] FSharpOption<int> lhsEnd, [Optional] [OptionalArgument] FSharpOption<int> rhsBegin, [Optional] [OptionalArgument] FSharpOption<int> rhsEnd)
		{
			return new SymbolOperators.ReshapeLike(lhs, rhs, lhsBegin, lhsEnd, rhsBegin, rhsEnd);
		}

		public static NDArray ShapeArray(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("shape_array");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033184_002D1315(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ShapeArray(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("shape_array");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033201_002D147();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033202_002D238();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ShapeArray_004033203(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033205_002D1316(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033206_002D1317(), outputArray)), names, vals);
		}

		public static SymbolOperators.ShapeArray ShapeArray([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ShapeArray(data);
		}

		public static NDArray SizeArray(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("size_array");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033236_002D1318(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void SizeArray(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("size_array");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033253_002D148();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033254_002D239();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SizeArray_004033255(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033257_002D1319(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033258_002D1320(), outputArray)), names, vals);
		}

		public static SymbolOperators.SizeArray SizeArray([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.SizeArray(data);
		}

		public static NDArray Cast(NDArray data, DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Cast");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033293_002D1321(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"dtype"
			};
			string[] array = new string[1];
			object obj;
			if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = dtype;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Cast(IEnumerable<NDArray> outputArray, NDArray data, DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Cast");
			string[] names2 = new string[1]
			{
				"dtype"
			};
			string[] array = new string[1];
			object obj;
			if (dtype != null)
			{
				IFormattable formattable = dtype as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = dtype;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Cast_004033317(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033319_002D1322(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033320_002D1323(), outputArray)), names, vals);
		}

		public static SymbolOperators.Cast Cast(Symbol data, DataType dtype)
		{
			return new SymbolOperators.Cast(data, dtype);
		}

		public static SymbolOperators.Cast Cast(DataType dtype, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Cast(dtype, data);
		}

		public static NDArray Negative(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("negative");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033373_002D1324(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Negative(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("negative");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033390_002D149();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033391_002D240();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Negative_004033392(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033394_002D1325(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033395_002D1326(), outputArray)), names, vals);
		}

		public static SymbolOperators.Negative Negative([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Negative(data);
		}

		public static NDArray Abs(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("abs");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033431_002D1327(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Abs(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("abs");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033454_002D150();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033455_002D241();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Abs_004033456(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033458_002D1328(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033459_002D1329(), outputArray)), names, vals);
		}

		public static SymbolOperators.Abs Abs([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Abs(data);
		}

		public static NDArray Sign(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sign");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033502_002D1330(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Sign(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sign");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033525_002D151();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033526_002D242();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Sign_004033527(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033529_002D1331(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033530_002D1332(), outputArray)), names, vals);
		}

		public static SymbolOperators.Sign Sign([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Sign(data);
		}

		public static NDArray Round(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("round");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033573_002D1333(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Round(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("round");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033596_002D152();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033597_002D243();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Round_004033598(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033600_002D1334(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033601_002D1335(), outputArray)), names, vals);
		}

		public static SymbolOperators.Round Round([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Round(data);
		}

		public static NDArray Rint(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rint");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033647_002D1336(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Rint(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rint");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033674_002D153();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033675_002D244();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Rint_004033676(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033678_002D1337(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033679_002D1338(), outputArray)), names, vals);
		}

		public static SymbolOperators.Rint Rint([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Rint(data);
		}

		public static NDArray Ceil(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ceil");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033727_002D1339(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Ceil(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ceil");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033752_002D154();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033753_002D245();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Ceil_004033754(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033756_002D1340(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033757_002D1341(), outputArray)), names, vals);
		}

		public static SymbolOperators.Ceil Ceil([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Ceil(data);
		}

		public static NDArray Floor(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("floor");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033803_002D1342(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Floor(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("floor");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033828_002D155();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033829_002D246();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Floor_004033830(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033832_002D1343(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033833_002D1344(), outputArray)), names, vals);
		}

		public static SymbolOperators.Floor Floor([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Floor(data);
		}

		public static NDArray Trunc(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("trunc");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033880_002D1345(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Trunc(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("trunc");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033906_002D156();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033907_002D247();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Trunc_004033908(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033910_002D1346(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033911_002D1347(), outputArray)), names, vals);
		}

		public static SymbolOperators.Trunc Trunc([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Trunc(data);
		}

		public static NDArray Fix(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("fix");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033957_002D1348(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Fix(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("fix");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004033981_002D157();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004033982_002D248();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Fix_004033983(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004033985_002D1349(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004033986_002D1350(), outputArray)), names, vals);
		}

		public static SymbolOperators.Fix Fix([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Fix(data);
		}

		public static NDArray Erf(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("erf");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034023_002D1351(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Erf(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("erf");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034040_002D158();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034041_002D249();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Erf_004034042(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034044_002D1352(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034045_002D1353(), outputArray)), names, vals);
		}

		public static SymbolOperators.Erf Erf([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Erf(data);
		}

		public static NDArray Erfinv(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("erfinv");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034076_002D1354(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Erfinv(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("erfinv");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034093_002D159();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034094_002D250();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Erfinv_004034095(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034097_002D1355(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034098_002D1356(), outputArray)), names, vals);
		}

		public static SymbolOperators.Erfinv Erfinv([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Erfinv(data);
		}

		public static NDArray Gamma(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("gamma");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034126_002D1357(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Gamma(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("gamma");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034140_002D160();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034141_002D251();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Gamma_004034142(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034144_002D1358(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034145_002D1359(), outputArray)), names, vals);
		}

		public static SymbolOperators.Gamma Gamma([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Gamma(data);
		}

		public static NDArray Gammaln(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("gammaln");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034170_002D1360(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Gammaln(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("gammaln");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034184_002D161();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034185_002D252();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Gammaln_004034186(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034188_002D1361(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034189_002D1362(), outputArray)), names, vals);
		}

		public static SymbolOperators.Gammaln Gammaln([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Gammaln(data);
		}

		public static NDArray LogicalNot(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("logical_not");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034214_002D1363(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LogicalNot(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("logical_not");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034228_002D162();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034229_002D253();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LogicalNot_004034230(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034232_002D1364(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034233_002D1365(), outputArray)), names, vals);
		}

		public static SymbolOperators.LogicalNot LogicalNot([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.LogicalNot(data);
		}

		public static NDArray Exp(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("exp");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034265_002D1366(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Exp(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("exp");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034287_002D163();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034288_002D254();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Exp_004034289(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034291_002D1367(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034292_002D1368(), outputArray)), names, vals);
		}

		public static SymbolOperators.Exp Exp([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Exp(data);
		}

		public static NDArray Log(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034327_002D1369(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Log(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034344_002D164();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034345_002D255();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Log_004034346(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034348_002D1370(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034349_002D1371(), outputArray)), names, vals);
		}

		public static SymbolOperators.Log Log([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Log(data);
		}

		public static NDArray Log10(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log10");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034379_002D1372(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Log10(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log10");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034396_002D165();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034397_002D256();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Log10_004034398(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034400_002D1373(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034401_002D1374(), outputArray)), names, vals);
		}

		public static SymbolOperators.Log10 Log10([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Log10(data);
		}

		public static NDArray Log2(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log2");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034431_002D1375(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Log2(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log2");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034448_002D166();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034449_002D257();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Log2_004034450(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034452_002D1376(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034453_002D1377(), outputArray)), names, vals);
		}

		public static SymbolOperators.Log2 Log2([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Log2(data);
		}

		public static NDArray Log1p(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log1p");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034491_002D1378(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Log1p(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("log1p");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034513_002D167();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034514_002D258();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Log1p_004034515(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034517_002D1379(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034518_002D1380(), outputArray)), names, vals);
		}

		public static SymbolOperators.Log1p Log1p([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Log1p(data);
		}

		public static NDArray Expm1(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("expm1");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034558_002D1381(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Expm1(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("expm1");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034579_002D168();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034580_002D259();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Expm1_004034581(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034583_002D1382(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034584_002D1383(), outputArray)), names, vals);
		}

		public static SymbolOperators.Expm1 Expm1([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Expm1(data);
		}

		public static NDArray Reciprocal(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("reciprocal");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034621_002D1384(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Reciprocal(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("reciprocal");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034640_002D169();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034641_002D260();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Reciprocal_004034642(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034644_002D1385(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034645_002D1386(), outputArray)), names, vals);
		}

		public static SymbolOperators.Reciprocal Reciprocal([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Reciprocal(data);
		}

		public static NDArray Square(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("square");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034687_002D1387(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Square(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("square");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034713_002D170();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034714_002D261();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Square_004034715(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034717_002D1388(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034718_002D1389(), outputArray)), names, vals);
		}

		public static SymbolOperators.Square Square([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Square(data);
		}

		public static NDArray Sqrt(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sqrt");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034767_002D1390(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Sqrt(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sqrt");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034793_002D171();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034794_002D262();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Sqrt_004034795(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034797_002D1391(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034798_002D1392(), outputArray)), names, vals);
		}

		public static SymbolOperators.Sqrt Sqrt([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Sqrt(data);
		}

		public static NDArray Rsqrt(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rsqrt");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034843_002D1393(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Rsqrt(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rsqrt");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034865_002D172();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034866_002D263();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Rsqrt_004034867(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034869_002D1394(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034870_002D1395(), outputArray)), names, vals);
		}

		public static SymbolOperators.Rsqrt Rsqrt([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Rsqrt(data);
		}

		public static NDArray Cbrt(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("cbrt");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034915_002D1396(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Cbrt(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("cbrt");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004034941_002D173();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004034942_002D264();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Cbrt_004034943(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034945_002D1397(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004034946_002D1398(), outputArray)), names, vals);
		}

		public static SymbolOperators.Cbrt Cbrt([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Cbrt(data);
		}

		public static NDArray Rcbrt(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rcbrt");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004034989_002D1399(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Rcbrt(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("rcbrt");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035009_002D174();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035010_002D265();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Rcbrt_004035011(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035013_002D1400(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035014_002D1401(), outputArray)), names, vals);
		}

		public static SymbolOperators.Rcbrt Rcbrt([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Rcbrt(data);
		}

		public static NDArray Sin(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sin");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035055_002D1402(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Sin(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sin");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035079_002D175();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035080_002D266();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Sin_004035081(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035083_002D1403(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035084_002D1404(), outputArray)), names, vals);
		}

		public static SymbolOperators.Sin Sin([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Sin(data);
		}

		public static NDArray Cos(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("cos");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035125_002D1405(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Cos(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("cos");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035145_002D176();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035146_002D267();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Cos_004035147(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035149_002D1406(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035150_002D1407(), outputArray)), names, vals);
		}

		public static SymbolOperators.Cos Cos([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Cos(data);
		}

		public static NDArray Tan(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("tan");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035191_002D1408(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Tan(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("tan");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035215_002D177();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035216_002D268();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Tan_004035217(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035219_002D1409(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035220_002D1410(), outputArray)), names, vals);
		}

		public static SymbolOperators.Tan Tan([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Tan(data);
		}

		public static NDArray Arcsin(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arcsin");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035266_002D1411(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Arcsin(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arcsin");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035291_002D178();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035292_002D269();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Arcsin_004035293(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035295_002D1412(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035296_002D1413(), outputArray)), names, vals);
		}

		public static SymbolOperators.Arcsin Arcsin([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Arcsin(data);
		}

		public static NDArray Arccos(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arccos");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035339_002D1414(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Arccos(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arccos");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035360_002D179();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035361_002D270();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Arccos_004035362(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035364_002D1415(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035365_002D1416(), outputArray)), names, vals);
		}

		public static SymbolOperators.Arccos Arccos([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Arccos(data);
		}

		public static NDArray Arctan(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arctan");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035407_002D1417(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Arctan(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arctan");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035431_002D180();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035432_002D271();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Arctan_004035433(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035435_002D1418(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035436_002D1419(), outputArray)), names, vals);
		}

		public static SymbolOperators.Arctan Arctan([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Arctan(data);
		}

		public static NDArray Degrees(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("degrees");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035479_002D1420(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Degrees(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("degrees");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035501_002D181();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035502_002D272();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Degrees_004035503(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035505_002D1421(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035506_002D1422(), outputArray)), names, vals);
		}

		public static SymbolOperators.Degrees Degrees([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Degrees(data);
		}

		public static NDArray Radians(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("radians");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035547_002D1423(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Radians(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("radians");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035569_002D182();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035570_002D273();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Radians_004035571(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035573_002D1424(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035574_002D1425(), outputArray)), names, vals);
		}

		public static SymbolOperators.Radians Radians([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Radians(data);
		}

		public static NDArray Sinh(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sinh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035615_002D1426(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Sinh(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sinh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035637_002D183();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035638_002D274();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Sinh_004035639(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035641_002D1427(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035642_002D1428(), outputArray)), names, vals);
		}

		public static SymbolOperators.Sinh Sinh([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Sinh(data);
		}

		public static NDArray Cosh(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("cosh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035679_002D1429(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Cosh(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("cosh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035697_002D184();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035698_002D275();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Cosh_004035699(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035701_002D1430(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035702_002D1431(), outputArray)), names, vals);
		}

		public static SymbolOperators.Cosh Cosh([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Cosh(data);
		}

		public static NDArray Tanh(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("tanh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035739_002D1432(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Tanh(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("tanh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035761_002D185();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035762_002D276();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Tanh_004035763(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035765_002D1433(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035766_002D1434(), outputArray)), names, vals);
		}

		public static SymbolOperators.Tanh Tanh([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Tanh(data);
		}

		public static NDArray Arcsinh(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arcsinh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035805_002D1435(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Arcsinh(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arcsinh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035825_002D186();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035826_002D277();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Arcsinh_004035827(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035829_002D1436(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035830_002D1437(), outputArray)), names, vals);
		}

		public static SymbolOperators.Arcsinh Arcsinh([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Arcsinh(data);
		}

		public static NDArray Arccosh(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arccosh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035863_002D1438(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Arccosh(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arccosh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035879_002D187();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035880_002D278();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Arccosh_004035881(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035883_002D1439(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035884_002D1440(), outputArray)), names, vals);
		}

		public static SymbolOperators.Arccosh Arccosh([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Arccosh(data);
		}

		public static NDArray Arctanh(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arctanh");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035917_002D1441(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void Arctanh(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("arctanh");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004035937_002D188();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004035938_002D279();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Arctanh_004035939(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035941_002D1442(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004035942_002D1443(), outputArray)), names, vals);
		}

		public static SymbolOperators.Arctanh Arctanh([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Arctanh(data);
		}

		public static Tuple<NDArray, NDArray> Histogram(NDArray data, NDArray bins, [Optional] [OptionalArgument] FSharpOption<int> binCnt, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> range)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_histogram");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004035983_002D1444(data, bins, 0, current));
			string[] parameterKeys = new string[2]
			{
				"bin_cnt",
				"range"
			};
			string[] array = new string[2];
			object obj;
			if (binCnt == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = binCnt;
				int binCnt2 = val.get_Value();
				int num = binCnt2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (range == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<double>> val2 = range;
				IEnumerable<double> range2 = val2.get_Value();
				IEnumerable<double> enumerable = range2;
				object obj5 = enumerable;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void Histogram(IEnumerable<NDArray> outputArray, NDArray data, NDArray bins, [Optional] [OptionalArgument] FSharpOption<int> binCnt, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> range)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_histogram");
			string[] names2 = new string[2]
			{
				"bin_cnt",
				"range"
			};
			string[] array = new string[2];
			object obj;
			if (binCnt == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = binCnt;
				int binCnt2 = val.get_Value();
				int num = binCnt2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (range == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<IEnumerable<double>> val2 = range;
				IEnumerable<double> range2 = val2.get_Value();
				IEnumerable<double> enumerable = range2;
				object obj5 = enumerable;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Histogram_004036009(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036011_002D1445(data, bins, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004036012_002D1446(), outputArray)), names, vals);
		}

		public static SymbolOperators.Histogram Histogram([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> bins, [Optional] [OptionalArgument] FSharpOption<int> binCnt, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> range)
		{
			return new SymbolOperators.Histogram(data, bins, binCnt, range);
		}

		public static NDArray Embedding(NDArray data, NDArray weight, int inputDim, int outputDim, [Optional] DataType dtype, bool sparseGrad = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Embedding");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036104_002D1447(data, weight, 0, current));
			string[] parameterKeys = new string[4]
			{
				"input_dim",
				"output_dim",
				"dtype",
				"sparse_grad"
			};
			string[] array = new string[4];
			object obj = inputDim;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = outputDim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			bool flag = sparseGrad;
			object obj9 = flag;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Embedding(IEnumerable<NDArray> outputArray, NDArray data, NDArray weight, int inputDim, int outputDim, [Optional] DataType dtype, bool sparseGrad = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Embedding");
			string[] names2 = new string[4]
			{
				"input_dim",
				"output_dim",
				"dtype",
				"sparse_grad"
			};
			string[] array = new string[4];
			object obj = inputDim;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = outputDim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			bool flag = sparseGrad;
			object obj9 = flag;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Embedding_004036179(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036181_002D1448(data, weight, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004036182_002D1449(), outputArray)), names, vals);
		}

		public static SymbolOperators.Embedding Embedding(Symbol data, Symbol weight, int inputDim, int outputDim, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> sparseGrad)
		{
			return new SymbolOperators.Embedding(data, weight, inputDim, outputDim, dtype, sparseGrad);
		}

		public static SymbolOperators.Embedding Embedding(int inputDim, int outputDim, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> sparseGrad)
		{
			return new SymbolOperators.Embedding(inputDim, outputDim, data, weight, dtype, sparseGrad);
		}

		public static NDArray ContribSparseEmbedding(NDArray data, NDArray weight, int inputDim, int outputDim, [Optional] DataType dtype, bool sparseGrad = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_SparseEmbedding");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036377_002D1450(data, weight, 0, current));
			string[] parameterKeys = new string[4]
			{
				"input_dim",
				"output_dim",
				"dtype",
				"sparse_grad"
			};
			string[] array = new string[4];
			object obj = inputDim;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = outputDim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			bool flag = sparseGrad;
			object obj9 = flag;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribSparseEmbedding(IEnumerable<NDArray> outputArray, NDArray data, NDArray weight, int inputDim, int outputDim, [Optional] DataType dtype, bool sparseGrad = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_SparseEmbedding");
			string[] names2 = new string[4]
			{
				"input_dim",
				"output_dim",
				"dtype",
				"sparse_grad"
			};
			string[] array = new string[4];
			object obj = inputDim;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = outputDim;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			bool flag = sparseGrad;
			object obj9 = flag;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribSparseEmbedding_004036450(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036452_002D1451(data, weight, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004036453_002D1452(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribSparseEmbedding ContribSparseEmbedding(Symbol data, Symbol weight, int inputDim, int outputDim, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> sparseGrad)
		{
			return new SymbolOperators.ContribSparseEmbedding(data, weight, inputDim, outputDim, dtype, sparseGrad);
		}

		public static SymbolOperators.ContribSparseEmbedding ContribSparseEmbedding(int inputDim, int outputDim, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<DataType> dtype, [Optional] [OptionalArgument] FSharpOption<bool> sparseGrad)
		{
			return new SymbolOperators.ContribSparseEmbedding(inputDim, outputDim, data, weight, dtype, sparseGrad);
		}

		public static NDArray Take(NDArray a, NDArray indices, int axis = 0, [Optional] GeneratedArgumentTypes.TakeMode mode)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("take");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036639_002D1453(a, indices, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axis",
				"mode"
			};
			string[] array = new string[2];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if ((mode == null) ? true : false)
			{
				obj4 = "clip";
			}
			else if (mode != null)
			{
				IFormattable formattable3 = mode as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = mode;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Take(IEnumerable<NDArray> outputArray, NDArray a, NDArray indices, int axis = 0, [Optional] GeneratedArgumentTypes.TakeMode mode)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("take");
			string[] names2 = new string[2]
			{
				"axis",
				"mode"
			};
			string[] array = new string[2];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if ((mode == null) ? true : false)
			{
				obj4 = "clip";
			}
			else if (mode != null)
			{
				IFormattable formattable3 = mode as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = mode;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Take_004036704(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036706_002D1454(a, indices, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004036707_002D1455(), outputArray)), names, vals);
		}

		public static SymbolOperators.Take Take([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<Symbol> indices, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.TakeMode> mode)
		{
			return new SymbolOperators.Take(a, indices, axis, mode);
		}

		public static NDArray BatchTake(NDArray a, NDArray indices)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("batch_take");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036798_002D1456(a, indices, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void BatchTake(IEnumerable<NDArray> outputArray, NDArray a, NDArray indices)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("batch_take");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004036829_002D189();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004036830_002D280();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BatchTake_004036831(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036833_002D1457(a, indices, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004036834_002D1458(), outputArray)), names, vals);
		}

		public static SymbolOperators.BatchTake BatchTake([Optional] [OptionalArgument] FSharpOption<Symbol> a, [Optional] [OptionalArgument] FSharpOption<Symbol> indices)
		{
			return new SymbolOperators.BatchTake(a, indices);
		}

		public static NDArray OneHot(NDArray indices, int depth, double onValue = 1.0, double offValue = 0.0, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("one_hot");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036912_002D1459(indices, 0, current));
			string[] parameterKeys = new string[4]
			{
				"depth",
				"on_value",
				"off_value",
				"dtype"
			};
			string[] array = new string[4];
			object obj = depth;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = onValue;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = offValue;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void OneHot(IEnumerable<NDArray> outputArray, NDArray indices, int depth, double onValue = 1.0, double offValue = 0.0, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("one_hot");
			string[] names2 = new string[4]
			{
				"depth",
				"on_value",
				"off_value",
				"dtype"
			};
			string[] array = new string[4];
			object obj = depth;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = onValue;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = offValue;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10;
			if ((dtype == null) ? true : false)
			{
				obj10 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable7 = dtype as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = dtype;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.OneHot_004036966(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004036968_002D1460(indices, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004036969_002D1461(), outputArray)), names, vals);
		}

		public static SymbolOperators.OneHot OneHot(Symbol indices, int depth, [Optional] [OptionalArgument] FSharpOption<double> onValue, [Optional] [OptionalArgument] FSharpOption<double> offValue, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.OneHot(indices, depth, onValue, offValue, dtype);
		}

		public static SymbolOperators.OneHot OneHot(int depth, [Optional] [OptionalArgument] FSharpOption<Symbol> indices, [Optional] [OptionalArgument] FSharpOption<double> onValue, [Optional] [OptionalArgument] FSharpOption<double> offValue, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.OneHot(depth, indices, onValue, offValue, dtype);
		}

		public static NDArray GatherNd(NDArray data, NDArray indices)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("gather_nd");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037088_002D1462(data, indices, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void GatherNd(IEnumerable<NDArray> outputArray, NDArray data, NDArray indices)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("gather_nd");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004037122_002D190();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004037123_002D281();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.GatherNd_004037124(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037126_002D1463(data, indices, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037127_002D1464(), outputArray)), names, vals);
		}

		public static SymbolOperators.GatherNd GatherNd([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> indices)
		{
			return new SymbolOperators.GatherNd(data, indices);
		}

		public static NDArray ScatterNd(NDArray data, NDArray indices, IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("scatter_nd");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037211_002D1465(data, indices, 0, current));
			string[] parameterKeys = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004037213_002D1466(), shape));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ScatterNd(IEnumerable<NDArray> outputArray, NDArray data, NDArray indices, IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("scatter_nd");
			string[] names2 = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004037266_002D282(), shape));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ScatterNd_004037267(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037269_002D1467(data, indices, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037270_002D1468(), outputArray)), names, vals);
		}

		public static SymbolOperators.ScatterNd ScatterNd(Symbol data, Symbol indices, IEnumerable<int> shape)
		{
			return new SymbolOperators.ScatterNd(data, indices, shape);
		}

		public static SymbolOperators.ScatterNd ScatterNd(IEnumerable<int> shape, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> indices)
		{
			return new SymbolOperators.ScatterNd(shape, data, indices);
		}

		public static NDArray ScatterSetNd(NDArray lhs, NDArray rhs, NDArray indices, IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_scatter_set_nd");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037397_002D1469(lhs, rhs, indices, 0, current));
			string[] parameterKeys = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004037399_002D1470(), shape));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ScatterSetNd(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs, NDArray indices, IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_scatter_set_nd");
			string[] names2 = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004037425_002D283(), shape));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ScatterSetNd_004037426(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037428_002D1471(lhs, rhs, indices, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037429_002D1472(), outputArray)), names, vals);
		}

		public static SymbolOperators.ScatterSetNd ScatterSetNd(Symbol lhs, Symbol rhs, Symbol indices, IEnumerable<int> shape)
		{
			return new SymbolOperators.ScatterSetNd(lhs, rhs, indices, shape);
		}

		public static SymbolOperators.ScatterSetNd ScatterSetNd(IEnumerable<int> shape, [Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs, [Optional] [OptionalArgument] FSharpOption<Symbol> indices)
		{
			return new SymbolOperators.ScatterSetNd(shape, lhs, rhs, indices);
		}

		public static NDArray ZerosWithoutDtypeNDArray(Context ctx, [Optional] IEnumerable<int> shape, int dtype = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_zeros_without_dtype");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004037487_002D1473(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4 = dtype;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ZerosWithoutDtype(IEnumerable<NDArray> outputArray, Context ctx, [Optional] IEnumerable<int> shape, int dtype = -1)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_zeros_without_dtype");
			string[] names2 = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004037497_002D284(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4 = dtype;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ZerosWithoutDtype_004037498(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037501_002D1474(), outputArray)), names, vals);
		}

		public static SymbolOperators.ZerosWithoutDtype ZerosWithoutDtype([Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<int> dtype)
		{
			return new SymbolOperators.ZerosWithoutDtype(shape, dtype);
		}

		public static NDArray ZerosNDArray(Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_zeros");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004037520_002D1475(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Zeros(IEnumerable<NDArray> outputArray, Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_zeros");
			string[] names2 = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004037530_002D285(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Zeros_004037531(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037534_002D1476(), outputArray)), names, vals);
		}

		public static SymbolOperators.Zeros Zeros([Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.Zeros(shape, dtype);
		}

		public static NDArray EyeNDArray(long N, Context ctx, long M = 0L, long k = 0L, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_eye");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[5]
			{
				"N",
				"ctx",
				"M",
				"k",
				"dtype"
			};
			string[] array = new string[5];
			object obj = N;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = M;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9 = k;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			object obj12;
			if ((dtype == null) ? true : false)
			{
				obj12 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable9 = dtype as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = dtype;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Eye(IEnumerable<NDArray> outputArray, long N, Context ctx, long M = 0L, long k = 0L, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_eye");
			string[] names2 = new string[5]
			{
				"N",
				"ctx",
				"M",
				"k",
				"dtype"
			};
			string[] array = new string[5];
			object obj = N;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6 = M;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable5 = obj6 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			object obj9 = k;
			object obj10;
			if (obj9 != null)
			{
				IFormattable formattable7 = obj9 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj11 = obj9;
					obj10 = obj11.ToString();
				}
			}
			else
			{
				obj10 = "";
			}
			array[3] = (string)obj10;
			object obj12;
			if ((dtype == null) ? true : false)
			{
				obj12 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable9 = dtype as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj13 = dtype;
					obj12 = obj13.ToString();
				}
			}
			else
			{
				obj12 = "";
			}
			array[4] = (string)obj12;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Eye_004037577(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037580_002D1477(), outputArray)), names, vals);
		}

		public static SymbolOperators.Eye Eye(long N, [Optional] [OptionalArgument] FSharpOption<long> M, [Optional] [OptionalArgument] FSharpOption<long> k, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.Eye(N, M, k, dtype);
		}

		public static NDArray OnesNDArray(Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_ones");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004037601_002D1478(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Ones(IEnumerable<NDArray> outputArray, Context ctx, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_ones");
			string[] names2 = new string[3]
			{
				"ctx",
				"shape",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((shape == null) ? true : false)
			{
				obj3 = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004037611_002D286(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			object obj4;
			if ((dtype == null) ? true : false)
			{
				obj4 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable3 = dtype as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = dtype;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[2] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Ones_004037612(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037615_002D1479(), outputArray)), names, vals);
		}

		public static SymbolOperators.Ones Ones([Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.Ones(shape, dtype);
		}

		public static NDArray[] FullNDArray(Context ctx, double value, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_full");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[4]
			{
				"ctx",
				"value",
				"shape",
				"dtype"
			};
			string[] array = new string[4];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = value;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((shape == null) ? true : false)
			{
				obj6 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004037635_002D1480(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj6 = val.Invoke(text2);
			}
			array[2] = (string)obj6;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.FullNDArray_004037636();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void Full(IEnumerable<NDArray> outputArray, Context ctx, double value, [Optional] IEnumerable<int> shape, [Optional] DataType dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_full");
			string[] names2 = new string[4]
			{
				"ctx",
				"value",
				"shape",
				"dtype"
			};
			string[] array = new string[4];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3 = value;
			object obj4;
			if (obj3 != null)
			{
				IFormattable formattable3 = obj3 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = obj3;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if ((shape == null) ? true : false)
			{
				obj6 = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004037646_002D287(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj6 = val.Invoke(text2);
			}
			array[2] = (string)obj6;
			object obj7;
			if ((dtype == null) ? true : false)
			{
				obj7 = "float32";
			}
			else if (dtype != null)
			{
				IFormattable formattable5 = dtype as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = dtype;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Full_004037647(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037650_002D1481(), outputArray)), names, vals);
		}

		public static SymbolOperators.Full Full(double value, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.Full(value, shape, dtype);
		}

		public static NDArray ArangeNDArray(double start, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_arange");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[7]
			{
				"start",
				"ctx",
				"stop",
				"step",
				"repeat",
				"infer_range",
				"dtype"
			};
			string[] array = new string[7];
			object obj = start;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (stop == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val = stop;
				double stop2 = val.get_Value();
				double num = stop2;
				object obj7 = num;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (step == null)
			{
				obj9 = "1.0";
			}
			else
			{
				FSharpOption<double> val2 = step;
				double step2 = val2.get_Value();
				double num2 = step2;
				object obj10 = num2;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (repeat == null)
			{
				obj12 = "1";
			}
			else
			{
				FSharpOption<int> val3 = repeat;
				int repeat2 = val3.get_Value();
				int num3 = repeat2;
				object obj13 = num3;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			object obj15;
			if (inferRange == null)
			{
				obj15 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = inferRange;
				bool inferRange2 = val4.get_Value();
				bool flag = inferRange2;
				object obj16 = flag;
				if (obj16 != null)
				{
					IFormattable formattable11 = obj16 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj17 = obj16;
						obj15 = obj17.ToString();
					}
				}
				else
				{
					obj15 = "";
				}
			}
			array[5] = (string)obj15;
			object obj18;
			if (dtype == null)
			{
				obj18 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj19 = dataType;
				if (obj19 != null)
				{
					IFormattable formattable13 = obj19 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj20 = obj19;
						obj18 = obj20.ToString();
					}
				}
				else
				{
					obj18 = "";
				}
			}
			array[6] = (string)obj18;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Arange(IEnumerable<NDArray> outputArray, double start, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_arange");
			string[] names2 = new string[7]
			{
				"start",
				"ctx",
				"stop",
				"step",
				"repeat",
				"infer_range",
				"dtype"
			};
			string[] array = new string[7];
			object obj = start;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (stop == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val = stop;
				double stop2 = val.get_Value();
				double num = stop2;
				object obj7 = num;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (step == null)
			{
				obj9 = "1.0";
			}
			else
			{
				FSharpOption<double> val2 = step;
				double step2 = val2.get_Value();
				double num2 = step2;
				object obj10 = num2;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (repeat == null)
			{
				obj12 = "1";
			}
			else
			{
				FSharpOption<int> val3 = repeat;
				int repeat2 = val3.get_Value();
				int num3 = repeat2;
				object obj13 = num3;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			object obj15;
			if (inferRange == null)
			{
				obj15 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = inferRange;
				bool inferRange2 = val4.get_Value();
				bool flag = inferRange2;
				object obj16 = flag;
				if (obj16 != null)
				{
					IFormattable formattable11 = obj16 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj17 = obj16;
						obj15 = obj17.ToString();
					}
				}
				else
				{
					obj15 = "";
				}
			}
			array[5] = (string)obj15;
			object obj18;
			if (dtype == null)
			{
				obj18 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj19 = dataType;
				if (obj19 != null)
				{
					IFormattable formattable13 = obj19 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj20 = obj19;
						obj18 = obj20.ToString();
					}
				}
				else
				{
					obj18 = "";
				}
			}
			array[6] = (string)obj18;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Arange_004037702(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037705_002D1482(), outputArray)), names, vals);
		}

		public static SymbolOperators.Arange Arange(double start, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.Arange(start, stop, step, repeat, inferRange, dtype);
		}

		public static NDArray ContribArangeLike(NDArray data, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> start, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_arange_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037756_002D1483(data, 0, current));
			string[] parameterKeys = new string[5]
			{
				"ctx",
				"start",
				"step",
				"repeat",
				"axis"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (start == null)
			{
				obj3 = "0.0";
			}
			else
			{
				FSharpOption<double> val = start;
				double start2 = val.get_Value();
				double num = start2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (step == null)
			{
				obj6 = "1.0";
			}
			else
			{
				FSharpOption<double> val2 = step;
				double step2 = val2.get_Value();
				double num2 = step2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (repeat == null)
			{
				obj9 = "1";
			}
			else
			{
				FSharpOption<int> val3 = repeat;
				int repeat2 = val3.get_Value();
				int num3 = repeat2;
				object obj10 = num3;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (axis == null)
			{
				obj12 = "None";
			}
			else
			{
				FSharpOption<int> val4 = axis;
				int axis2 = val4.get_Value();
				int num4 = axis2;
				object obj13 = num4;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ContribArangeLike(IEnumerable<NDArray> outputArray, NDArray data, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> start, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_arange_like");
			string[] names2 = new string[5]
			{
				"ctx",
				"start",
				"step",
				"repeat",
				"axis"
			};
			string[] array = new string[5];
			object obj;
			if (ctx != null)
			{
				IFormattable formattable = ctx as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = ctx;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (start == null)
			{
				obj3 = "0.0";
			}
			else
			{
				FSharpOption<double> val = start;
				double start2 = val.get_Value();
				double num = start2;
				object obj4 = num;
				if (obj4 != null)
				{
					IFormattable formattable3 = obj4 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			array[1] = (string)obj3;
			object obj6;
			if (step == null)
			{
				obj6 = "1.0";
			}
			else
			{
				FSharpOption<double> val2 = step;
				double step2 = val2.get_Value();
				double num2 = step2;
				object obj7 = num2;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (repeat == null)
			{
				obj9 = "1";
			}
			else
			{
				FSharpOption<int> val3 = repeat;
				int repeat2 = val3.get_Value();
				int num3 = repeat2;
				object obj10 = num3;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (axis == null)
			{
				obj12 = "None";
			}
			else
			{
				FSharpOption<int> val4 = axis;
				int axis2 = val4.get_Value();
				int num4 = axis2;
				object obj13 = num4;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribArangeLike_004037800(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037802_002D1484(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037803_002D1485(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribArangeLike ContribArangeLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> start, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.ContribArangeLike(data, start, step, repeat, axis);
		}

		public static NDArray LinspaceNDArray(double start, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linspace");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[7]
			{
				"start",
				"ctx",
				"stop",
				"step",
				"repeat",
				"infer_range",
				"dtype"
			};
			string[] array = new string[7];
			object obj = start;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (stop == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val = stop;
				double stop2 = val.get_Value();
				double num = stop2;
				object obj7 = num;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (step == null)
			{
				obj9 = "1.0";
			}
			else
			{
				FSharpOption<double> val2 = step;
				double step2 = val2.get_Value();
				double num2 = step2;
				object obj10 = num2;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (repeat == null)
			{
				obj12 = "1";
			}
			else
			{
				FSharpOption<int> val3 = repeat;
				int repeat2 = val3.get_Value();
				int num3 = repeat2;
				object obj13 = num3;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			object obj15;
			if (inferRange == null)
			{
				obj15 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = inferRange;
				bool inferRange2 = val4.get_Value();
				bool flag = inferRange2;
				object obj16 = flag;
				if (obj16 != null)
				{
					IFormattable formattable11 = obj16 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj17 = obj16;
						obj15 = obj17.ToString();
					}
				}
				else
				{
					obj15 = "";
				}
			}
			array[5] = (string)obj15;
			object obj18;
			if (dtype == null)
			{
				obj18 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj19 = dataType;
				if (obj19 != null)
				{
					IFormattable formattable13 = obj19 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj20 = obj19;
						obj18 = obj20.ToString();
					}
				}
				else
				{
					obj18 = "";
				}
			}
			array[6] = (string)obj18;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Linspace(IEnumerable<NDArray> outputArray, double start, Context ctx, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linspace");
			string[] names2 = new string[7]
			{
				"start",
				"ctx",
				"stop",
				"step",
				"repeat",
				"infer_range",
				"dtype"
			};
			string[] array = new string[7];
			object obj = start;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (ctx != null)
			{
				IFormattable formattable3 = ctx as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = ctx;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			object obj6;
			if (stop == null)
			{
				obj6 = "None";
			}
			else
			{
				FSharpOption<double> val = stop;
				double stop2 = val.get_Value();
				double num = stop2;
				object obj7 = num;
				if (obj7 != null)
				{
					IFormattable formattable5 = obj7 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj8 = obj7;
						obj6 = obj8.ToString();
					}
				}
				else
				{
					obj6 = "";
				}
			}
			array[2] = (string)obj6;
			object obj9;
			if (step == null)
			{
				obj9 = "1.0";
			}
			else
			{
				FSharpOption<double> val2 = step;
				double step2 = val2.get_Value();
				double num2 = step2;
				object obj10 = num2;
				if (obj10 != null)
				{
					IFormattable formattable7 = obj10 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj9 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj11 = obj10;
						obj9 = obj11.ToString();
					}
				}
				else
				{
					obj9 = "";
				}
			}
			array[3] = (string)obj9;
			object obj12;
			if (repeat == null)
			{
				obj12 = "1";
			}
			else
			{
				FSharpOption<int> val3 = repeat;
				int repeat2 = val3.get_Value();
				int num3 = repeat2;
				object obj13 = num3;
				if (obj13 != null)
				{
					IFormattable formattable9 = obj13 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj12 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj14 = obj13;
						obj12 = obj14.ToString();
					}
				}
				else
				{
					obj12 = "";
				}
			}
			array[4] = (string)obj12;
			object obj15;
			if (inferRange == null)
			{
				obj15 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = inferRange;
				bool inferRange2 = val4.get_Value();
				bool flag = inferRange2;
				object obj16 = flag;
				if (obj16 != null)
				{
					IFormattable formattable11 = obj16 as IFormattable;
					if (formattable11 != null)
					{
						IFormattable formattable12 = formattable11;
						obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj17 = obj16;
						obj15 = obj17.ToString();
					}
				}
				else
				{
					obj15 = "";
				}
			}
			array[5] = (string)obj15;
			object obj18;
			if (dtype == null)
			{
				obj18 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj19 = dataType;
				if (obj19 != null)
				{
					IFormattable formattable13 = obj19 as IFormattable;
					if (formattable13 != null)
					{
						IFormattable formattable14 = formattable13;
						obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj20 = obj19;
						obj18 = obj20.ToString();
					}
				}
				else
				{
					obj18 = "";
				}
			}
			array[6] = (string)obj18;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Linspace_004037879(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037882_002D1486(), outputArray)), names, vals);
		}

		public static SymbolOperators.Linspace Linspace(double start, [Optional] [OptionalArgument] FSharpOption<double> stop, [Optional] [OptionalArgument] FSharpOption<double> step, [Optional] [OptionalArgument] FSharpOption<int> repeat, [Optional] [OptionalArgument] FSharpOption<bool> inferRange, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.Linspace(start, stop, step, repeat, inferRange, dtype);
		}

		public static NDArray ZerosLike(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("zeros_like");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037918_002D1487(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void ZerosLike(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("zeros_like");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004037944_002D191();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004037945_002D288();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ZerosLike_004037946(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037948_002D1488(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004037949_002D1489(), outputArray)), names, vals);
		}

		public static SymbolOperators.ZerosLike ZerosLike([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ZerosLike(data);
		}

		public static NDArray OnesLike(NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ones_like");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004037991_002D1490(data, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void OnesLike(IEnumerable<NDArray> outputArray, NDArray data)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("ones_like");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004038011_002D192();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004038012_002D289();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.OnesLike_004038013(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038015_002D1491(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004038016_002D1492(), outputArray)), names, vals);
		}

		public static SymbolOperators.OnesLike OnesLike([Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.OnesLike(data);
		}

		public static NDArray LinalgGemm(NDArray A, NDArray B, NDArray C, bool transposeA = false, bool transposeB = false, double alpha = 1.0, double beta = 1.0, int axis = -2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_gemm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038104_002D1493(A, B, C, 0, current));
			string[] parameterKeys = new string[5]
			{
				"transpose_a",
				"transpose_b",
				"alpha",
				"beta",
				"axis"
			};
			string[] array = new string[5];
			bool flag = transposeA;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = transposeB;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = alpha;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = axis;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgGemm(IEnumerable<NDArray> outputArray, NDArray A, NDArray B, NDArray C, bool transposeA = false, bool transposeB = false, double alpha = 1.0, double beta = 1.0, int axis = -2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_gemm");
			string[] names2 = new string[5]
			{
				"transpose_a",
				"transpose_b",
				"alpha",
				"beta",
				"axis"
			};
			string[] array = new string[5];
			bool flag = transposeA;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = transposeB;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = alpha;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = beta;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = axis;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgGemm_004038179(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038181_002D1494(A, B, C, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004038182_002D1495(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgGemm LinalgGemm([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<Symbol> B, [Optional] [OptionalArgument] FSharpOption<Symbol> C, [Optional] [OptionalArgument] FSharpOption<bool> transposeA, [Optional] [OptionalArgument] FSharpOption<bool> transposeB, [Optional] [OptionalArgument] FSharpOption<double> alpha, [Optional] [OptionalArgument] FSharpOption<double> beta, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.LinalgGemm(A, B, C, transposeA, transposeB, alpha, beta, axis);
		}

		public static NDArray LinalgGemm2(NDArray A, NDArray B, bool transposeA = false, bool transposeB = false, double alpha = 1.0, int axis = -2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_gemm2");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038309_002D1496(A, B, 0, current));
			string[] parameterKeys = new string[4]
			{
				"transpose_a",
				"transpose_b",
				"alpha",
				"axis"
			};
			string[] array = new string[4];
			bool flag = transposeA;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = transposeB;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = alpha;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = axis;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgGemm2(IEnumerable<NDArray> outputArray, NDArray A, NDArray B, bool transposeA = false, bool transposeB = false, double alpha = 1.0, int axis = -2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_gemm2");
			string[] names2 = new string[4]
			{
				"transpose_a",
				"transpose_b",
				"alpha",
				"axis"
			};
			string[] array = new string[4];
			bool flag = transposeA;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = transposeB;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = alpha;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = axis;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgGemm2_004038377(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038379_002D1497(A, B, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004038380_002D1498(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgGemm2 LinalgGemm2([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<Symbol> B, [Optional] [OptionalArgument] FSharpOption<bool> transposeA, [Optional] [OptionalArgument] FSharpOption<bool> transposeB, [Optional] [OptionalArgument] FSharpOption<double> alpha, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.LinalgGemm2(A, B, transposeA, transposeB, alpha, axis);
		}

		public static NDArray LinalgPotrf(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_potrf");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038472_002D1499(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LinalgPotrf(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_potrf");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004038507_002D193();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004038508_002D290();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgPotrf_004038509(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038511_002D1500(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004038512_002D1501(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgPotrf LinalgPotrf([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.LinalgPotrf(A);
		}

		public static NDArray LinalgPotri(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_potri");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038588_002D1502(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LinalgPotri(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_potri");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004038632_002D194();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004038633_002D291();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgPotri_004038634(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038636_002D1503(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004038637_002D1504(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgPotri LinalgPotri([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.LinalgPotri(A);
		}

		public static NDArray LinalgTrmm(NDArray A, NDArray B, bool transpose = false, bool rightside = false, bool lower = true, double alpha = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_trmm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038732_002D1505(A, B, 0, current));
			string[] parameterKeys = new string[4]
			{
				"transpose",
				"rightside",
				"lower",
				"alpha"
			};
			string[] array = new string[4];
			bool flag = transpose;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = rightside;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag3 = lower;
			object obj7 = flag3;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = alpha;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgTrmm(IEnumerable<NDArray> outputArray, NDArray A, NDArray B, bool transpose = false, bool rightside = false, bool lower = true, double alpha = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_trmm");
			string[] names2 = new string[4]
			{
				"transpose",
				"rightside",
				"lower",
				"alpha"
			};
			string[] array = new string[4];
			bool flag = transpose;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = rightside;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag3 = lower;
			object obj7 = flag3;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = alpha;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgTrmm_004038789(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038791_002D1506(A, B, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004038792_002D1507(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgTrmm LinalgTrmm([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<Symbol> B, [Optional] [OptionalArgument] FSharpOption<bool> transpose, [Optional] [OptionalArgument] FSharpOption<bool> rightside, [Optional] [OptionalArgument] FSharpOption<bool> lower, [Optional] [OptionalArgument] FSharpOption<double> alpha)
		{
			return new SymbolOperators.LinalgTrmm(A, B, transpose, rightside, lower, alpha);
		}

		public static NDArray LinalgTrsm(NDArray A, NDArray B, bool transpose = false, bool rightside = false, bool lower = true, double alpha = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_trsm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038893_002D1508(A, B, 0, current));
			string[] parameterKeys = new string[4]
			{
				"transpose",
				"rightside",
				"lower",
				"alpha"
			};
			string[] array = new string[4];
			bool flag = transpose;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = rightside;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag3 = lower;
			object obj7 = flag3;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = alpha;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgTrsm(IEnumerable<NDArray> outputArray, NDArray A, NDArray B, bool transpose = false, bool rightside = false, bool lower = true, double alpha = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_trsm");
			string[] names2 = new string[4]
			{
				"transpose",
				"rightside",
				"lower",
				"alpha"
			};
			string[] array = new string[4];
			bool flag = transpose;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag2 = rightside;
			object obj4 = flag2;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag3 = lower;
			object obj7 = flag3;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = alpha;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgTrsm_004038951(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004038953_002D1509(A, B, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004038954_002D1510(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgTrsm LinalgTrsm([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<Symbol> B, [Optional] [OptionalArgument] FSharpOption<bool> transpose, [Optional] [OptionalArgument] FSharpOption<bool> rightside, [Optional] [OptionalArgument] FSharpOption<bool> lower, [Optional] [OptionalArgument] FSharpOption<double> alpha)
		{
			return new SymbolOperators.LinalgTrsm(A, B, transpose, rightside, lower, alpha);
		}

		public static NDArray LinalgSumlogdiag(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_sumlogdiag");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039032_002D1511(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LinalgSumlogdiag(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_sumlogdiag");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004039063_002D195();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004039064_002D292();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgSumlogdiag_004039065(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039067_002D1512(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004039068_002D1513(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgSumlogdiag LinalgSumlogdiag([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.LinalgSumlogdiag(A);
		}

		public static NDArray LinalgExtractdiag(NDArray A, int offset = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_extractdiag");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039135_002D1514(A, 0, current));
			string[] parameterKeys = new string[1]
			{
				"offset"
			};
			string[] array = new string[1];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgExtractdiag(IEnumerable<NDArray> outputArray, NDArray A, int offset = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_extractdiag");
			string[] names2 = new string[1]
			{
				"offset"
			};
			string[] array = new string[1];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgExtractdiag_004039176(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039178_002D1515(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004039179_002D1516(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgExtractdiag LinalgExtractdiag([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<int> offset)
		{
			return new SymbolOperators.LinalgExtractdiag(A, offset);
		}

		public static NDArray LinalgMakediag(NDArray A, int offset = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_makediag");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039255_002D1517(A, 0, current));
			string[] parameterKeys = new string[1]
			{
				"offset"
			};
			string[] array = new string[1];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgMakediag(IEnumerable<NDArray> outputArray, NDArray A, int offset = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_makediag");
			string[] names2 = new string[1]
			{
				"offset"
			};
			string[] array = new string[1];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgMakediag_004039297(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039299_002D1518(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004039300_002D1519(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgMakediag LinalgMakediag([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<int> offset)
		{
			return new SymbolOperators.LinalgMakediag(A, offset);
		}

		public static NDArray LinalgExtracttrian(NDArray A, int offset = 0, bool lower = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_extracttrian");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039384_002D1520(A, 0, current));
			string[] parameterKeys = new string[2]
			{
				"offset",
				"lower"
			};
			string[] array = new string[2];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = lower;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgExtracttrian(IEnumerable<NDArray> outputArray, NDArray A, int offset = 0, bool lower = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_extracttrian");
			string[] names2 = new string[2]
			{
				"offset",
				"lower"
			};
			string[] array = new string[2];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = lower;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgExtracttrian_004039433(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039435_002D1521(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004039436_002D1522(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgExtracttrian LinalgExtracttrian([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<int> offset, [Optional] [OptionalArgument] FSharpOption<bool> lower)
		{
			return new SymbolOperators.LinalgExtracttrian(A, offset, lower);
		}

		public static NDArray LinalgMaketrian(NDArray A, int offset = 0, bool lower = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_maketrian");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039537_002D1523(A, 0, current));
			string[] parameterKeys = new string[2]
			{
				"offset",
				"lower"
			};
			string[] array = new string[2];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = lower;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgMaketrian(IEnumerable<NDArray> outputArray, NDArray A, int offset = 0, bool lower = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_maketrian");
			string[] names2 = new string[2]
			{
				"offset",
				"lower"
			};
			string[] array = new string[2];
			object obj = offset;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			bool flag = lower;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgMaketrian_004039596(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039598_002D1524(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004039599_002D1525(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgMaketrian LinalgMaketrian([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<int> offset, [Optional] [OptionalArgument] FSharpOption<bool> lower)
		{
			return new SymbolOperators.LinalgMaketrian(A, offset, lower);
		}

		public static NDArray LinalgSyrk(NDArray A, bool transpose = false, double alpha = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_syrk");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039699_002D1526(A, 0, current));
			string[] parameterKeys = new string[2]
			{
				"transpose",
				"alpha"
			};
			string[] array = new string[2];
			bool flag = transpose;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = alpha;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void LinalgSyrk(IEnumerable<NDArray> outputArray, NDArray A, bool transpose = false, double alpha = 1.0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_syrk");
			string[] names2 = new string[2]
			{
				"transpose",
				"alpha"
			};
			string[] array = new string[2];
			bool flag = transpose;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = alpha;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgSyrk_004039747(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039749_002D1527(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004039750_002D1528(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgSyrk LinalgSyrk([Optional] [OptionalArgument] FSharpOption<Symbol> A, [Optional] [OptionalArgument] FSharpOption<bool> transpose, [Optional] [OptionalArgument] FSharpOption<double> alpha)
		{
			return new SymbolOperators.LinalgSyrk(A, transpose, alpha);
		}

		public static Tuple<NDArray, NDArray> LinalgGelqf(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_gelqf");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039848_002D1529(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void LinalgGelqf(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_gelqf");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004039903_002D196();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004039904_002D293();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgGelqf_004039905(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004039907_002D1530(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004039908_002D1531(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgGelqf LinalgGelqf([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.LinalgGelqf(A);
		}

		public static Tuple<NDArray, NDArray> LinalgSyevd(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_syevd");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040014_002D1532(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void LinalgSyevd(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_syevd");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004040068_002D197();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004040069_002D294();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgSyevd_004040070(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040072_002D1533(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004040073_002D1534(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgSyevd LinalgSyevd([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.LinalgSyevd(A);
		}

		public static NDArray LinalgInverse(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_inverse");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040158_002D1535(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LinalgInverse(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_inverse");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004040192_002D198();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004040193_002D295();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgInverse_004040194(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040196_002D1536(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004040197_002D1537(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgInverse LinalgInverse([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.LinalgInverse(A);
		}

		public static NDArray LinalgDet(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_det");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040265_002D1538(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void LinalgDet(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_det");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004040302_002D199();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004040303_002D296();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgDet_004040304(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040306_002D1539(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004040307_002D1540(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgDet LinalgDet([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.LinalgDet(A);
		}

		public static Tuple<NDArray, NDArray> LinalgSlogdet(NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_slogdet");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040384_002D1541(A, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new Tuple<NDArray, NDArray>(new NDArray(outputs[0]), new NDArray(outputs[1]));
		}

		public static void LinalgSlogdet(IEnumerable<NDArray> outputArray, NDArray A)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_linalg_slogdet");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004040427_002D200();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004040428_002D297();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.LinalgSlogdet_004040429(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040431_002D1542(A, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004040432_002D1543(), outputArray)), names, vals);
		}

		public static SymbolOperators.LinalgSlogdet LinalgSlogdet([Optional] [OptionalArgument] FSharpOption<Symbol> A)
		{
			return new SymbolOperators.LinalgSlogdet(A);
		}

		public static NDArray Reshape(NDArray data, [Optional] IEnumerable<int> shape, bool reverse = false, [Optional] IEnumerable<int> targetShape, bool keepHighest = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Reshape");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040528_002D1544(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"shape",
				"reverse",
				"target_shape",
				"keep_highest"
			};
			string[] array = new string[4];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004040530_002D1545(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			bool flag = reverse;
			object obj2 = flag;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if ((targetShape == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004040530_002D1546(), targetShape));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj5 = val2.Invoke(text4);
			}
			array[2] = (string)obj5;
			bool flag2 = keepHighest;
			object obj6 = flag2;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable3 = obj6 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj7 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Reshape(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> shape, bool reverse = false, [Optional] IEnumerable<int> targetShape, bool keepHighest = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Reshape");
			string[] names2 = new string[4]
			{
				"shape",
				"reverse",
				"target_shape",
				"keep_highest"
			};
			string[] array = new string[4];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004040586_002D298(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			bool flag = reverse;
			object obj2 = flag;
			object obj3;
			if (obj2 != null)
			{
				IFormattable formattable = obj2 as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = obj2;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if ((targetShape == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004040586_002D299(), targetShape));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj5 = val2.Invoke(text4);
			}
			array[2] = (string)obj5;
			bool flag2 = keepHighest;
			object obj6 = flag2;
			object obj7;
			if (obj6 != null)
			{
				IFormattable formattable3 = obj6 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj7 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = obj6;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[3] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Reshape_004040587(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040589_002D1547(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004040590_002D1548(), outputArray)), names, vals);
		}

		public static SymbolOperators.Reshape Reshape([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape, [Optional] [OptionalArgument] FSharpOption<bool> reverse, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape, [Optional] [OptionalArgument] FSharpOption<bool> keepHighest)
		{
			return new SymbolOperators.Reshape(data, shape, reverse, targetShape, keepHighest);
		}

		public static NDArray Transpose(NDArray data, [Optional] IEnumerable<int> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("transpose");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040668_002D1549(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj;
			if ((axes == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004040670_002D1550(), axes));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Transpose(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("transpose");
			string[] names2 = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj;
			if ((axes == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004040699_002D300(), axes));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Transpose_004040700(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040702_002D1551(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004040703_002D1552(), outputArray)), names, vals);
		}

		public static SymbolOperators.Transpose Transpose([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			return new SymbolOperators.Transpose(data, axes);
		}

		public static NDArray ExpandDims(NDArray data, int axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("expand_dims");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040744_002D1553(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ExpandDims(IEnumerable<NDArray> outputArray, NDArray data, int axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("expand_dims");
			string[] names2 = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ExpandDims_004040761(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040763_002D1554(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004040764_002D1555(), outputArray)), names, vals);
		}

		public static SymbolOperators.ExpandDims ExpandDims(Symbol data, int axis)
		{
			return new SymbolOperators.ExpandDims(data, axis);
		}

		public static SymbolOperators.ExpandDims ExpandDims(int axis, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.ExpandDims(axis, data);
		}

		public static NDArray[] Slice(NDArray data, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] IEnumerable<FSharpOption<int>> step)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("slice");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040832_002D1556(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"begin",
				"end",
				"step"
			};
			string[] array = new string[3];
			object obj;
			if (sliceBegin != null)
			{
				IFormattable formattable = sliceBegin as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = sliceBegin;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (sliceEnd != null)
			{
				IFormattable formattable3 = sliceEnd as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = sliceEnd;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if ((step == null) ? true : false)
			{
				obj5 = "[]";
			}
			else if (step != null)
			{
				IFormattable formattable5 = step as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj5 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = step;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.Slice_004040835();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void Slice(IEnumerable<NDArray> outputArray, NDArray data, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] IEnumerable<FSharpOption<int>> step)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("slice");
			string[] names2 = new string[3]
			{
				"begin",
				"end",
				"step"
			};
			string[] array = new string[3];
			object obj;
			if (sliceBegin != null)
			{
				IFormattable formattable = sliceBegin as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = sliceBegin;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (sliceEnd != null)
			{
				IFormattable formattable3 = sliceEnd as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = sliceEnd;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if ((step == null) ? true : false)
			{
				obj5 = "[]";
			}
			else if (step != null)
			{
				IFormattable formattable5 = step as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj5 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = step;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Slice_004040881_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040883_002D1557(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004040884_002D1558(), outputArray)), names, vals);
		}

		public static SymbolOperators.Slice Slice(Symbol data, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] [OptionalArgument] FSharpOption<IEnumerable<FSharpOption<int>>> step)
		{
			return new SymbolOperators.Slice(data, sliceBegin, sliceEnd, step);
		}

		public static SymbolOperators.Slice Slice(IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<FSharpOption<int>>> step)
		{
			return new SymbolOperators.Slice(sliceBegin, sliceEnd, data, step);
		}

		public static NDArray SliceAssign(NDArray lhs, NDArray rhs, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] IEnumerable<FSharpOption<int>> step)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_slice_assign");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004040995_002D1559(lhs, rhs, 0, current));
			string[] parameterKeys = new string[3]
			{
				"begin",
				"end",
				"step"
			};
			string[] array = new string[3];
			object obj;
			if (sliceBegin != null)
			{
				IFormattable formattable = sliceBegin as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = sliceBegin;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (sliceEnd != null)
			{
				IFormattable formattable3 = sliceEnd as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = sliceEnd;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if ((step == null) ? true : false)
			{
				obj5 = "[]";
			}
			else if (step != null)
			{
				IFormattable formattable5 = step as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj5 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = step;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SliceAssign(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] IEnumerable<FSharpOption<int>> step)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_slice_assign");
			string[] names2 = new string[3]
			{
				"begin",
				"end",
				"step"
			};
			string[] array = new string[3];
			object obj;
			if (sliceBegin != null)
			{
				IFormattable formattable = sliceBegin as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = sliceBegin;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (sliceEnd != null)
			{
				IFormattable formattable3 = sliceEnd as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = sliceEnd;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5;
			if ((step == null) ? true : false)
			{
				obj5 = "[]";
			}
			else if (step != null)
			{
				IFormattable formattable5 = step as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj5 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = step;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SliceAssign_004041023(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041025_002D1560(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041026_002D1561(), outputArray)), names, vals);
		}

		public static SymbolOperators.SliceAssign SliceAssign(Symbol lhs, Symbol rhs, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] [OptionalArgument] FSharpOption<IEnumerable<FSharpOption<int>>> step)
		{
			return new SymbolOperators.SliceAssign(lhs, rhs, sliceBegin, sliceEnd, step);
		}

		public static SymbolOperators.SliceAssign SliceAssign(IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] [OptionalArgument] FSharpOption<Symbol> lhs, [Optional] [OptionalArgument] FSharpOption<Symbol> rhs, [Optional] [OptionalArgument] FSharpOption<IEnumerable<FSharpOption<int>>> step)
		{
			return new SymbolOperators.SliceAssign(sliceBegin, sliceEnd, lhs, rhs, step);
		}

		public static NDArray SliceAssignScalar(NDArray data, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, double scalar = 0.0, [Optional] IEnumerable<FSharpOption<int>> step)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_slice_assign_scalar");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041083_002D1562(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"begin",
				"end",
				"scalar",
				"step"
			};
			string[] array = new string[4];
			object obj;
			if (sliceBegin != null)
			{
				IFormattable formattable = sliceBegin as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = sliceBegin;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (sliceEnd != null)
			{
				IFormattable formattable3 = sliceEnd as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = sliceEnd;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5 = scalar;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			object obj8;
			if ((step == null) ? true : false)
			{
				obj8 = "[]";
			}
			else if (step != null)
			{
				IFormattable formattable7 = step as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj8 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = step;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SliceAssignScalar(IEnumerable<NDArray> outputArray, NDArray data, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, double scalar = 0.0, [Optional] IEnumerable<FSharpOption<int>> step)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_slice_assign_scalar");
			string[] names2 = new string[4]
			{
				"begin",
				"end",
				"scalar",
				"step"
			};
			string[] array = new string[4];
			object obj;
			if (sliceBegin != null)
			{
				IFormattable formattable = sliceBegin as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = sliceBegin;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if (sliceEnd != null)
			{
				IFormattable formattable3 = sliceEnd as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj3 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj4 = sliceEnd;
					obj3 = obj4.ToString();
				}
			}
			else
			{
				obj3 = "";
			}
			array[1] = (string)obj3;
			object obj5 = scalar;
			object obj6;
			if (obj5 != null)
			{
				IFormattable formattable5 = obj5 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj6 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj7 = obj5;
					obj6 = obj7.ToString();
				}
			}
			else
			{
				obj6 = "";
			}
			array[2] = (string)obj6;
			object obj8;
			if ((step == null) ? true : false)
			{
				obj8 = "[]";
			}
			else if (step != null)
			{
				IFormattable formattable7 = step as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj8 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = step;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SliceAssignScalar_004041110(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041112_002D1563(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041113_002D1564(), outputArray)), names, vals);
		}

		public static SymbolOperators.SliceAssignScalar SliceAssignScalar(Symbol data, IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] [OptionalArgument] FSharpOption<double> scalar, [Optional] [OptionalArgument] FSharpOption<IEnumerable<FSharpOption<int>>> step)
		{
			return new SymbolOperators.SliceAssignScalar(data, sliceBegin, sliceEnd, scalar, step);
		}

		public static SymbolOperators.SliceAssignScalar SliceAssignScalar(IEnumerable<FSharpOption<int>> sliceBegin, IEnumerable<FSharpOption<int>> sliceEnd, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> scalar, [Optional] [OptionalArgument] FSharpOption<IEnumerable<FSharpOption<int>>> step)
		{
			return new SymbolOperators.SliceAssignScalar(sliceBegin, sliceEnd, data, scalar, step);
		}

		public static NDArray SliceAxis(NDArray data, int axis, int sliceBegin, [Optional] [OptionalArgument] FSharpOption<int> sliceEnd)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("slice_axis");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041173_002D1565(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"begin",
				"end"
			};
			string[] array = new string[3];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = sliceBegin;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (sliceEnd == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<int> val = sliceEnd;
				int sliceEnd2 = val.get_Value();
				int num = sliceEnd2;
				object obj8 = num;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SliceAxis(IEnumerable<NDArray> outputArray, NDArray data, int axis, int sliceBegin, [Optional] [OptionalArgument] FSharpOption<int> sliceEnd)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("slice_axis");
			string[] names2 = new string[3]
			{
				"axis",
				"begin",
				"end"
			};
			string[] array = new string[3];
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = sliceBegin;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if (sliceEnd == null)
			{
				obj7 = "None";
			}
			else
			{
				FSharpOption<int> val = sliceEnd;
				int sliceEnd2 = val.get_Value();
				int num = sliceEnd2;
				object obj8 = num;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SliceAxis_004041204(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041206_002D1566(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041207_002D1567(), outputArray)), names, vals);
		}

		public static SymbolOperators.SliceAxis SliceAxis(Symbol data, int axis, int sliceBegin, [Optional] [OptionalArgument] FSharpOption<int> sliceEnd)
		{
			return new SymbolOperators.SliceAxis(data, axis, sliceBegin, sliceEnd);
		}

		public static SymbolOperators.SliceAxis SliceAxis(int axis, int sliceBegin, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> sliceEnd)
		{
			return new SymbolOperators.SliceAxis(axis, sliceBegin, data, sliceEnd);
		}

		public static NDArray SliceLike(NDArray data, NDArray shapeLike, [Optional] IEnumerable<int> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("slice_like");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041305_002D1568(data, shapeLike, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj;
			if ((axes == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004041307_002D1569(), axes));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SliceLike(IEnumerable<NDArray> outputArray, NDArray data, NDArray shapeLike, [Optional] IEnumerable<int> axes)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("slice_like");
			string[] names2 = new string[1]
			{
				"axes"
			};
			string[] array = new string[1];
			object obj;
			if ((axes == null) ? true : false)
			{
				obj = "[]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004041354_002D301(), axes));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SliceLike_004041355(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041357_002D1570(data, shapeLike, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041358_002D1571(), outputArray)), names, vals);
		}

		public static SymbolOperators.SliceLike SliceLike([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> shapeLike, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axes)
		{
			return new SymbolOperators.SliceLike(data, shapeLike, axes);
		}

		public static NDArray Clip(NDArray data, double aMin, double aMax)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("clip");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041433_002D1572(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"a_min",
				"a_max"
			};
			string[] array = new string[2];
			object obj = aMin;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = aMax;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Clip(IEnumerable<NDArray> outputArray, NDArray data, double aMin, double aMax)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("clip");
			string[] names2 = new string[2]
			{
				"a_min",
				"a_max"
			};
			string[] array = new string[2];
			object obj = aMin;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = aMax;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Clip_004041465(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041467_002D1573(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041468_002D1574(), outputArray)), names, vals);
		}

		public static SymbolOperators.Clip Clip(Symbol data, double aMin, double aMax)
		{
			return new SymbolOperators.Clip(data, aMin, aMax);
		}

		public static SymbolOperators.Clip Clip(double aMin, double aMax, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Clip(aMin, aMax, data);
		}

		public static NDArray Repeat(NDArray data, int repeats, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("repeat");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041548_002D1575(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"repeats",
				"axis"
			};
			string[] array = new string[2];
			object obj = repeats;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (axis == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj5 = num;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Repeat(IEnumerable<NDArray> outputArray, NDArray data, int repeats, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("repeat");
			string[] names2 = new string[2]
			{
				"repeats",
				"axis"
			};
			string[] array = new string[2];
			object obj = repeats;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if (axis == null)
			{
				obj4 = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj5 = num;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Repeat_004041578(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041580_002D1576(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041581_002D1577(), outputArray)), names, vals);
		}

		public static SymbolOperators.Repeat Repeat(Symbol data, int repeats, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.Repeat(data, repeats, axis);
		}

		public static SymbolOperators.Repeat Repeat(int repeats, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.Repeat(repeats, data, axis);
		}

		public static NDArray Tile(NDArray data, IEnumerable<int> reps)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("tile");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041665_002D1578(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"reps"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004041667_002D1579(), reps));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Tile(IEnumerable<NDArray> outputArray, NDArray data, IEnumerable<int> reps)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("tile");
			string[] names2 = new string[1]
			{
				"reps"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004041702_002D302(), reps));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Tile_004041703(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041705_002D1580(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041706_002D1581(), outputArray)), names, vals);
		}

		public static SymbolOperators.Tile Tile(Symbol data, IEnumerable<int> reps)
		{
			return new SymbolOperators.Tile(data, reps);
		}

		public static SymbolOperators.Tile Tile(IEnumerable<int> reps, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Tile(reps, data);
		}

		public static NDArray Reverse(NDArray data, IEnumerable<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("reverse");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041791_002D1582(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004041793_002D1583(), axis));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Reverse(IEnumerable<NDArray> outputArray, NDArray data, IEnumerable<int> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("reverse");
			string[] names2 = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004041813_002D303(), axis));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Reverse_004041814(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041816_002D1584(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041817_002D1585(), outputArray)), names, vals);
		}

		public static SymbolOperators.Reverse Reverse(Symbol data, IEnumerable<int> axis)
		{
			return new SymbolOperators.Reverse(data, axis);
		}

		public static SymbolOperators.Reverse Reverse(IEnumerable<int> axis, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.Reverse(axis, data);
		}

		public static NDArray Stack(params NDArray[] data, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("stack");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004041873_002D1586();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = val.Invoke(data[i]);
			}
			string[] parameterKeys = new string[2]
			{
				"num_args",
				"axis"
			};
			string[] array2 = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array2[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array2[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator2, array, parameterKeys, array2);
			return new NDArray(outputs[0]);
		}

		public static void Stack(IEnumerable<NDArray> outputArray, params NDArray[] data, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("stack");
			string[] names2 = new string[2]
			{
				"num_args",
				"axis"
			};
			string[] array = new string[2];
			int num = data.Length;
			object obj = num;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Stack_004041897(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			FSharpFunc<NDArray, IntPtr> val = new _0024Operators.outputs_004041899_002D1587();
			if (data == null)
			{
				throw new ArgumentNullException("array");
			}
			IntPtr[] array2 = new IntPtr[data.Length];
			IntPtr creator2 = atomicSymbolCreatorHandle;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = val.Invoke(data[i]);
			}
			int outputs = MXNDArray.imperativeInvokeInto(creator2, array2, SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041900_002D1588(), outputArray)), names, vals);
		}

		public static SymbolOperators.Stack Stack([Optional] [OptionalArgument] FSharpOption<IEnumerable<Symbol>> data, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.Stack(data, axis);
		}

		public static NDArray Squeeze(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("squeeze");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041940_002D1589(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004041942_002D1590(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Squeeze(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("squeeze");
			string[] names2 = new string[1]
			{
				"axis"
			};
			string[] array = new string[1];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004041963_002D304(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Squeeze_004041964(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004041966_002D1591(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004041967_002D1592(), outputArray)), names, vals);
		}

		public static SymbolOperators.Squeeze Squeeze([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis)
		{
			return new SymbolOperators.Squeeze(data, axis);
		}

		public static NDArray DepthToSpace(NDArray data, int blockSize)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("depth_to_space");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042024_002D1593(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"block_size"
			};
			string[] array = new string[1];
			object obj = blockSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void DepthToSpace(IEnumerable<NDArray> outputArray, NDArray data, int blockSize)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("depth_to_space");
			string[] names2 = new string[1]
			{
				"block_size"
			};
			string[] array = new string[1];
			object obj = blockSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.DepthToSpace_004042064(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042066_002D1594(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004042067_002D1595(), outputArray)), names, vals);
		}

		public static SymbolOperators.DepthToSpace DepthToSpace(Symbol data, int blockSize)
		{
			return new SymbolOperators.DepthToSpace(data, blockSize);
		}

		public static SymbolOperators.DepthToSpace DepthToSpace(int blockSize, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.DepthToSpace(blockSize, data);
		}

		public static NDArray SpaceToDepth(NDArray data, int blockSize)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("space_to_depth");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042172_002D1596(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"block_size"
			};
			string[] array = new string[1];
			object obj = blockSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SpaceToDepth(IEnumerable<NDArray> outputArray, NDArray data, int blockSize)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("space_to_depth");
			string[] names2 = new string[1]
			{
				"block_size"
			};
			string[] array = new string[1];
			object obj = blockSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SpaceToDepth_004042212(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042214_002D1597(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004042215_002D1598(), outputArray)), names, vals);
		}

		public static SymbolOperators.SpaceToDepth SpaceToDepth(Symbol data, int blockSize)
		{
			return new SymbolOperators.SpaceToDepth(data, blockSize);
		}

		public static SymbolOperators.SpaceToDepth SpaceToDepth(int blockSize, [Optional] [OptionalArgument] FSharpOption<Symbol> data)
		{
			return new SymbolOperators.SpaceToDepth(blockSize, data);
		}

		public static NDArray[] SplitV2(NDArray data, IEnumerable<int> indices, int axis = 1, bool squeezeAxis = false, int sections = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_split_v2");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042348_002D1599(data, 0, current));
			string[] parameterKeys = new string[4]
			{
				"indices",
				"axis",
				"squeeze_axis",
				"sections"
			};
			string[] array = new string[4];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004042350_002D1600(), indices));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			bool flag = squeezeAxis;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			object obj7 = sections;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.SplitV2_004042351();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SplitV2(IEnumerable<NDArray> outputArray, NDArray data, IEnumerable<int> indices, int axis = 1, bool squeezeAxis = false, int sections = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_split_v2");
			string[] names2 = new string[4]
			{
				"indices",
				"axis",
				"squeeze_axis",
				"sections"
			};
			string[] array = new string[4];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004042416_002D305(), indices));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = axis;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			bool flag = squeezeAxis;
			object obj4 = flag;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[2] = (string)obj5;
			object obj7 = sections;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SplitV2_004042417_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042419_002D1601(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004042420_002D1602(), outputArray)), names, vals);
		}

		public static SymbolOperators.SplitV2 SplitV2(Symbol data, IEnumerable<int> indices, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> squeezeAxis, [Optional] [OptionalArgument] FSharpOption<int> sections)
		{
			return new SymbolOperators.SplitV2(data, indices, axis, squeezeAxis, sections);
		}

		public static SymbolOperators.SplitV2 SplitV2(IEnumerable<int> indices, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> squeezeAxis, [Optional] [OptionalArgument] FSharpOption<int> sections)
		{
			return new SymbolOperators.SplitV2(indices, data, axis, squeezeAxis, sections);
		}

		public static NDArray SplitV2BackwardNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_split_v2_backward");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void SplitV2Backward(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_split_v2_backward");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004042549_002D201();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004042550_002D306();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SplitV2Backward_004042551(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004042554_002D1603(), outputArray)), names, vals);
		}

		public static SymbolOperators.SplitV2Backward SplitV2Backward()
		{
			return new SymbolOperators.SplitV2Backward();
		}

		public static NDArray[] Topk(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.RetTyp> retTyp, [Optional] [OptionalArgument] FSharpOption<bool> isAscend, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("topk");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042609_002D1604(data, 0, current));
			string[] parameterKeys = new string[5]
			{
				"axis",
				"k",
				"ret_typ",
				"is_ascend",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (k == null)
			{
				obj4 = "1";
			}
			else
			{
				FSharpOption<int> val2 = k;
				int i = val2.get_Value();
				int num2 = i;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (retTyp == null)
			{
				obj7 = "indices";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.RetTyp> val3 = retTyp;
				GeneratedArgumentTypes.RetTyp retTyp2 = val3.get_Value();
				GeneratedArgumentTypes.RetTyp retTyp3 = retTyp2;
				object obj8 = retTyp3;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (isAscend == null)
			{
				obj10 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = isAscend;
				bool isAscend2 = val4.get_Value();
				bool flag = isAscend2;
				object obj11 = flag;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (dtype == null)
			{
				obj13 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj14 = dataType;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val6 = new _0024Operators.Topk_004042612();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				array4[j] = val6.Invoke(array3[j]);
			}
			return array4;
		}

		public static void Topk(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.RetTyp> retTyp, [Optional] [OptionalArgument] FSharpOption<bool> isAscend, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("topk");
			string[] names2 = new string[5]
			{
				"axis",
				"k",
				"ret_typ",
				"is_ascend",
				"dtype"
			};
			string[] array = new string[5];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (k == null)
			{
				obj4 = "1";
			}
			else
			{
				FSharpOption<int> val2 = k;
				int i = val2.get_Value();
				int num2 = i;
				object obj5 = num2;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (retTyp == null)
			{
				obj7 = "indices";
			}
			else
			{
				FSharpOption<GeneratedArgumentTypes.RetTyp> val3 = retTyp;
				GeneratedArgumentTypes.RetTyp retTyp2 = val3.get_Value();
				GeneratedArgumentTypes.RetTyp retTyp3 = retTyp2;
				object obj8 = retTyp3;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			object obj10;
			if (isAscend == null)
			{
				obj10 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = isAscend;
				bool isAscend2 = val4.get_Value();
				bool flag = isAscend2;
				object obj11 = flag;
				if (obj11 != null)
				{
					IFormattable formattable7 = obj11 as IFormattable;
					if (formattable7 != null)
					{
						IFormattable formattable8 = formattable7;
						obj10 = formattable8.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj12 = obj11;
						obj10 = obj12.ToString();
					}
				}
				else
				{
					obj10 = "";
				}
			}
			array[3] = (string)obj10;
			object obj13;
			if (dtype == null)
			{
				obj13 = "float32";
			}
			else
			{
				FSharpOption<DataType> val5 = dtype;
				DataType dtype2 = val5.get_Value();
				DataType dataType = dtype2;
				object obj14 = dataType;
				if (obj14 != null)
				{
					IFormattable formattable9 = obj14 as IFormattable;
					if (formattable9 != null)
					{
						IFormattable formattable10 = formattable9;
						obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj15 = obj14;
						obj13 = obj15.ToString();
					}
				}
				else
				{
					obj13 = "";
				}
			}
			array[4] = (string)obj13;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Topk_004042664_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042666_002D1605(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004042667_002D1606(), outputArray)), names, vals);
		}

		public static SymbolOperators.Topk Topk([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<int> k, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.RetTyp> retTyp, [Optional] [OptionalArgument] FSharpOption<bool> isAscend, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.Topk(data, axis, k, retTyp, isAscend, dtype);
		}

		public static NDArray Sort(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> isAscend)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sort");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042746_002D1607(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"axis",
				"is_ascend"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (isAscend == null)
			{
				obj4 = "true";
			}
			else
			{
				FSharpOption<bool> val2 = isAscend;
				bool isAscend2 = val2.get_Value();
				bool flag = isAscend2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Sort(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> isAscend)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("sort");
			string[] names2 = new string[2]
			{
				"axis",
				"is_ascend"
			};
			string[] array = new string[2];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (isAscend == null)
			{
				obj4 = "true";
			}
			else
			{
				FSharpOption<bool> val2 = isAscend;
				bool isAscend2 = val2.get_Value();
				bool flag = isAscend2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Sort_004042783(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042785_002D1608(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004042786_002D1609(), outputArray)), names, vals);
		}

		public static SymbolOperators.Sort Sort([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> isAscend)
		{
			return new SymbolOperators.Sort(data, axis, isAscend);
		}

		public static NDArray Argsort(NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> isAscend, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("argsort");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042851_002D1610(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"is_ascend",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (isAscend == null)
			{
				obj4 = "true";
			}
			else
			{
				FSharpOption<bool> val2 = isAscend;
				bool isAscend2 = val2.get_Value();
				bool flag = isAscend2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (dtype == null)
			{
				obj7 = "float32";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj8 = dataType;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void Argsort(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> isAscend, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("argsort");
			string[] names2 = new string[3]
			{
				"axis",
				"is_ascend",
				"dtype"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<int> val = axis;
				int axis2 = val.get_Value();
				int num = axis2;
				object obj2 = num;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			object obj4;
			if (isAscend == null)
			{
				obj4 = "true";
			}
			else
			{
				FSharpOption<bool> val2 = isAscend;
				bool isAscend2 = val2.get_Value();
				bool flag = isAscend2;
				object obj5 = flag;
				if (obj5 != null)
				{
					IFormattable formattable3 = obj5 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj6 = obj5;
						obj4 = obj6.ToString();
					}
				}
				else
				{
					obj4 = "";
				}
			}
			array[1] = (string)obj4;
			object obj7;
			if (dtype == null)
			{
				obj7 = "float32";
			}
			else
			{
				FSharpOption<DataType> val3 = dtype;
				DataType dtype2 = val3.get_Value();
				DataType dataType = dtype2;
				object obj8 = dataType;
				if (obj8 != null)
				{
					IFormattable formattable5 = obj8 as IFormattable;
					if (formattable5 != null)
					{
						IFormattable formattable6 = formattable5;
						obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj9 = obj8;
						obj7 = obj9.ToString();
					}
				}
				else
				{
					obj7 = "";
				}
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Argsort_004042887(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042889_002D1611(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004042890_002D1612(), outputArray)), names, vals);
		}

		public static SymbolOperators.Argsort Argsort([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> axis, [Optional] [OptionalArgument] FSharpOption<bool> isAscend, [Optional] [OptionalArgument] FSharpOption<DataType> dtype)
		{
			return new SymbolOperators.Argsort(data, axis, isAscend, dtype);
		}

		public static NDArray RavelMultiIndex(NDArray data, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_ravel_multi_index");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042940_002D1613(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004042942_002D1614(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void RavelMultiIndex(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_ravel_multi_index");
			string[] names2 = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004042961_002D307(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.RavelMultiIndex_004042962(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004042964_002D1615(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004042965_002D1616(), outputArray)), names, vals);
		}

		public static SymbolOperators.RavelMultiIndex RavelMultiIndex([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape)
		{
			return new SymbolOperators.RavelMultiIndex(data, shape);
		}

		public static NDArray UnravelIndex(NDArray data, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_unravel_index");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043001_002D1617(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004043003_002D1618(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void UnravelIndex(IEnumerable<NDArray> outputArray, NDArray data, [Optional] IEnumerable<int> shape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_unravel_index");
			string[] names2 = new string[1]
			{
				"shape"
			};
			string[] array = new string[1];
			object obj;
			if ((shape == null) ? true : false)
			{
				obj = null;
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004043022_002D308(), shape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val.Invoke(text2);
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.UnravelIndex_004043023(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043025_002D1619(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004043026_002D1620(), outputArray)), names, vals);
		}

		public static SymbolOperators.UnravelIndex UnravelIndex([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> shape)
		{
			return new SymbolOperators.UnravelIndex(data, shape);
		}

		public static NDArray SparseRetain(NDArray data, NDArray indices)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sparse_retain");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043073_002D1621(data, indices, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			return new NDArray(outputs[0]);
		}

		public static void SparseRetain(IEnumerable<NDArray> outputArray, NDArray data, NDArray indices)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_sparse_retain");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004043104_002D202();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004043105_002D309();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SparseRetain_004043106(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043108_002D1622(data, indices, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004043109_002D1623(), outputArray)), names, vals);
		}

		public static SymbolOperators.SparseRetain SparseRetain([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> indices)
		{
			return new SymbolOperators.SparseRetain(data, indices);
		}

		public static NDArray SquareSum(NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_square_sum");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043176_002D1624(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004043178_002D1625(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SquareSum(IEnumerable<NDArray> outputArray, NDArray data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_square_sum");
			string[] names2 = new string[3]
			{
				"axis",
				"keepdims",
				"exclude"
			};
			string[] array = new string[3];
			object obj;
			if (axis == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = axis;
				IEnumerable<int> axis2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004043216_002D310(), axis2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj = val2.Invoke(text2);
			}
			array[0] = (string)obj;
			object obj2;
			if (keepdims == null)
			{
				obj2 = "false";
			}
			else
			{
				FSharpOption<bool> val3 = keepdims;
				bool keepdims2 = val3.get_Value();
				bool flag = keepdims2;
				object obj3 = flag;
				if (obj3 != null)
				{
					IFormattable formattable = obj3 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj4 = obj3;
						obj2 = obj4.ToString();
					}
				}
				else
				{
					obj2 = "";
				}
			}
			array[1] = (string)obj2;
			object obj5;
			if (exclude == null)
			{
				obj5 = "false";
			}
			else
			{
				FSharpOption<bool> val4 = exclude;
				bool exclude2 = val4.get_Value();
				bool flag2 = exclude2;
				object obj6 = flag2;
				if (obj6 != null)
				{
					IFormattable formattable3 = obj6 as IFormattable;
					if (formattable3 != null)
					{
						IFormattable formattable4 = formattable3;
						obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj7 = obj6;
						obj5 = obj7.ToString();
					}
				}
				else
				{
					obj5 = "";
				}
			}
			array[2] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SquareSum_004043217(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043219_002D1626(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004043220_002D1627(), outputArray)), names, vals);
		}

		public static SymbolOperators.SquareSum SquareSum([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> axis, [Optional] [OptionalArgument] FSharpOption<bool> keepdims, [Optional] [OptionalArgument] FSharpOption<bool> exclude)
		{
			return new SymbolOperators.SquareSum(data, axis, keepdims, exclude);
		}

		public static NDArray[] ContribMrcnnMaskTarget(NDArray rois, NDArray gtMasks, NDArray matches, NDArray clsTargets, int numRois, int numClasses, IEnumerable<int> maskSize, int sampleRatio = 2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_mrcnn_mask_target");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043279_002D1628(rois, gtMasks, matches, clsTargets, 0, current));
			string[] parameterKeys = new string[4]
			{
				"num_rois",
				"num_classes",
				"mask_size",
				"sample_ratio"
			};
			string[] array = new string[4];
			object obj = numRois;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numClasses;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004043281_002D1629(), maskSize));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[2] = val.Invoke(text2);
			object obj7 = sampleRatio;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.ContribMrcnnMaskTarget_004043282();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribMrcnnMaskTarget(IEnumerable<NDArray> outputArray, NDArray rois, NDArray gtMasks, NDArray matches, NDArray clsTargets, int numRois, int numClasses, IEnumerable<int> maskSize, int sampleRatio = 2)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_mrcnn_mask_target");
			string[] names2 = new string[4]
			{
				"num_rois",
				"num_classes",
				"mask_size",
				"sample_ratio"
			};
			string[] array = new string[4];
			object obj = numRois;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = numClasses;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004043304_002D311(), maskSize));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[2] = val.Invoke(text2);
			object obj7 = sampleRatio;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[3] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribMrcnnMaskTarget_004043305_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043307_002D1630(rois, gtMasks, matches, clsTargets, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004043308_002D1631(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribMrcnnMaskTarget ContribMrcnnMaskTarget(Symbol rois, Symbol gtMasks, Symbol matches, Symbol clsTargets, int numRois, int numClasses, IEnumerable<int> maskSize, [Optional] [OptionalArgument] FSharpOption<int> sampleRatio)
		{
			return new SymbolOperators.ContribMrcnnMaskTarget(rois, gtMasks, matches, clsTargets, numRois, numClasses, maskSize, sampleRatio);
		}

		public static SymbolOperators.ContribMrcnnMaskTarget ContribMrcnnMaskTarget(int numRois, int numClasses, IEnumerable<int> maskSize, [Optional] [OptionalArgument] FSharpOption<Symbol> rois, [Optional] [OptionalArgument] FSharpOption<Symbol> gtMasks, [Optional] [OptionalArgument] FSharpOption<Symbol> matches, [Optional] [OptionalArgument] FSharpOption<Symbol> clsTargets, [Optional] [OptionalArgument] FSharpOption<int> sampleRatio)
		{
			return new SymbolOperators.ContribMrcnnMaskTarget(numRois, numClasses, maskSize, rois, gtMasks, matches, clsTargets, sampleRatio);
		}

		public static NDArray[] BilinearSampler(NDArray data, NDArray grid, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("BilinearSampler");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043416_002D1632(data, grid, 0, current));
			string[] parameterKeys = new string[1]
			{
				"cudnn_off"
			};
			string[] array = new string[1];
			object obj;
			if (cudnnOff == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<bool> val = cudnnOff;
				bool cudnnOff2 = val.get_Value();
				bool flag = cudnnOff2;
				object obj2 = flag;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.BilinearSampler_004043419();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void BilinearSampler(IEnumerable<NDArray> outputArray, NDArray data, NDArray grid, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("BilinearSampler");
			string[] names2 = new string[1]
			{
				"cudnn_off"
			};
			string[] array = new string[1];
			object obj;
			if (cudnnOff == null)
			{
				obj = "None";
			}
			else
			{
				FSharpOption<bool> val = cudnnOff;
				bool cudnnOff2 = val.get_Value();
				bool flag = cudnnOff2;
				object obj2 = flag;
				if (obj2 != null)
				{
					IFormattable formattable = obj2 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj3 = obj2;
						obj = obj3.ToString();
					}
				}
				else
				{
					obj = "";
				}
			}
			array[0] = (string)obj;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.BilinearSampler_004043502_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043504_002D1633(data, grid, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004043505_002D1634(), outputArray)), names, vals);
		}

		public static SymbolOperators.BilinearSampler BilinearSampler([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> grid, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			return new SymbolOperators.BilinearSampler(data, grid, cudnnOff);
		}

		public static NDArray[] ContribCountSketch(NDArray data, NDArray h, NDArray s, int outDim, int processingBatchSize = 32)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_count_sketch");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043626_002D1635(data, h, s, 0, current));
			string[] parameterKeys = new string[2]
			{
				"out_dim",
				"processing_batch_size"
			};
			string[] array = new string[2];
			object obj = outDim;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = processingBatchSize;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribCountSketch_004043629();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribCountSketch(IEnumerable<NDArray> outputArray, NDArray data, NDArray h, NDArray s, int outDim, int processingBatchSize = 32)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_count_sketch");
			string[] names2 = new string[2]
			{
				"out_dim",
				"processing_batch_size"
			};
			string[] array = new string[2];
			object obj = outDim;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = processingBatchSize;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribCountSketch_004043669_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043671_002D1636(data, h, s, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004043672_002D1637(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribCountSketch ContribCountSketch(Symbol data, Symbol h, Symbol s, int outDim, [Optional] [OptionalArgument] FSharpOption<int> processingBatchSize)
		{
			return new SymbolOperators.ContribCountSketch(data, h, s, outDim, processingBatchSize);
		}

		public static SymbolOperators.ContribCountSketch ContribCountSketch(int outDim, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> h, [Optional] [OptionalArgument] FSharpOption<Symbol> s, [Optional] [OptionalArgument] FSharpOption<int> processingBatchSize)
		{
			return new SymbolOperators.ContribCountSketch(outDim, data, h, s, processingBatchSize);
		}

		public static NDArray[] ContribDeformableConvolution(NDArray data, NDArray offset, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, int numDeformableGroup = 1, long workspace = 1024L, bool noBias = false, [Optional] GeneratedArgumentTypes.ContribDeformableConvolutionLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_DeformableConvolution");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043816_002D1638(data, offset, weight, bias, 0, current));
			string[] parameterKeys = new string[10]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"num_deformable_group",
				"workspace",
				"no_bias",
				"layout"
			};
			string[] array = new string[10];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004043818_002D1639(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004043818_002D1640(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004043818_002D1641(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004043818_002D1642(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = numDeformableGroup;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			object obj13 = workspace;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			bool flag = noBias;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable9 = obj16 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj17 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[8] = (string)obj17;
			object obj19;
			if ((layout == null) ? true : false)
			{
				obj19 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable11 = layout as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = layout;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[9] = (string)obj19;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val5 = new _0024Operators.ContribDeformableConvolution_004043819();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val5.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribDeformableConvolution(IEnumerable<NDArray> outputArray, NDArray data, NDArray offset, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, int numDeformableGroup = 1, long workspace = 1024L, bool noBias = false, [Optional] GeneratedArgumentTypes.ContribDeformableConvolutionLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_DeformableConvolution");
			string[] names2 = new string[10]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"num_deformable_group",
				"workspace",
				"no_bias",
				"layout"
			};
			string[] array = new string[10];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004043898_002D312(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004043898_002D313(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004043898_002D314(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004043898_002D315(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = numDeformableGroup;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			object obj13 = workspace;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			bool flag = noBias;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable9 = obj16 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj17 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[8] = (string)obj17;
			object obj19;
			if ((layout == null) ? true : false)
			{
				obj19 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable11 = layout as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = layout;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[9] = (string)obj19;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribDeformableConvolution_004043899_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004043901_002D1643(data, offset, weight, bias, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004043902_002D1644(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribDeformableConvolution ContribDeformableConvolution(Symbol data, Symbol offset, Symbol weight, Symbol bias, IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<int> numDeformableGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribDeformableConvolutionLayout> layout)
		{
			return new SymbolOperators.ContribDeformableConvolution(data, offset, weight, bias, kernel, numFilter, stride, dilate, pad, numGroup, numDeformableGroup, workspace, noBias, layout);
		}

		public static SymbolOperators.ContribDeformableConvolution ContribDeformableConvolution(IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> offset, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> bias, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<int> numDeformableGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribDeformableConvolutionLayout> layout)
		{
			return new SymbolOperators.ContribDeformableConvolution(kernel, numFilter, data, offset, weight, bias, stride, dilate, pad, numGroup, numDeformableGroup, workspace, noBias, layout);
		}

		public static SymbolOperators.ContribDeformablePSROIPooling ContribDeformablePSROIPooling(Symbol data, Symbol rois, Symbol trans, double spatialScale, int outputDim, int groupSize, int pooledSize, [Optional] [OptionalArgument] FSharpOption<int> partSize, [Optional] [OptionalArgument] FSharpOption<int> samplePerPart, [Optional] [OptionalArgument] FSharpOption<double> transStd, [Optional] [OptionalArgument] FSharpOption<bool> noTrans)
		{
			return new SymbolOperators.ContribDeformablePSROIPooling(data, rois, trans, spatialScale, outputDim, groupSize, pooledSize, partSize, samplePerPart, transStd, noTrans);
		}

		public static SymbolOperators.ContribDeformablePSROIPooling ContribDeformablePSROIPooling(double spatialScale, int outputDim, int groupSize, int pooledSize, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> rois, [Optional] [OptionalArgument] FSharpOption<Symbol> trans, [Optional] [OptionalArgument] FSharpOption<int> partSize, [Optional] [OptionalArgument] FSharpOption<int> samplePerPart, [Optional] [OptionalArgument] FSharpOption<double> transStd, [Optional] [OptionalArgument] FSharpOption<bool> noTrans)
		{
			return new SymbolOperators.ContribDeformablePSROIPooling(spatialScale, outputDim, groupSize, pooledSize, data, rois, trans, partSize, samplePerPart, transStd, noTrans);
		}

		public static NDArray[] ContribFft(NDArray data, int computeSize = 128)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_fft");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044084_002D1645(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"compute_size"
			};
			string[] array = new string[1];
			object obj = computeSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribFft_004044087();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribFft(IEnumerable<NDArray> outputArray, NDArray data, int computeSize = 128)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_fft");
			string[] names2 = new string[1]
			{
				"compute_size"
			};
			string[] array = new string[1];
			object obj = computeSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribFft_004044110_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044112_002D1646(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004044113_002D1647(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribFft ContribFft([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> computeSize)
		{
			return new SymbolOperators.ContribFft(data, computeSize);
		}

		public static NDArray[] ContribIfft(NDArray data, int computeSize = 128)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_ifft");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044159_002D1648(data, 0, current));
			string[] parameterKeys = new string[1]
			{
				"compute_size"
			};
			string[] array = new string[1];
			object obj = computeSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribIfft_004044162();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribIfft(IEnumerable<NDArray> outputArray, NDArray data, int computeSize = 128)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_ifft");
			string[] names2 = new string[1]
			{
				"compute_size"
			};
			string[] array = new string[1];
			object obj = computeSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribIfft_004044186_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044188_002D1649(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004044189_002D1650(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribIfft ContribIfft([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<int> computeSize)
		{
			return new SymbolOperators.ContribIfft(data, computeSize);
		}

		public static NDArray[] ContribModulatedDeformableConvolution(NDArray data, NDArray offset, NDArray mask, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, int numDeformableGroup = 1, long workspace = 1024L, bool noBias = false, int im2colStep = 64, [Optional] GeneratedArgumentTypes.ContribModulatedDeformableConvolutionLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_ModulatedDeformableConvolution");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044296_002D1651(data, offset, mask, weight, bias, 0, current));
			string[] parameterKeys = new string[11]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"num_deformable_group",
				"workspace",
				"no_bias",
				"im2col_step",
				"layout"
			};
			string[] array = new string[11];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004044298_002D1652(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004044298_002D1653(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004044298_002D1654(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004044298_002D1655(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = numDeformableGroup;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			object obj13 = workspace;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			bool flag = noBias;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable9 = obj16 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj17 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[8] = (string)obj17;
			object obj19 = im2colStep;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable11 = obj19 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj20 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[9] = (string)obj20;
			object obj22;
			if ((layout == null) ? true : false)
			{
				obj22 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj22 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj23 = layout;
					obj22 = obj23.ToString();
				}
			}
			else
			{
				obj22 = "";
			}
			array[10] = (string)obj22;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val5 = new _0024Operators.ContribModulatedDeformableConvolution_004044299();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val5.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribModulatedDeformableConvolution(IEnumerable<NDArray> outputArray, NDArray data, NDArray offset, NDArray mask, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, int numDeformableGroup = 1, long workspace = 1024L, bool noBias = false, int im2colStep = 64, [Optional] GeneratedArgumentTypes.ContribModulatedDeformableConvolutionLayout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_ModulatedDeformableConvolution");
			string[] names2 = new string[11]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"num_deformable_group",
				"workspace",
				"no_bias",
				"im2col_step",
				"layout"
			};
			string[] array = new string[11];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004044383_002D316(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004044383_002D317(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004044383_002D318(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004044383_002D319(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = numDeformableGroup;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			object obj13 = workspace;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			bool flag = noBias;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable9 = obj16 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj17 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[8] = (string)obj17;
			object obj19 = im2colStep;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable11 = obj19 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj20 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[9] = (string)obj20;
			object obj22;
			if ((layout == null) ? true : false)
			{
				obj22 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj22 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj23 = layout;
					obj22 = obj23.ToString();
				}
			}
			else
			{
				obj22 = "";
			}
			array[10] = (string)obj22;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribModulatedDeformableConvolution_004044384_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044386_002D1656(data, offset, mask, weight, bias, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004044387_002D1657(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribModulatedDeformableConvolution ContribModulatedDeformableConvolution(Symbol data, Symbol offset, Symbol mask, Symbol weight, Symbol bias, IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<int> numDeformableGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<int> im2colStep, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribModulatedDeformableConvolutionLayout> layout)
		{
			return new SymbolOperators.ContribModulatedDeformableConvolution(data, offset, mask, weight, bias, kernel, numFilter, stride, dilate, pad, numGroup, numDeformableGroup, workspace, noBias, im2colStep, layout);
		}

		public static SymbolOperators.ContribModulatedDeformableConvolution ContribModulatedDeformableConvolution(IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> offset, [Optional] [OptionalArgument] FSharpOption<Symbol> mask, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> bias, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<int> numDeformableGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<int> im2colStep, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ContribModulatedDeformableConvolutionLayout> layout)
		{
			return new SymbolOperators.ContribModulatedDeformableConvolution(kernel, numFilter, data, offset, mask, weight, bias, stride, dilate, pad, numGroup, numDeformableGroup, workspace, noBias, im2colStep, layout);
		}

		public static NDArray[] ContribMultiProposal(NDArray clsProb, NDArray bboxPred, NDArray imInfo, int rpnPreNmsTopN = 6000, int rpnPostNmsTopN = 300, double threshold = 0.7, int rpnMinSize = 16, [Optional] IEnumerable<double> scales, [Optional] IEnumerable<double> ratios, int featureStride = 16, bool outputScore = false, bool iouLoss = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_MultiProposal");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044550_002D1658(clsProb, bboxPred, imInfo, 0, current));
			string[] parameterKeys = new string[9]
			{
				"rpn_pre_nms_top_n",
				"rpn_post_nms_top_n",
				"threshold",
				"rpn_min_size",
				"scales",
				"ratios",
				"feature_stride",
				"output_score",
				"iou_loss"
			};
			string[] array = new string[9];
			object obj = rpnPreNmsTopN;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = rpnPostNmsTopN;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = threshold;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rpnMinSize;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13;
			if ((scales == null) ? true : false)
			{
				obj13 = "[4,8,16,32]";
			}
			else if (scales != null)
			{
				IFormattable formattable9 = scales as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = scales;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15;
			if ((ratios == null) ? true : false)
			{
				obj15 = "[0.5,1,2]";
			}
			else if (ratios != null)
			{
				IFormattable formattable11 = ratios as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = ratios;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array[5] = (string)obj15;
			object obj17 = featureStride;
			object obj18;
			if (obj17 != null)
			{
				IFormattable formattable13 = obj17 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = obj17;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			array[6] = (string)obj18;
			bool flag = outputScore;
			object obj20 = flag;
			object obj21;
			if (obj20 != null)
			{
				IFormattable formattable15 = obj20 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj21 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = obj20;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[7] = (string)obj21;
			bool flag2 = iouLoss;
			object obj23 = flag2;
			object obj24;
			if (obj23 != null)
			{
				IFormattable formattable17 = obj23 as IFormattable;
				if (formattable17 != null)
				{
					IFormattable formattable18 = formattable17;
					obj24 = formattable18.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj25 = obj23;
					obj24 = obj25.ToString();
				}
			}
			else
			{
				obj24 = "";
			}
			array[8] = (string)obj24;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribMultiProposal_004044553();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribMultiProposal(IEnumerable<NDArray> outputArray, NDArray clsProb, NDArray bboxPred, NDArray imInfo, int rpnPreNmsTopN = 6000, int rpnPostNmsTopN = 300, double threshold = 0.7, int rpnMinSize = 16, [Optional] IEnumerable<double> scales, [Optional] IEnumerable<double> ratios, int featureStride = 16, bool outputScore = false, bool iouLoss = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_MultiProposal");
			string[] names2 = new string[9]
			{
				"rpn_pre_nms_top_n",
				"rpn_post_nms_top_n",
				"threshold",
				"rpn_min_size",
				"scales",
				"ratios",
				"feature_stride",
				"output_score",
				"iou_loss"
			};
			string[] array = new string[9];
			object obj = rpnPreNmsTopN;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = rpnPostNmsTopN;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = threshold;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rpnMinSize;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13;
			if ((scales == null) ? true : false)
			{
				obj13 = "[4,8,16,32]";
			}
			else if (scales != null)
			{
				IFormattable formattable9 = scales as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = scales;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15;
			if ((ratios == null) ? true : false)
			{
				obj15 = "[0.5,1,2]";
			}
			else if (ratios != null)
			{
				IFormattable formattable11 = ratios as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = ratios;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array[5] = (string)obj15;
			object obj17 = featureStride;
			object obj18;
			if (obj17 != null)
			{
				IFormattable formattable13 = obj17 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = obj17;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			array[6] = (string)obj18;
			bool flag = outputScore;
			object obj20 = flag;
			object obj21;
			if (obj20 != null)
			{
				IFormattable formattable15 = obj20 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj21 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = obj20;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[7] = (string)obj21;
			bool flag2 = iouLoss;
			object obj23 = flag2;
			object obj24;
			if (obj23 != null)
			{
				IFormattable formattable17 = obj23 as IFormattable;
				if (formattable17 != null)
				{
					IFormattable formattable18 = formattable17;
					obj24 = formattable18.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj25 = obj23;
					obj24 = obj25.ToString();
				}
			}
			else
			{
				obj24 = "";
			}
			array[8] = (string)obj24;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribMultiProposal_004044584_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044586_002D1659(clsProb, bboxPred, imInfo, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004044587_002D1660(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribMultiProposal ContribMultiProposal([Optional] [OptionalArgument] FSharpOption<Symbol> clsProb, [Optional] [OptionalArgument] FSharpOption<Symbol> bboxPred, [Optional] [OptionalArgument] FSharpOption<Symbol> imInfo, [Optional] [OptionalArgument] FSharpOption<int> rpnPreNmsTopN, [Optional] [OptionalArgument] FSharpOption<int> rpnPostNmsTopN, [Optional] [OptionalArgument] FSharpOption<double> threshold, [Optional] [OptionalArgument] FSharpOption<int> rpnMinSize, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> scales, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> ratios, [Optional] [OptionalArgument] FSharpOption<int> featureStride, [Optional] [OptionalArgument] FSharpOption<bool> outputScore, [Optional] [OptionalArgument] FSharpOption<bool> iouLoss)
		{
			return new SymbolOperators.ContribMultiProposal(clsProb, bboxPred, imInfo, rpnPreNmsTopN, rpnPostNmsTopN, threshold, rpnMinSize, scales, ratios, featureStride, outputScore, iouLoss);
		}

		public static NDArray[] ContribProposal(NDArray clsProb, NDArray bboxPred, NDArray imInfo, int rpnPreNmsTopN = 6000, int rpnPostNmsTopN = 300, double threshold = 0.7, int rpnMinSize = 16, [Optional] IEnumerable<double> scales, [Optional] IEnumerable<double> ratios, int featureStride = 16, bool outputScore = false, bool iouLoss = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_Proposal");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044638_002D1661(clsProb, bboxPred, imInfo, 0, current));
			string[] parameterKeys = new string[9]
			{
				"rpn_pre_nms_top_n",
				"rpn_post_nms_top_n",
				"threshold",
				"rpn_min_size",
				"scales",
				"ratios",
				"feature_stride",
				"output_score",
				"iou_loss"
			};
			string[] array = new string[9];
			object obj = rpnPreNmsTopN;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = rpnPostNmsTopN;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = threshold;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rpnMinSize;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13;
			if ((scales == null) ? true : false)
			{
				obj13 = "[4,8,16,32]";
			}
			else if (scales != null)
			{
				IFormattable formattable9 = scales as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = scales;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15;
			if ((ratios == null) ? true : false)
			{
				obj15 = "[0.5,1,2]";
			}
			else if (ratios != null)
			{
				IFormattable formattable11 = ratios as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = ratios;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array[5] = (string)obj15;
			object obj17 = featureStride;
			object obj18;
			if (obj17 != null)
			{
				IFormattable formattable13 = obj17 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = obj17;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			array[6] = (string)obj18;
			bool flag = outputScore;
			object obj20 = flag;
			object obj21;
			if (obj20 != null)
			{
				IFormattable formattable15 = obj20 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj21 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = obj20;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[7] = (string)obj21;
			bool flag2 = iouLoss;
			object obj23 = flag2;
			object obj24;
			if (obj23 != null)
			{
				IFormattable formattable17 = obj23 as IFormattable;
				if (formattable17 != null)
				{
					IFormattable formattable18 = formattable17;
					obj24 = formattable18.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj25 = obj23;
					obj24 = obj25.ToString();
				}
			}
			else
			{
				obj24 = "";
			}
			array[8] = (string)obj24;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.ContribProposal_004044641();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void ContribProposal(IEnumerable<NDArray> outputArray, NDArray clsProb, NDArray bboxPred, NDArray imInfo, int rpnPreNmsTopN = 6000, int rpnPostNmsTopN = 300, double threshold = 0.7, int rpnMinSize = 16, [Optional] IEnumerable<double> scales, [Optional] IEnumerable<double> ratios, int featureStride = 16, bool outputScore = false, bool iouLoss = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_contrib_Proposal");
			string[] names2 = new string[9]
			{
				"rpn_pre_nms_top_n",
				"rpn_post_nms_top_n",
				"threshold",
				"rpn_min_size",
				"scales",
				"ratios",
				"feature_stride",
				"output_score",
				"iou_loss"
			};
			string[] array = new string[9];
			object obj = rpnPreNmsTopN;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = rpnPostNmsTopN;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = threshold;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = rpnMinSize;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13;
			if ((scales == null) ? true : false)
			{
				obj13 = "[4,8,16,32]";
			}
			else if (scales != null)
			{
				IFormattable formattable9 = scales as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj13 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj14 = scales;
					obj13 = obj14.ToString();
				}
			}
			else
			{
				obj13 = "";
			}
			array[4] = (string)obj13;
			object obj15;
			if ((ratios == null) ? true : false)
			{
				obj15 = "[0.5,1,2]";
			}
			else if (ratios != null)
			{
				IFormattable formattable11 = ratios as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj15 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj16 = ratios;
					obj15 = obj16.ToString();
				}
			}
			else
			{
				obj15 = "";
			}
			array[5] = (string)obj15;
			object obj17 = featureStride;
			object obj18;
			if (obj17 != null)
			{
				IFormattable formattable13 = obj17 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj18 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj19 = obj17;
					obj18 = obj19.ToString();
				}
			}
			else
			{
				obj18 = "";
			}
			array[6] = (string)obj18;
			bool flag = outputScore;
			object obj20 = flag;
			object obj21;
			if (obj20 != null)
			{
				IFormattable formattable15 = obj20 as IFormattable;
				if (formattable15 != null)
				{
					IFormattable formattable16 = formattable15;
					obj21 = formattable16.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = obj20;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[7] = (string)obj21;
			bool flag2 = iouLoss;
			object obj23 = flag2;
			object obj24;
			if (obj23 != null)
			{
				IFormattable formattable17 = obj23 as IFormattable;
				if (formattable17 != null)
				{
					IFormattable formattable18 = formattable17;
					obj24 = formattable18.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj25 = obj23;
					obj24 = obj25.ToString();
				}
			}
			else
			{
				obj24 = "";
			}
			array[8] = (string)obj24;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ContribProposal_004044672_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044674_002D1662(clsProb, bboxPred, imInfo, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004044675_002D1663(), outputArray)), names, vals);
		}

		public static SymbolOperators.ContribProposal ContribProposal([Optional] [OptionalArgument] FSharpOption<Symbol> clsProb, [Optional] [OptionalArgument] FSharpOption<Symbol> bboxPred, [Optional] [OptionalArgument] FSharpOption<Symbol> imInfo, [Optional] [OptionalArgument] FSharpOption<int> rpnPreNmsTopN, [Optional] [OptionalArgument] FSharpOption<int> rpnPostNmsTopN, [Optional] [OptionalArgument] FSharpOption<double> threshold, [Optional] [OptionalArgument] FSharpOption<int> rpnMinSize, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> scales, [Optional] [OptionalArgument] FSharpOption<IEnumerable<double>> ratios, [Optional] [OptionalArgument] FSharpOption<int> featureStride, [Optional] [OptionalArgument] FSharpOption<bool> outputScore, [Optional] [OptionalArgument] FSharpOption<bool> iouLoss)
		{
			return new SymbolOperators.ContribProposal(clsProb, bboxPred, imInfo, rpnPreNmsTopN, rpnPostNmsTopN, threshold, rpnMinSize, scales, ratios, featureStride, outputScore, iouLoss);
		}

		public static SymbolOperators.ContribPSROIPooling ContribPSROIPooling(Symbol data, Symbol rois, double spatialScale, int outputDim, int pooledSize, [Optional] [OptionalArgument] FSharpOption<int> groupSize)
		{
			return new SymbolOperators.ContribPSROIPooling(data, rois, spatialScale, outputDim, pooledSize, groupSize);
		}

		public static SymbolOperators.ContribPSROIPooling ContribPSROIPooling(double spatialScale, int outputDim, int pooledSize, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> rois, [Optional] [OptionalArgument] FSharpOption<int> groupSize)
		{
			return new SymbolOperators.ContribPSROIPooling(spatialScale, outputDim, pooledSize, data, rois, groupSize);
		}

		public static NDArray ConvolutionV1(NDArray data, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, long workspace = 1024L, bool noBias = false, [Optional] GeneratedArgumentTypes.CudnnTune cudnnTune, bool cudnnOff = false, [Optional] GeneratedArgumentTypes.ConvolutionV1Layout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Convolution_v1");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044757_002D1664(data, weight, bias, 0, current));
			string[] parameterKeys = new string[11]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"workspace",
				"no_bias",
				"cudnn_tune",
				"cudnn_off",
				"layout"
			};
			string[] array = new string[11];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004044759_002D1665(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004044759_002D1666(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004044759_002D1667(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004044759_002D1668(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = workspace;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			bool flag = noBias;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			object obj16;
			if ((cudnnTune == null) ? true : false)
			{
				obj16 = "None";
			}
			else if (cudnnTune != null)
			{
				IFormattable formattable9 = cudnnTune as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = cudnnTune;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[8] = (string)obj16;
			bool flag2 = cudnnOff;
			object obj18 = flag2;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable11 = obj18 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[9] = (string)obj19;
			object obj21;
			if ((layout == null) ? true : false)
			{
				obj21 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj21 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = layout;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[10] = (string)obj21;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void ConvolutionV1(IEnumerable<NDArray> outputArray, NDArray data, NDArray weight, NDArray bias, IEnumerable<int> kernel, int numFilter, [Optional] IEnumerable<int> stride, [Optional] IEnumerable<int> dilate, [Optional] IEnumerable<int> pad, int numGroup = 1, long workspace = 1024L, bool noBias = false, [Optional] GeneratedArgumentTypes.CudnnTune cudnnTune, bool cudnnOff = false, [Optional] GeneratedArgumentTypes.ConvolutionV1Layout layout)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Convolution_v1");
			string[] names2 = new string[11]
			{
				"kernel",
				"num_filter",
				"stride",
				"dilate",
				"pad",
				"num_group",
				"workspace",
				"no_bias",
				"cudnn_tune",
				"cudnn_off",
				"layout"
			};
			string[] array = new string[11];
			string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004044803_002D320(), kernel));
			FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
			string text2 = text;
			array[0] = val.Invoke(text2);
			object obj = numFilter;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[1] = (string)obj2;
			object obj4;
			if ((stride == null) ? true : false)
			{
				obj4 = "[]";
			}
			else
			{
				string text3 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004044803_002D321(), stride));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text4 = text3;
				obj4 = val2.Invoke(text4);
			}
			array[2] = (string)obj4;
			object obj5;
			if ((dilate == null) ? true : false)
			{
				obj5 = "[]";
			}
			else
			{
				string text5 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004044803_002D322(), dilate));
				FSharpFunc<string, string> val3 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text6 = text5;
				obj5 = val3.Invoke(text6);
			}
			array[3] = (string)obj5;
			object obj6;
			if ((pad == null) ? true : false)
			{
				obj6 = "[]";
			}
			else
			{
				string text7 = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004044803_002D323(), pad));
				FSharpFunc<string, string> val4 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text8 = text7;
				obj6 = val4.Invoke(text8);
			}
			array[4] = (string)obj6;
			object obj7 = numGroup;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable3 = obj7 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj8 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[5] = (string)obj8;
			object obj10 = workspace;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable5 = obj10 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj11 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[6] = (string)obj11;
			bool flag = noBias;
			object obj13 = flag;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable7 = obj13 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj14 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[7] = (string)obj14;
			object obj16;
			if ((cudnnTune == null) ? true : false)
			{
				obj16 = "None";
			}
			else if (cudnnTune != null)
			{
				IFormattable formattable9 = cudnnTune as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj16 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj17 = cudnnTune;
					obj16 = obj17.ToString();
				}
			}
			else
			{
				obj16 = "";
			}
			array[8] = (string)obj16;
			bool flag2 = cudnnOff;
			object obj18 = flag2;
			object obj19;
			if (obj18 != null)
			{
				IFormattable formattable11 = obj18 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj19 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj20 = obj18;
					obj19 = obj20.ToString();
				}
			}
			else
			{
				obj19 = "";
			}
			array[9] = (string)obj19;
			object obj21;
			if ((layout == null) ? true : false)
			{
				obj21 = "None";
			}
			else if (layout != null)
			{
				IFormattable formattable13 = layout as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj21 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj22 = layout;
					obj21 = obj22.ToString();
				}
			}
			else
			{
				obj21 = "";
			}
			array[10] = (string)obj21;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.ConvolutionV1_004044804(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044806_002D1669(data, weight, bias, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004044807_002D1670(), outputArray)), names, vals);
		}

		public static SymbolOperators.ConvolutionV1 ConvolutionV1(Symbol data, Symbol weight, Symbol bias, IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.CudnnTune> cudnnTune, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ConvolutionV1Layout> layout)
		{
			return new SymbolOperators.ConvolutionV1(data, weight, bias, kernel, numFilter, stride, dilate, pad, numGroup, workspace, noBias, cudnnTune, cudnnOff, layout);
		}

		public static SymbolOperators.ConvolutionV1 ConvolutionV1(IEnumerable<int> kernel, int numFilter, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> weight, [Optional] [OptionalArgument] FSharpOption<Symbol> bias, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> stride, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> dilate, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> pad, [Optional] [OptionalArgument] FSharpOption<int> numGroup, [Optional] [OptionalArgument] FSharpOption<long> workspace, [Optional] [OptionalArgument] FSharpOption<bool> noBias, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.CudnnTune> cudnnTune, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.ConvolutionV1Layout> layout)
		{
			return new SymbolOperators.ConvolutionV1(kernel, numFilter, data, weight, bias, stride, dilate, pad, numGroup, workspace, noBias, cudnnTune, cudnnOff, layout);
		}

		public static NDArray[] Correlation(NDArray data1, NDArray data2, int kernelSize = 1, int maxDisplacement = 1, int stride1 = 1, int stride2 = 1, int padSize = 0, bool isMultiply = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Correlation");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044917_002D1671(data1, data2, 0, current));
			string[] parameterKeys = new string[6]
			{
				"kernel_size",
				"max_displacement",
				"stride1",
				"stride2",
				"pad_size",
				"is_multiply"
			};
			string[] array = new string[6];
			object obj = kernelSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxDisplacement;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = stride1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = stride2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = padSize;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			bool flag = isMultiply;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.Correlation_004044920();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void Correlation(IEnumerable<NDArray> outputArray, NDArray data1, NDArray data2, int kernelSize = 1, int maxDisplacement = 1, int stride1 = 1, int stride2 = 1, int padSize = 0, bool isMultiply = true)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("Correlation");
			string[] names2 = new string[6]
			{
				"kernel_size",
				"max_displacement",
				"stride1",
				"stride2",
				"pad_size",
				"is_multiply"
			};
			string[] array = new string[6];
			object obj = kernelSize;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = maxDisplacement;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = stride1;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = stride2;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = padSize;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			bool flag = isMultiply;
			object obj16 = flag;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Correlation_004044976_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004044978_002D1672(data1, data2, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004044979_002D1673(), outputArray)), names, vals);
		}

		public static SymbolOperators.Correlation Correlation([Optional] [OptionalArgument] FSharpOption<Symbol> data1, [Optional] [OptionalArgument] FSharpOption<Symbol> data2, [Optional] [OptionalArgument] FSharpOption<int> kernelSize, [Optional] [OptionalArgument] FSharpOption<int> maxDisplacement, [Optional] [OptionalArgument] FSharpOption<int> stride1, [Optional] [OptionalArgument] FSharpOption<int> stride2, [Optional] [OptionalArgument] FSharpOption<int> padSize, [Optional] [OptionalArgument] FSharpOption<bool> isMultiply)
		{
			return new SymbolOperators.Correlation(data1, data2, kernelSize, maxDisplacement, stride1, stride2, padSize, isMultiply);
		}

		public static NDArray[] CrossDeviceCopyNDArray()
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_CrossDeviceCopy");
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.CrossDeviceCopyNDArray_004045037();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void CrossDeviceCopy(IEnumerable<NDArray> outputArray)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_CrossDeviceCopy");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004045042_002D203();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004045043_002D324();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.CrossDeviceCopy_004045044(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004045047_002D1674(), outputArray)), names, vals);
		}

		public static SymbolOperators.CrossDeviceCopy CrossDeviceCopy()
		{
			return new SymbolOperators.CrossDeviceCopy();
		}

		public static NDArray[] GridGenerator(NDArray data, GeneratedArgumentTypes.GridGeneratorTransformType transformType, [Optional] IEnumerable<int> targetShape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("GridGenerator");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045065_002D1675(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"transform_type",
				"target_shape"
			};
			string[] array = new string[2];
			object obj;
			if (transformType != null)
			{
				IFormattable formattable = transformType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = transformType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((targetShape == null) ? true : false)
			{
				obj3 = "[0,0]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004045067_002D1676(), targetShape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val2 = new _0024Operators.GridGenerator_004045068();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val2.Invoke(array3[i]);
			}
			return array4;
		}

		public static void GridGenerator(IEnumerable<NDArray> outputArray, NDArray data, GeneratedArgumentTypes.GridGeneratorTransformType transformType, [Optional] IEnumerable<int> targetShape)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("GridGenerator");
			string[] names2 = new string[2]
			{
				"transform_type",
				"target_shape"
			};
			string[] array = new string[2];
			object obj;
			if (transformType != null)
			{
				IFormattable formattable = transformType as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj2 = transformType;
					obj = obj2.ToString();
				}
			}
			else
			{
				obj = "";
			}
			array[0] = (string)obj;
			object obj3;
			if ((targetShape == null) ? true : false)
			{
				obj3 = "[0,0]";
			}
			else
			{
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004045077_002D325(), targetShape));
				FSharpFunc<string, string> val = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj3 = val.Invoke(text2);
			}
			array[1] = (string)obj3;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.GridGenerator_004045078_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045080_002D1677(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004045081_002D1678(), outputArray)), names, vals);
		}

		public static SymbolOperators.GridGenerator GridGenerator(Symbol data, GeneratedArgumentTypes.GridGeneratorTransformType transformType, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape)
		{
			return new SymbolOperators.GridGenerator(data, transformType, targetShape);
		}

		public static SymbolOperators.GridGenerator GridGenerator(GeneratedArgumentTypes.GridGeneratorTransformType transformType, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape)
		{
			return new SymbolOperators.GridGenerator(transformType, data, targetShape);
		}

		public static NDArray InstanceNorm(NDArray data, NDArray gamma, NDArray beta, double eps = 0.001)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("InstanceNorm");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045149_002D1679(data, gamma, beta, 0, current));
			string[] parameterKeys = new string[1]
			{
				"eps"
			};
			string[] array = new string[1];
			object obj = eps;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void InstanceNorm(IEnumerable<NDArray> outputArray, NDArray data, NDArray gamma, NDArray beta, double eps = 0.001)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("InstanceNorm");
			string[] names2 = new string[1]
			{
				"eps"
			};
			string[] array = new string[1];
			object obj = eps;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.InstanceNorm_004045204(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045206_002D1680(data, gamma, beta, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004045207_002D1681(), outputArray)), names, vals);
		}

		public static SymbolOperators.InstanceNorm InstanceNorm([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> gamma, [Optional] [OptionalArgument] FSharpOption<Symbol> beta, [Optional] [OptionalArgument] FSharpOption<double> eps)
		{
			return new SymbolOperators.InstanceNorm(data, gamma, beta, eps);
		}

		public static NDArray L2Normalization(NDArray data, double eps = 0.0, [Optional] GeneratedArgumentTypes.L2NormalizationMode mode)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("L2Normalization");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045322_002D1682(data, 0, current));
			string[] parameterKeys = new string[2]
			{
				"eps",
				"mode"
			};
			string[] array = new string[2];
			object obj = eps;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if ((mode == null) ? true : false)
			{
				obj4 = "instance";
			}
			else if (mode != null)
			{
				IFormattable formattable3 = mode as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = mode;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void L2Normalization(IEnumerable<NDArray> outputArray, NDArray data, double eps = 0.0, [Optional] GeneratedArgumentTypes.L2NormalizationMode mode)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("L2Normalization");
			string[] names2 = new string[2]
			{
				"eps",
				"mode"
			};
			string[] array = new string[2];
			object obj = eps;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4;
			if ((mode == null) ? true : false)
			{
				obj4 = "instance";
			}
			else if (mode != null)
			{
				IFormattable formattable3 = mode as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj4 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj5 = mode;
					obj4 = obj5.ToString();
				}
			}
			else
			{
				obj4 = "";
			}
			array[1] = (string)obj4;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.L2Normalization_004045389(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045391_002D1683(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004045392_002D1684(), outputArray)), names, vals);
		}

		public static SymbolOperators.L2Normalization L2Normalization([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> eps, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.L2NormalizationMode> mode)
		{
			return new SymbolOperators.L2Normalization(data, eps, mode);
		}

		public static NDArray MakeLoss(NDArray data, double gradScale = 1.0, double validThresh = 0.0, [Optional] GeneratedArgumentTypes.Normalization normalization)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("MakeLoss");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045489_002D1685(data, 0, current));
			string[] parameterKeys = new string[3]
			{
				"grad_scale",
				"valid_thresh",
				"normalization"
			};
			string[] array = new string[3];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = validThresh;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((normalization == null) ? true : false)
			{
				obj7 = "null";
			}
			else if (normalization != null)
			{
				IFormattable formattable5 = normalization as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = normalization;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void MakeLoss(IEnumerable<NDArray> outputArray, NDArray data, double gradScale = 1.0, double validThresh = 0.0, [Optional] GeneratedArgumentTypes.Normalization normalization)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("MakeLoss");
			string[] names2 = new string[3]
			{
				"grad_scale",
				"valid_thresh",
				"normalization"
			};
			string[] array = new string[3];
			object obj = gradScale;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = validThresh;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7;
			if ((normalization == null) ? true : false)
			{
				obj7 = "null";
			}
			else if (normalization != null)
			{
				IFormattable formattable5 = normalization as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj7 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj8 = normalization;
					obj7 = obj8.ToString();
				}
			}
			else
			{
				obj7 = "";
			}
			array[2] = (string)obj7;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.MakeLoss_004045526_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045528_002D1686(data, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004045529_002D1687(), outputArray)), names, vals);
		}

		public static SymbolOperators.MakeLoss MakeLoss([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<double> gradScale, [Optional] [OptionalArgument] FSharpOption<double> validThresh, [Optional] [OptionalArgument] FSharpOption<GeneratedArgumentTypes.Normalization> normalization)
		{
			return new SymbolOperators.MakeLoss(data, gradScale, validThresh, normalization);
		}

		public static NDArray SequenceLast(NDArray data, NDArray sequenceLength, bool useSequenceLength = false, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SequenceLast");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045622_002D1688(data, sequenceLength, 0, current));
			string[] parameterKeys = new string[2]
			{
				"use_sequence_length",
				"axis"
			};
			string[] array = new string[2];
			bool flag = useSequenceLength;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SequenceLast(IEnumerable<NDArray> outputArray, NDArray data, NDArray sequenceLength, bool useSequenceLength = false, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SequenceLast");
			string[] names2 = new string[2]
			{
				"use_sequence_length",
				"axis"
			};
			string[] array = new string[2];
			bool flag = useSequenceLength;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SequenceLast_004045682(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045684_002D1689(data, sequenceLength, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004045685_002D1690(), outputArray)), names, vals);
		}

		public static SymbolOperators.SequenceLast SequenceLast([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> sequenceLength, [Optional] [OptionalArgument] FSharpOption<bool> useSequenceLength, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.SequenceLast(data, sequenceLength, useSequenceLength, axis);
		}

		public static NDArray SequenceReverse(NDArray data, NDArray sequenceLength, bool useSequenceLength = false, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SequenceReverse");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045820_002D1691(data, sequenceLength, 0, current));
			string[] parameterKeys = new string[2]
			{
				"use_sequence_length",
				"axis"
			};
			string[] array = new string[2];
			bool flag = useSequenceLength;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SequenceReverse(IEnumerable<NDArray> outputArray, NDArray data, NDArray sequenceLength, bool useSequenceLength = false, int axis = 0)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SequenceReverse");
			string[] names2 = new string[2]
			{
				"use_sequence_length",
				"axis"
			};
			string[] array = new string[2];
			bool flag = useSequenceLength;
			object obj = flag;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = axis;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SequenceReverse_004045901(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045903_002D1692(data, sequenceLength, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004045904_002D1693(), outputArray)), names, vals);
		}

		public static SymbolOperators.SequenceReverse SequenceReverse([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> sequenceLength, [Optional] [OptionalArgument] FSharpOption<bool> useSequenceLength, [Optional] [OptionalArgument] FSharpOption<int> axis)
		{
			return new SymbolOperators.SequenceReverse(data, sequenceLength, useSequenceLength, axis);
		}

		public static NDArray[] SpatialTransformer(NDArray data, NDArray loc, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SpatialTransformer");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004045995_002D1694(data, loc, 0, current));
			string[] parameterKeys = new string[4]
			{
				"transform_type",
				"sampler_type",
				"target_shape",
				"cudnn_off"
			};
			string[] obj = new string[4]
			{
				"affine",
				"bilinear",
				null,
				null
			};
			object obj2;
			if (targetShape == null)
			{
				obj2 = "[0,0]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = targetShape;
				IEnumerable<int> targetShape2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.outputs_004045997_002D1695(), targetShape2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj2 = val2.Invoke(text2);
			}
			obj[2] = (string)obj2;
			object obj3;
			if (cudnnOff == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<bool> val3 = cudnnOff;
				bool cudnnOff2 = val3.get_Value();
				bool flag = cudnnOff2;
				object obj4 = flag;
				if (obj4 != null)
				{
					IFormattable formattable = obj4 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			obj[3] = (string)obj3;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, obj);
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val4 = new _0024Operators.SpatialTransformer_004045998();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val4.Invoke(array2[i]);
			}
			return array3;
		}

		public static void SpatialTransformer(IEnumerable<NDArray> outputArray, NDArray data, NDArray loc, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SpatialTransformer");
			string[] names2 = new string[4]
			{
				"transform_type",
				"sampler_type",
				"target_shape",
				"cudnn_off"
			};
			string[] obj = new string[4]
			{
				"affine",
				"bilinear",
				null,
				null
			};
			object obj2;
			if (targetShape == null)
			{
				obj2 = "[0,0]";
			}
			else
			{
				FSharpOption<IEnumerable<int>> val = targetShape;
				IEnumerable<int> targetShape2 = val.get_Value();
				string text = StringModule.Concat(", ", SeqModule.Map<int, string>((FSharpFunc<int, string>)new _0024Operators.vals_004046010_002D326(), targetShape2));
				FSharpFunc<string, string> val2 = ExtraTopLevelOperators.PrintFormatToString<FSharpFunc<string, string>>((PrintfFormat<FSharpFunc<string, string>, Unit, string, string>)(object)new PrintfFormat<FSharpFunc<string, string>, Unit, string, string, string>("[%s]"));
				string text2 = text;
				obj2 = val2.Invoke(text2);
			}
			obj[2] = (string)obj2;
			object obj3;
			if (cudnnOff == null)
			{
				obj3 = "None";
			}
			else
			{
				FSharpOption<bool> val3 = cudnnOff;
				bool cudnnOff2 = val3.get_Value();
				bool flag = cudnnOff2;
				object obj4 = flag;
				if (obj4 != null)
				{
					IFormattable formattable = obj4 as IFormattable;
					if (formattable != null)
					{
						IFormattable formattable2 = formattable;
						obj3 = formattable2.ToString(null, CultureInfo.InvariantCulture);
					}
					else
					{
						object obj5 = obj4;
						obj3 = obj5.ToString();
					}
				}
				else
				{
					obj3 = "";
				}
			}
			obj[3] = (string)obj3;
			string[] vals2 = obj;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SpatialTransformer_004046011_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046013_002D1696(data, loc, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004046014_002D1697(), outputArray)), names, vals);
		}

		public static SymbolOperators.SpatialTransformer SpatialTransformer(Symbol data, Symbol loc, GeneratedArgumentTypes.SpatialTransformerTransformType transformType, GeneratedArgumentTypes.SamplerType samplerType, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			return new SymbolOperators.SpatialTransformer(data, loc, transformType, samplerType, targetShape, cudnnOff);
		}

		public static SymbolOperators.SpatialTransformer SpatialTransformer(GeneratedArgumentTypes.SpatialTransformerTransformType transformType, GeneratedArgumentTypes.SamplerType samplerType, [Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> loc, [Optional] [OptionalArgument] FSharpOption<IEnumerable<int>> targetShape, [Optional] [OptionalArgument] FSharpOption<bool> cudnnOff)
		{
			return new SymbolOperators.SpatialTransformer(transformType, samplerType, data, loc, targetShape, cudnnOff);
		}

		public static NDArray SVMOutput(NDArray data, NDArray label, double margin = 1.0, double regularizationCoefficient = 1.0, bool useLinear = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SVMOutput");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046056_002D1698(data, label, 0, current));
			string[] parameterKeys = new string[3]
			{
				"margin",
				"regularization_coefficient",
				"use_linear"
			};
			string[] array = new string[3];
			object obj = margin;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = regularizationCoefficient;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = useLinear;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			return new NDArray(outputs[0]);
		}

		public static void SVMOutput(IEnumerable<NDArray> outputArray, NDArray data, NDArray label, double margin = 1.0, double regularizationCoefficient = 1.0, bool useLinear = false)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("SVMOutput");
			string[] names2 = new string[3]
			{
				"margin",
				"regularization_coefficient",
				"use_linear"
			};
			string[] array = new string[3];
			object obj = margin;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = regularizationCoefficient;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			bool flag = useLinear;
			object obj7 = flag;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SVMOutput_004046081(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046083_002D1699(data, label, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004046084_002D1700(), outputArray)), names, vals);
		}

		public static SymbolOperators.SVMOutput SVMOutput([Optional] [OptionalArgument] FSharpOption<Symbol> data, [Optional] [OptionalArgument] FSharpOption<Symbol> label, [Optional] [OptionalArgument] FSharpOption<double> margin, [Optional] [OptionalArgument] FSharpOption<double> regularizationCoefficient, [Optional] [OptionalArgument] FSharpOption<bool> useLinear)
		{
			return new SymbolOperators.SVMOutput(data, label, margin, regularizationCoefficient, useLinear);
		}

		public static NDArray[] SetValueNDArray(double src)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_set_value");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr[] inputs = ArrayModule.Empty<IntPtr>();
			string[] parameterKeys = new string[1]
			{
				"src"
			};
			string[] array = new string[1];
			object obj = src;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.SetValueNDArray_004046111();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void SetValue(IEnumerable<NDArray> outputArray, double src)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_set_value");
			string[] names2 = new string[1]
			{
				"src"
			};
			string[] array = new string[1];
			object obj = src;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.SetValue_004046118(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, ArrayModule.Empty<IntPtr>(), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004046121_002D1701(), outputArray)), names, vals);
		}

		public static SymbolOperators.SetValue SetValue(double src)
		{
			return new SymbolOperators.SetValue(src);
		}

		public static NDArray[] OnehotEncode(NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_onehot_encode");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046134_002D1702(lhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.OnehotEncode_004046137();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void OnehotEncode(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_onehot_encode");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004046143_002D204();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004046144_002D327();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.OnehotEncode_004046145_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046147_002D1703(lhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004046148_002D1704(), outputArray)), names, vals);
		}

		public static NDArray[] FillElement0index(NDArray lhs, NDArray mhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("fill_element_0index");
			IntPtr current = default(IntPtr);
			IntPtr[] outputs = MXNDArray.imperativeInvoke(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046160_002D1705(lhs, mhs, rhs, 0, current)), ArrayModule.Empty<string>(), ArrayModule.Empty<string>());
			IntPtr[] array = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.FillElement0index_004046163();
			IntPtr[] array2 = array;
			if (array2 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array3 = new NDArray[array2.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = val.Invoke(array2[i]);
			}
			return array3;
		}

		public static void FillElement0index(IEnumerable<NDArray> outputArray, NDArray lhs, NDArray mhs, NDArray rhs)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("fill_element_0index");
			FSharpTypeFunc names2 = (FSharpTypeFunc)(object)new _0024Operators.names_004046171_002D205();
			FSharpTypeFunc vals2 = (FSharpTypeFunc)(object)new _0024Operators.vals_004046172_002D328();
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.FillElement0index_004046173_002D1(), ArrayModule.Zip<string, string>((string[])names2.Specialize<string>(), (string[])vals2.Specialize<string>())));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046175_002D1706(lhs, mhs, rhs, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004046176_002D1707(), outputArray)), names, vals);
		}

		public static NDArray[] Imdecode(NDArray mean, int index, int x0, int y0, int x1, int y1, int c, int size)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_imdecode");
			IntPtr atomicSymbolCreatorHandle = creator.AtomicSymbolCreatorHandle;
			IntPtr current = default(IntPtr);
			IntPtr[] inputs = SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046200_002D1708(mean, 0, current));
			string[] parameterKeys = new string[7]
			{
				"index",
				"x0",
				"y0",
				"x1",
				"y1",
				"c",
				"size"
			};
			string[] array = new string[7];
			object obj = index;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = x0;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = y0;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = x1;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = y1;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = c;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = size;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			IntPtr[] outputs = MXNDArray.imperativeInvoke(atomicSymbolCreatorHandle, inputs, parameterKeys, array);
			IntPtr[] array2 = outputs;
			FSharpFunc<IntPtr, NDArray> val = new _0024Operators.Imdecode_004046203();
			IntPtr[] array3 = array2;
			if (array3 == null)
			{
				throw new ArgumentNullException("array");
			}
			NDArray[] array4 = new NDArray[array3.Length];
			for (int i = 0; i < array4.Length; i++)
			{
				array4[i] = val.Invoke(array3[i]);
			}
			return array4;
		}

		public static void Imdecode(IEnumerable<NDArray> outputArray, NDArray mean, int index, int x0, int y0, int x1, int y1, int c, int size)
		{
			AtomicSymbolCreator creator = AtomicSymbolCreator.FromName("_imdecode");
			string[] names2 = new string[7]
			{
				"index",
				"x0",
				"y0",
				"x1",
				"y1",
				"c",
				"size"
			};
			string[] array = new string[7];
			object obj = index;
			object obj2;
			if (obj != null)
			{
				IFormattable formattable = obj as IFormattable;
				if (formattable != null)
				{
					IFormattable formattable2 = formattable;
					obj2 = formattable2.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj3 = obj;
					obj2 = obj3.ToString();
				}
			}
			else
			{
				obj2 = "";
			}
			array[0] = (string)obj2;
			object obj4 = x0;
			object obj5;
			if (obj4 != null)
			{
				IFormattable formattable3 = obj4 as IFormattable;
				if (formattable3 != null)
				{
					IFormattable formattable4 = formattable3;
					obj5 = formattable4.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj6 = obj4;
					obj5 = obj6.ToString();
				}
			}
			else
			{
				obj5 = "";
			}
			array[1] = (string)obj5;
			object obj7 = y0;
			object obj8;
			if (obj7 != null)
			{
				IFormattable formattable5 = obj7 as IFormattable;
				if (formattable5 != null)
				{
					IFormattable formattable6 = formattable5;
					obj8 = formattable6.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj9 = obj7;
					obj8 = obj9.ToString();
				}
			}
			else
			{
				obj8 = "";
			}
			array[2] = (string)obj8;
			object obj10 = x1;
			object obj11;
			if (obj10 != null)
			{
				IFormattable formattable7 = obj10 as IFormattable;
				if (formattable7 != null)
				{
					IFormattable formattable8 = formattable7;
					obj11 = formattable8.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj12 = obj10;
					obj11 = obj12.ToString();
				}
			}
			else
			{
				obj11 = "";
			}
			array[3] = (string)obj11;
			object obj13 = y1;
			object obj14;
			if (obj13 != null)
			{
				IFormattable formattable9 = obj13 as IFormattable;
				if (formattable9 != null)
				{
					IFormattable formattable10 = formattable9;
					obj14 = formattable10.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj15 = obj13;
					obj14 = obj15.ToString();
				}
			}
			else
			{
				obj14 = "";
			}
			array[4] = (string)obj14;
			object obj16 = c;
			object obj17;
			if (obj16 != null)
			{
				IFormattable formattable11 = obj16 as IFormattable;
				if (formattable11 != null)
				{
					IFormattable formattable12 = formattable11;
					obj17 = formattable12.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj18 = obj16;
					obj17 = obj18.ToString();
				}
			}
			else
			{
				obj17 = "";
			}
			array[5] = (string)obj17;
			object obj19 = size;
			object obj20;
			if (obj19 != null)
			{
				IFormattable formattable13 = obj19 as IFormattable;
				if (formattable13 != null)
				{
					IFormattable formattable14 = formattable13;
					obj20 = formattable14.ToString(null, CultureInfo.InvariantCulture);
				}
				else
				{
					object obj21 = obj19;
					obj20 = obj21.ToString();
				}
			}
			else
			{
				obj20 = "";
			}
			array[6] = (string)obj20;
			string[] vals2 = array;
			Tuple<string[], string[]> tuple = ArrayModule.Unzip<string, string>(ArrayModule.Choose<Tuple<string, string>, Tuple<string, string>>((FSharpFunc<Tuple<string, string>, FSharpOption<Tuple<string, string>>>)new _0024Operators.Imdecode_004046226_002D1(), ArrayModule.Zip<string, string>(names2, vals2)));
			string[] vals = tuple.Item2;
			string[] names = tuple.Item1;
			IntPtr current = default(IntPtr);
			int outputs = MXNDArray.imperativeInvokeInto(creator.AtomicSymbolCreatorHandle, SeqModule.ToArray<IntPtr>((IEnumerable<IntPtr>)(object)new _0024Operators.outputs_004046228_002D1709(mean, 0, current)), SeqModule.ToArray<IntPtr>(SeqModule.Map<NDArray, IntPtr>((FSharpFunc<NDArray, IntPtr>)new _0024Operators.outputs_004046229_002D1710(), outputArray)), names, vals);
		}

		public static SymbolOperators.Imdecode Imdecode(Symbol mean, int index, int x0, int y0, int x1, int y1, int c, int size)
		{
			return new SymbolOperators.Imdecode(mean, index, x0, y0, x1, y1, c, size);
		}

		public static SymbolOperators.Imdecode Imdecode(int index, int x0, int y0, int x1, int y1, int c, int size, [Optional] [OptionalArgument] FSharpOption<Symbol> mean)
		{
			return new SymbolOperators.Imdecode(index, x0, y0, x1, y1, c, size, mean);
		}
	}
}
